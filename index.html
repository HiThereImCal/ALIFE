<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ALIFE â€” Artificial Life Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Syncopate:wght@400;700&display=swap');

  :root {
    --bg: #060810;
    --panel: #0a0e1a;
    --border: #1a2240;
    --accent: #00f5c4;
    --accent2: #ff4d6d;
    --accent3: #ffd166;
    --text: #8899bb;
    --text-bright: #ccd6f6;
    --grid: rgba(0,245,196,0.04);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
  }

  .logo {
    font-family: 'Syncopate', sans-serif;
    font-weight: 700;
    font-size: 18px;
    letter-spacing: 6px;
    color: var(--accent);
    text-shadow: 0 0 20px rgba(0,245,196,0.5);
  }
  .logo span { color: var(--text); font-weight: 400; }

  .header-stats {
    display: flex;
    gap: 24px;
    font-size: 11px;
    letter-spacing: 1px;
  }

  .stat { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .stat-val { color: var(--accent); font-size: 16px; font-weight: bold; }
  .stat-lbl { color: var(--text); opacity: 0.6; font-size: 9px; letter-spacing: 2px; text-transform: uppercase; }

  .by-cal-link {
    display: flex;
    align-items: center;
    gap: 7px;
    text-decoration: none;
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--text);
    opacity: 0.8;
    border: 1px solid var(--border);
    padding: 5px 11px;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .by-cal-link:hover {
    border-color: var(--accent);
    color: var(--accent);
    opacity: 1;
    box-shadow: 0 0 12px rgba(0,245,196,0.15);
  }

  .main { display: flex; flex: 1; overflow: hidden; }

  canvas { flex: 1; display: block; cursor: crosshair; }

  .panel {
    width: 220px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
    flex-shrink: 0;
  }
  .panel::-webkit-scrollbar { width: 3px; }
  .panel::-webkit-scrollbar-track { background: transparent; }
  .panel::-webkit-scrollbar-thumb { background: var(--border); }

  .section { border-bottom: 1px solid var(--border); padding: 12px; }

  .section-title {
    font-family: 'Syncopate', sans-serif;
    font-size: 8px;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 10px;
    text-transform: uppercase;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 10px;
  }
  .control-label { color: var(--text); letter-spacing: 1px; }

  input[type=range] {
    -webkit-appearance: none;
    width: 90px; height: 2px;
    background: var(--border);
    outline: none; border-radius: 2px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(0,245,196,0.6);
  }

  .val-display { color: var(--accent); font-size: 10px; min-width: 28px; text-align: right; }

  .btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; letter-spacing: 2px; text-transform: uppercase;
    border: 1px solid var(--border); background: transparent;
    color: var(--text-bright); padding: 7px 10px;
    cursor: pointer; transition: all 0.15s;
    width: 100%; margin-bottom: 6px; text-align: left;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.05); box-shadow: 0 0 10px rgba(0,245,196,0.1); }
  .btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.08); }
  .btn.danger:hover { border-color: var(--accent2); color: var(--accent2); background: rgba(255,77,109,0.05); }

  .legend { display: flex; flex-direction: column; gap: 5px; }
  .legend-item { display: flex; align-items: center; gap: 8px; font-size: 9px; letter-spacing: 1px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

  .mini-chart { width: 100%; height: 60px; border: 1px solid var(--border); margin-top: 8px; overflow: hidden; }
  .mini-chart canvas { width: 100%; height: 100%; }

  .info-box { font-size: 9px; line-height: 1.8; color: var(--text); letter-spacing: 0.5px; }
  .info-box b { color: var(--accent); font-weight: normal; }

  footer {
    padding: 6px 16px; font-size: 9px; letter-spacing: 2px;
    color: var(--border); border-top: 1px solid var(--border);
    background: var(--panel); display: flex; justify-content: space-between; flex-shrink: 0;
  }
</style>
</head>
<body>

<header>
  <div class="logo">ALIFE <span>/ SIM</span></div>
  <div class="header-stats">
    <div class="stat"><div class="stat-val" id="hPop">0</div><div class="stat-lbl">Herbivores</div></div>
    <div class="stat"><div class="stat-val" id="cPop" style="color:var(--accent2)">0</div><div class="stat-lbl">Carnivores</div></div>
    <div class="stat"><div class="stat-val" id="fPop" style="color:var(--accent3)">0</div><div class="stat-lbl">Food</div></div>
    <div class="stat"><div class="stat-val" id="genNum" style="color:#a29bfe">0</div><div class="stat-lbl">Generation</div></div>
    <div class="stat"><div class="stat-val" id="tickNum">0</div><div class="stat-lbl">Tick</div></div>
  </div>
  <a href="https://www.linkedin.com/in/callum-smith-55118071/" target="_blank" rel="noopener" class="by-cal-link">
    <svg width="13" height="13" viewBox="0 0 24 24" fill="currentColor">
      <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
    </svg>
    BY CAL
  </a>
</header>

<div class="main">
  <canvas id="canvas"></canvas>
  <div class="panel">
    <div class="section">
      <div class="section-title">Simulation</div>
      <button class="btn active" id="playBtn" onclick="togglePlay()">â¸ PAUSE</button>
      <button class="btn danger" onclick="resetSim()">â†º RESET</button>
      <div class="control-row">
        <div class="control-label">SPEED</div>
        <input type="range" id="speedSlider" min="1" max="10" value="1" oninput="updateSpeed(this)">
        <div class="val-display" id="speedVal">1</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Environment</div>
      <div class="control-row">
        <div class="control-label">FOOD SPREAD</div>
        <input type="range" id="foodRate" min="1" max="20" value="8" oninput="updateParam('foodRate', this)">
        <div class="val-display" id="foodRateVal">8</div>
      </div>
      <div class="control-row">
        <div class="control-label">MAX FOOD</div>
        <input type="range" id="maxFood" min="20" max="1000" value="120" oninput="updateParam('maxFood', this)">
        <div class="val-display" id="maxFoodVal">120</div>
      </div>
      <div class="control-row">
        <div class="control-label">MUTATION</div>
        <input type="range" id="mutRate" min="0" max="50" value="10" oninput="updateParam('mutRate', this)">
        <div class="val-display" id="mutRateVal">10%</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Spawn</div>
      <button class="btn" id="spawnH" onclick="spawnCreatures('herbivore', spawnAmt())">+ <span id="spawnHlbl">1</span> HERBIVORE<span id="spawnHs"></span></button>
      <button class="btn" id="spawnC" onclick="spawnCreatures('carnivore', spawnAmt())">+ <span id="spawnClbl">1</span> CARNIVORE<span id="spawnCs"></span></button>
      <button class="btn" id="spawnF" onclick="spawnFood(spawnAmt())">+ <span id="spawnFlbl">1</span> FOOD</button>
      <div style="display:flex;gap:6px;margin-top:8px;">
        <button class="btn qty-btn active" id="qty1" onclick="setQty(1)" style="flex:1;text-align:center;padding:6px 0;">1</button>
        <button class="btn qty-btn" id="qty10" onclick="setQty(10)" style="flex:1;text-align:center;padding:6px 0;">10</button>
        <button class="btn qty-btn" id="qty25" onclick="setQty(25)" style="flex:1;text-align:center;padding:6px 0;">25</button>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Legend</div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>HERBIVORE â€” eats food</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent2)"></div>CARNIVORE â€” hunts prey</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent3)"></div>FOOD â€” energy pellets</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a29bfe"></div>MATING â€” purple, vulnerable!</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffd166;opacity:0.7"></div>SATED (90%+) â€” behaviour shift</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a0b4f0;opacity:0.7"></div>SLEEPING â€” inert, vulnerable</div>
        <div class="legend-item"><div class="legend-dot" style="background:#5c3d1a;opacity:0.7"></div>CORPSE â€” carnivore food</div>
        <div class="legend-item"><div class="legend-dot" style="background:#636e72;opacity:0.4"></div>OLD AGE â€” no corpse</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Population Graph</div>
      <div class="mini-chart"><canvas id="chartCanvas"></canvas></div>
    </div>
    <div class="section">
      <div class="section-title">Selection Info</div>
      <div class="info-box" id="infoBox"><b>Click a creature</b> to inspect its genes and status.</div>
    </div>
  </div>
</div>

<footer>
  <span>ARTIFICIAL LIFE SIMULATOR â€” EVOLUTIONARY GENETICS ENGINE</span>
  <span id="fpsDisplay">60 FPS</span>
</footer>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const chartCanvas = document.getElementById('chartCanvas');
const chartCtx = chartCanvas.getContext('2d');

let creatures = [];
let foods = [];
let tick = 0;
let generation = 1;
let playing = true;
let speed = 1;
let selectedCreature = null;
let corpses = [];

// How many ticks creatures stay in the purple mating state before baby spawns
const MATING_DURATION = 60;

const params = { foodRate: 8, maxFood: 120, mutRate: 10 };
const history = { h: [], c: [], f: [] };
const MAX_HISTORY = 196;

// â”€â”€ DNA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function randomDNA(type) {
  return {
    type,
    speed:      0.5 + Math.random() * 2.5,
    sense:      30  + Math.random() * 120,
    size:       3   + Math.random() * 5,
    fertility:  0.001 + Math.random() * 0.004,
    metabolism: 0.015 + Math.random() * 0.03,
    aggression: type === 'carnivore' ? 0.5 + Math.random() * 0.5 : Math.random() * 0.3,
  };
}

function mutateDNA(dna) {
  const m = params.mutRate / 100;
  const mut = v => v * (1 + (Math.random() * 2 - 1) * m);
  return {
    type:       dna.type,
    speed:      Math.max(0.2, Math.min(5,    mut(dna.speed))),
    sense:      Math.max(15,  Math.min(200,  mut(dna.sense))),
    size:       Math.max(2,   Math.min(12,   mut(dna.size))),
    fertility:  Math.max(0.0005, Math.min(0.01, mut(dna.fertility))),
    metabolism: Math.max(0.005,  Math.min(0.08, mut(dna.metabolism))),
    aggression: Math.max(0,   Math.min(1,    mut(dna.aggression))),
  };
}

// â”€â”€ Factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createCreature(type, x, y, dna) {
  dna = dna || randomDNA(type);
  return {
    id:             Math.random().toString(36).slice(2),
    dna,
    x:              x ?? Math.random() * canvas.width,
    y:              y ?? Math.random() * canvas.height,
    vx:             (Math.random() - 0.5) * 2,
    vy:             (Math.random() - 0.5) * 2,
    energy:         150, // Start at 50% of max (300) â€” must eat before mating
    age:            0,
    alive:          true,
    matingWith:     null,  // partner reference during active mating
    matingTicks:    0,     // progress through MATING_DURATION
    matingCooldown: 0,     // post-birth cooldown
    mateCount:      0,     // successful matings; capped at 3
    sleeping:       false, // currently asleep
    sleepTicks:     0,     // ticks remaining in sleep
    sleepCooldown:  Math.floor(Math.random() * 400) + 200, // ticks until next sleep check
    wakeScatter:    0,     // >0 = startled, flee at full speed
    trail:          [],
    gen:            generation,
  };
}

function createFood(x, y) {
  return {
    x:      x ?? Math.random() * canvas.width,
    y:      y ?? Math.random() * canvas.height,
    energy: 20 + Math.random() * 30,
  };
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetSim() {
  creatures = []; foods = []; corpses = [];
  tick = 0; generation = 1;
  history.h = []; history.c = []; history.f = [];
  selectedCreature = null;
  for (let i = 0; i < 20; i++) creatures.push(createCreature('herbivore'));
  for (let i = 0; i < 6;  i++) creatures.push(createCreature('carnivore'));
  for (let i = 0; i < 60; i++) foods.push(createFood());
}

function spawnCreatures(type, n) { for (let i = 0; i < n; i++) creatures.push(createCreature(type)); }
function spawnFood(n)            { for (let i = 0; i < n; i++) foods.push(createFood()); }

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dist(a, b) {
  const dx = a.x - b.x, dy = a.y - b.y;
  return Math.sqrt(dx*dx + dy*dy);
}

function findNearest(c, list, maxDist) {
  let best = null, bd = maxDist;
  for (const item of list) {
    const d = dist(c, item);
    if (d < bd) { bd = d; best = item; }
  }
  return best;
}

// â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCreature(c) {
  if (!c.alive) return;

  c.age++;
  if (c.matingCooldown > 0) c.matingCooldown--;
  c.energy -= c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002;

  if (c.energy <= 0 || c.age > 4000) {
    if (c.matingWith) { c.matingWith.matingWith = null; c.matingWith.matingTicks = 0; }
    // Starvation leaves a corpse; old age does not
    if (c.energy <= 0) {
      corpses.push({ x: c.x, y: c.y, energy: 25 + Math.random() * 20, decay: 0 });
    }
    c.alive = false;
    return;
  }

  const W = canvas.width, H = canvas.height;

  // â”€â”€ SLEEP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (c.sleeping) {
    c.sleepTicks--;
    // Sleeping metabolism is 10% of normal
    // (energy was already deducted at 100% above; refund 90%)
    c.energy += (c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002) * 0.9;

    // Dampen velocity â€” nearly still
    c.vx *= 0.05; c.vy *= 0.05;
    c.x += c.vx; c.y += c.vy;
    if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
    if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;
    c.trail.push({ x: c.x, y: c.y });
    if (c.trail.length > 8) c.trail.shift();

    if (c.sleepTicks <= 0) {
      c.sleeping = false;
      c.sleepCooldown = 300 + Math.floor(Math.random() * 400);
    }
    c.energy = Math.min(c.energy, 300);
    return; // Skip all other behaviour while asleep
  }

  // Startled â€” flee at max speed for a short burst
  if (c.wakeScatter > 0) {
    c.wakeScatter--;
    // Random scatter direction was set when startled; just let velocity carry
    const spd0 = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
    if (spd0 > c.dna.speed * 2) { c.vx = (c.vx/spd0)*c.dna.speed*2; c.vy = (c.vy/spd0)*c.dna.speed*2; }
  }

  // Tick down sleep cooldown; trigger sleep when it hits zero
  if (c.sleepCooldown > 0) {
    c.sleepCooldown--;
  } else if (!c.matingWith && c.wakeScatter === 0) {
    // Fall asleep: duration 180-360 ticks
    c.sleeping = true;
    c.sleepTicks = 180 + Math.floor(Math.random() * 180);
    c.vx *= 0.1; c.vy *= 0.1;
    c.energy = Math.min(c.energy, 300);
    return;
  }

  // â”€â”€ ACTIVE MATING (creature is purple) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (c.matingWith) {
    const partner = c.matingWith;

    // Safety checks: cancel if partner died, or partner no longer points back (stale link)
    if (!partner.alive || partner.matingWith !== c) {
      c.matingWith = null; c.matingTicks = 0;
    } else {
      // Only the lower-id creature drives the tick counter to avoid double-counting
      if (c.id < partner.id) c.matingTicks++;
      else c.matingTicks = partner.matingTicks; // mirror the master's progress

      // Drift slowly toward partner â€” easy prey for carnivores!
      const dx = partner.x - c.x, dy = partner.y - c.y;
      const d  = Math.sqrt(dx*dx + dy*dy) + 0.001;
      c.vx += (dx/d) * 0.15;
      c.vy += (dy/d) * 0.15;
      const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
      const cap = c.dna.speed * 0.3;
      if (spd > cap) { c.vx = (c.vx/spd)*cap; c.vy = (c.vy/spd)*cap; }
      c.x += c.vx; c.y += c.vy;
      if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
      if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 8) c.trail.shift();

      // Spawn babies at end â€” only the lower-id creature (the "mother") births
      if (c.matingTicks >= MATING_DURATION && c.id < partner.id) {
        const avg = (a, b) => (a + b) / 2;
        const newGen = Math.max(c.gen, partner.gen) + 1;
        generation = Math.max(generation, newGen);
        // 80% = 1 offspring, 15% = 2, 5% = 3
        const roll = Math.random();
        const numOffspring = roll < 0.80 ? 1 : roll < 0.95 ? 2 : 3;
        for (let n = 0; n < numOffspring; n++) {
          const childDNA = mutateDNA({
            type:       c.dna.type,
            speed:      avg(c.dna.speed,      partner.dna.speed),
            sense:      avg(c.dna.sense,      partner.dna.sense),
            size:       avg(c.dna.size,       partner.dna.size),
            fertility:  avg(c.dna.fertility,  partner.dna.fertility),
            metabolism: avg(c.dna.metabolism, partner.dna.metabolism),
            aggression: avg(c.dna.aggression, partner.dna.aggression),
          });
          const child = createCreature(
            c.dna.type,
            c.x + (Math.random()-0.5)*24,
            c.y + (Math.random()-0.5)*24,
            childDNA
          );
          child.gen = newGen;
          creatures.push(child);
        }
        // Energy cost scales with number of offspring; carnivores pay 50% less
        const baseCost = 30 + numOffspring * 15;
        const costMult = c.dna.type === 'carnivore' ? 0.5 : 1.0;
        const cost = baseCost * costMult;
        c.energy -= cost; partner.energy -= cost * 0.5;
        c.matingCooldown = 120; partner.matingCooldown = 120;
        c.mateCount++;       // track successful births
        partner.mateCount++; // both parents count it
      }

      // End mating phase for both
      if (c.matingTicks >= MATING_DURATION) {
        partner.matingWith = null; partner.matingTicks = 0;
        c.matingWith       = null; c.matingTicks       = 0;
      }
    }

    c.energy = Math.min(c.energy, 300);
    return; // Skip normal behaviour while mating
  }

  // â”€â”€ NORMAL BEHAVIOUR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  c.trail.push({ x: c.x, y: c.y });
  if (c.trail.length > 8) c.trail.shift();

  const MATE_ENERGY  = 240; // 80% of max 300 â€” required to mate
  const SATED_ENERGY = 270; // 90% of max 300 â€” above this, behaviour shifts
  const MAX_MATES    = 3;   // after 3 successful matings, ineligible forever

  const isSated    = c.energy >= SATED_ENERGY;
  const canMate    = c.matingCooldown === 0 && c.mateCount < MAX_MATES && !c.matingWith;
  const mateElig   = canMate && c.energy >= MATE_ENERGY;

  let tx = null, ty = null;

  if (c.dna.type === 'herbivore') {
    // Always flee carnivores (stronger urge when sated â€” nothing to distract from survival)
    const predator = findNearest(c,
      creatures.filter(o => o.alive && o.dna.type === 'carnivore'),
      isSated ? c.dna.sense * 1.4 : c.dna.sense); // wider awareness when sated
    if (predator) {
      const dx = c.x - predator.x, dy = c.y - predator.y;
      const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
      tx = c.x + (dx/d) * (isSated ? 120 : 80);
      ty = c.y + (dy/d) * (isSated ? 120 : 80);
    }
    // Mildly repelled by corpses (smell of death = predator nearby)
    if (tx === null) {
      const corpse = findNearest(c, corpses, c.dna.sense * 0.5);
      if (corpse) {
        const dx = c.x - corpse.x, dy = c.y - corpse.y;
        const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
        tx = c.x + (dx/d) * 40; ty = c.y + (dy/d) * 40;
      }
    }
    // Only seek food when NOT sated
    if (tx === null && !isSated) {
      const food = findNearest(c, foods, c.dna.sense);
      if (food) { tx = food.x; ty = food.y; }
    }
    // Seek mate when eligible (sated herbivores actively seek mates)
    if (tx === null && mateElig) {
      const mate = findNearest(c,
        creatures.filter(o => o.alive && o !== c && o.dna.type === 'herbivore' &&
                              o.energy >= MATE_ENERGY && o.matingCooldown === 0 &&
                              !o.matingWith && o.mateCount < MAX_MATES),
        c.dna.sense * 0.8);
      if (mate) { tx = mate.x; ty = mate.y; }
    }

  } else {
    // Carnivore at 90%+ energy: focus on mating, ignore prey
    if (isSated) {
      // Seek mate only â€” no hunting while sated
      if (mateElig) {
        const mate = findNearest(c,
          creatures.filter(o => o.alive && o !== c && o.dna.type === 'carnivore' &&
                                o.energy >= MATE_ENERGY && o.matingCooldown === 0 &&
                                !o.matingWith && o.mateCount < MAX_MATES),
          c.dna.sense * 0.8);
        if (mate) { tx = mate.x; ty = mate.y; }
      }
      // Wander if no mate found â€” don't hunt
    } else {
      // Carnivore hungry: prioritise sleeping prey, purple pips, weak carnivores, corpses, herbivores
      // Sleeping creatures are prime targets â€” easy, inert prey
      const sleepingPrey = findNearest(c,
        creatures.filter(o => o.alive && o.sleeping),
        c.dna.sense);
      if (sleepingPrey) { tx = sleepingPrey.x; ty = sleepingPrey.y; }

      if (tx === null) {
        const purplePrey = findNearest(c,
          creatures.filter(o => o.alive && o.matingWith !== null),
          c.dna.sense);
        if (purplePrey) { tx = purplePrey.x; ty = purplePrey.y; }
      }

      // Cannibalism target: weak young carnivores
      if (tx === null) {
        const weakCarnivore = findNearest(c,
          creatures.filter(o => o.alive && o !== c && o.dna.type === 'carnivore'
                                && o.energy < 30 && o.age < c.age * 0.5),
          c.dna.sense);
        if (weakCarnivore) { tx = weakCarnivore.x; ty = weakCarnivore.y; }
      }

      // Scavenge corpses (easy energy)
      if (tx === null) {
        const nearCorpse = findNearest(c, corpses, c.dna.sense);
        if (nearCorpse) { tx = nearCorpse.x; ty = nearCorpse.y; }
      }

      if (tx === null) {
        const prey = findNearest(c,
          creatures.filter(o => o.alive && o.dna.type === 'herbivore'),
          c.dna.sense);
        if (prey) { tx = prey.x; ty = prey.y; }
      }

      // Seek mate when eligible even while not sated (if no prey nearby)
      if (tx === null && mateElig) {
        const mate = findNearest(c,
          creatures.filter(o => o.alive && o !== c && o.dna.type === 'carnivore' &&
                                o.energy >= MATE_ENERGY && o.matingCooldown === 0 &&
                                !o.matingWith && o.mateCount < MAX_MATES),
          c.dna.sense * 0.5);
        if (mate) { tx = mate.x; ty = mate.y; }
      }
    }
  }

  if (tx !== null) {
    const dx = tx - c.x, dy = ty - c.y;
    const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
    c.vx += (dx/d) * 0.4; c.vy += (dy/d) * 0.4;
  } else {
    c.vx += (Math.random()-0.5) * 0.5; c.vy += (Math.random()-0.5) * 0.5;
  }

  const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
  if (spd > c.dna.speed) { c.vx = (c.vx/spd)*c.dna.speed; c.vy = (c.vy/spd)*c.dna.speed; }
  c.x += c.vx; c.y += c.vy;
  if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
  if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

  // Herbivores eat food only when below sated threshold
  if (c.dna.type === 'herbivore' && !isSated) {
    for (let i = foods.length - 1; i >= 0; i--) {
      if (dist(c, foods[i]) < c.dna.size + 4) {
        c.energy += foods[i].energy;
        foods.splice(i, 1);
        break;
      }
    }
  }

  // Carnivores hunt ONLY when below sated threshold (90%)
  if (c.dna.type === 'carnivore' && !isSated) {
    let ate = false;
    for (const prey of creatures) {
      if (!prey.alive || prey === c) continue;
      const isPurple    = prey.matingWith !== null;
      const isHerbivore = prey.dna.type === 'herbivore';
      const isSleeping  = prey.sleeping;
      // Can eat: purple/mating prey, herbivores, sleeping creatures
      // Cannibalism: eat carnivore only if it's <10% energy AND age < half attacker age
      const isWeakCarnivore = prey.dna.type === 'carnivore'
                              && prey.energy < 30          // <10% of 300
                              && prey.age < c.age * 0.5;   // less than half attacker's age
      const edible = isPurple || isHerbivore || isSleeping || isWeakCarnivore;
      if (edible && dist(c, prey) < c.dna.size + prey.dna.size) {
        c.energy += prey.energy * 0.6;
        if (prey.matingWith) { prey.matingWith.matingWith = null; prey.matingWith.matingTicks = 0; }
        // Wake nearby sleepers if this prey was asleep
        if (prey.sleeping) {
          for (const neighbour of creatures) {
            if (neighbour !== prey && neighbour.sleeping && dist(neighbour, prey) < neighbour.dna.sense) {
              neighbour.sleeping = false;
              neighbour.sleepTicks = 0;
              neighbour.sleepCooldown = 400 + Math.floor(Math.random() * 300);
              // Scatter in random direction at high speed
              const ang = Math.random() * Math.PI * 2;
              neighbour.vx = Math.cos(ang) * neighbour.dna.speed * 2;
              neighbour.vy = Math.sin(ang) * neighbour.dna.speed * 2;
              neighbour.wakeScatter = 60;
            }
          }
        }
        prey.alive = false;
        ate = true;
        break;
      }
    }
    // Also scavenge nearby corpses
    if (!ate) {
      for (let i = corpses.length - 1; i >= 0; i--) {
        if (dist(c, corpses[i]) < c.dna.size + 5) {
          c.energy += corpses[i].energy;
          corpses.splice(i, 1);
          break;
        }
      }
    }
  }

  // Initiate mating â€” requires 80%+ energy, under 3 prior matings, both partners eligible, not sleeping
  if (mateElig && !c.sleeping && c.wakeScatter === 0) {
    for (const other of creatures) {
      if (!other.alive || other === c || other.dna.type !== c.dna.type) continue;
      if (other.matingWith || other.matingCooldown > 0 || other.mateCount >= MAX_MATES) continue;
      if (other.energy < MATE_ENERGY) continue;
      if (dist(c, other) < c.dna.size + other.dna.size + 5) {
        c.matingWith     = other; c.matingTicks = 0;
        other.matingWith = c;     other.matingTicks = 0;
        break;
      }
    }
  }

  c.energy = Math.min(c.energy, 300);
}

function updateSim() {
  tick++;

  // Food grows by spreading from existing food â€” no random teleport spawning
  if (foods.length < params.maxFood && foods.length > 0) {
    // Each tick, each food pellet has a small chance to sprout a neighbour nearby
    const growthChance = params.foodRate * 0.0003; // slider controls spread speed
    for (let i = 0; i < foods.length && foods.length < params.maxFood; i++) {
      if (Math.random() < growthChance) {
        const parent = foods[i];
        // Spread radius: closer neighbours more likely, max 60px
        const angle = Math.random() * Math.PI * 2;
        const r = 10 + Math.random() * 50;
        const nx = parent.x + Math.cos(angle) * r;
        const ny = parent.y + Math.sin(angle) * r;
        // Only sprout if within canvas bounds
        if (nx > 0 && nx < canvas.width && ny > 0 && ny < canvas.height) {
          foods.push(createFood(nx, ny));
        }
      }
    }
  }

  for (const c of creatures) updateCreature(c);

  // Decay corpses over time
  for (const corp of corpses) corp.decay++;
  corpses = corpses.filter(corp => corp.decay < 300);

  creatures = creatures.filter(c => c.alive || (c.age++ < 60));

  if (creatures.filter(c => c.dna.type === 'herbivore').length > 200)
    creatures = creatures.filter(c => c.dna.type !== 'herbivore' || Math.random() > 0.1);
  if (creatures.filter(c => c.dna.type === 'carnivore').length > 60)
    creatures = creatures.filter(c => c.dna.type !== 'carnivore' || Math.random() > 0.1);

  if (tick % 60 === 0) {
    const alive = creatures.filter(c => c.alive);
    history.h.push(alive.filter(c => c.dna.type === 'herbivore').length);
    history.c.push(alive.filter(c => c.dna.type === 'carnivore').length);
    history.f.push(foods.length);
    if (history.h.length > MAX_HISTORY) { history.h.shift(); history.c.shift(); history.f.shift(); }
  }
}

// â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawCreature(c) {
  const alive = c.alive;
  const alpha = alive ? 1.0 : Math.max(0, 1 - (c.age - 3940) / 60);
  if (alpha <= 0) return;

  const isH      = c.dna.type === 'herbivore';
  const isMating = alive && c.matingWith !== null;
  const r        = c.dna.size;

  // Energy-based brightness/saturation: 20% min -> 100% at full energy
  const ePct = alive ? Math.max(0, Math.min(1, c.energy / 300)) : 0;
  const sat  = Math.round(30 + ePct * 70);  // 30%â€“100% saturation
  const lit  = Math.round(20 + ePct * 45);  // 20%â€“65% lightness

  // Base hue per type: mating=267(purple), herbivore=168(teal), carnivore=348(red)
  const isSleepingDraw = alive && c.sleeping;
  const hue = isMating ? 267 : isSleepingDraw ? 220 : (isH ? 168 : 348);
  const baseColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#2a2a3a';
  const glowColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#444';
  // Extract approximate RGB for rgba() glow uses
  const glowRGB    = alive ? (isMating ? '162,155,254' : (isH ? '0,245,196' : '255,77,109')) : '68,68,68';
  const trailColor = isMating ? `hsla(267,${sat}%,${lit}%,0.2)` : (isH ? `hsla(168,${sat}%,${lit}%,0.15)` : `hsla(348,${sat}%,${lit}%,0.15)`);

  ctx.save();
  ctx.globalAlpha = alpha;

  // Trail
  if (alive && c.trail.length > 1) {
    ctx.beginPath();
    ctx.moveTo(c.trail[0].x, c.trail[0].y);
    for (let i = 1; i < c.trail.length; i++) ctx.lineTo(c.trail[i].x, c.trail[i].y);
    ctx.strokeStyle = trailColor;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Sense radius (selected only)
  if (c === selectedCreature && alive) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.dna.sense, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(${glowRGB},0.1)`;
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 5]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Sleep indicator: zzz rings when asleep
  if (alive && c.sleeping) {
    ctx.save();
    ctx.globalAlpha = (alpha * 0.6);
    // Pulsing outer ring in dim blue-grey
    const pulse = 0.5 + 0.5 * Math.sin(tick * 0.08);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + pulse * 4, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(120,140,200,${0.4 + pulse * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([3, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
    // Tiny 'z' indicators floating upward
    for (let z = 0; z < 3; z++) {
      const zAge = (tick + z * 30) % 90;
      const zAlpha = zAge < 45 ? zAge / 45 : (90 - zAge) / 45;
      const zY = c.y - r - 6 - zAge * 0.25;
      const zX = c.x + r + 2 + z * 4;
      ctx.globalAlpha = alpha * zAlpha * 0.7;
      ctx.fillStyle = 'rgba(160,180,240,1)';
      ctx.font = `${7 + z}px monospace`;
      ctx.fillText('z', zX, zY);
    }
    ctx.restore();
  }

  // Mating pulse ring + progress arc
  if (isMating) {
    const progress = c.matingTicks / MATING_DURATION;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + Math.sin(tick * 0.25) * 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(162,155,254,${0.25 + progress * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 9, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
    ctx.strokeStyle = 'rgba(162,155,254,0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Outer glow
  if (alive) {
    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r * 3);
    g.addColorStop(0, `rgba(${glowRGB},0.3)`);
    g.addColorStop(1, `rgba(${glowRGB},0)`);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r * 3, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
  }

  // Body
  ctx.beginPath();
  if (isH) {
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
      const px = c.x + Math.cos(angle) * r, py = c.y + Math.sin(angle) * r;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
  } else {
    ctx.moveTo(c.x,     c.y - r * 1.3);
    ctx.lineTo(c.x + r, c.y);
    ctx.lineTo(c.x,     c.y + r * 1.3);
    ctx.lineTo(c.x - r, c.y);
    ctx.closePath();
  }

  if (alive) {
    ctx.fillStyle = baseColor;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = isMating ? 14 : 8;
    ctx.fill();
    ctx.shadowBlur = 0;
  } else {
    ctx.fillStyle = '#1a1a2a';
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }

  // Direction nub
  if (alive) {
    const angle = Math.atan2(c.vy, c.vx);
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x + Math.cos(angle) * r * 1.8, c.y + Math.sin(angle) * r * 1.8);
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Energy bar
  if (alive) {
    const bw = r * 2.5, bh = 2;
    const bx = c.x - bw/2, by = c.y + r + 3;
    const pct = Math.min(1, c.energy / 200);
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = isMating ? '#a29bfe'
                  : pct > 0.5 ? '#00f5c4'
                  : pct > 0.25 ? '#ffd166' : '#ff4d6d';
    ctx.fillRect(bx, by, bw * pct, bh);
  }

  ctx.restore();
}

function drawFood(f) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#ffd166';
  ctx.shadowColor = '#ffd166';
  ctx.shadowBlur = 6;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawCorpse(corp) {
  const age = corp.decay / 300; // 0=fresh, 1=gone
  const alpha = 1 - age * 0.8;
  const r = 3 + (1 - age) * 2;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.arc(corp.x, corp.y, r, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(30,${Math.round(40 - age*30)}%,${Math.round(18 + age*8)}%)`;
  ctx.shadowColor = 'rgba(80,40,0,0.3)';
  ctx.shadowBlur = 4;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Small X to distinguish from food
  ctx.strokeStyle = `rgba(100,60,20,${0.5 * alpha})`;
  ctx.lineWidth = 0.7;
  ctx.beginPath(); ctx.moveTo(corp.x - r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x + r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(corp.x + r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x - r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.restore();
}

function drawChart() {
  const w = chartCanvas.width, h = chartCanvas.height;
  chartCtx.clearRect(0, 0, w, h);
  chartCtx.fillStyle = '#060810';
  chartCtx.fillRect(0, 0, w, h);
  const all = [...history.h, ...history.c, ...history.f];
  const maxVal = Math.max(...all, 1);
  if (history.h.length < 2) return;

  const line = (data, color) => {
    chartCtx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = (i / (MAX_HISTORY - 1)) * w;
      const y = h - (data[i] / maxVal) * h * 0.9 - 2;
      i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
    }
    chartCtx.strokeStyle = color;
    chartCtx.lineWidth = 1.5;
    chartCtx.stroke();
  };
  line(history.h, '#00f5c4');
  line(history.c, '#ff4d6d');
  line(history.f, '#ffd166');
}

function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(6,8,16,0.85)';
  ctx.fillRect(0, 0, W, H);

  if (selectedCreature && selectedCreature.alive) {
    ctx.beginPath();
    ctx.arc(selectedCreature.x, selectedCreature.y, selectedCreature.dna.size + 10, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  for (const corp of corpses) drawCorpse(corp);
  for (const f of foods) drawFood(f);
  for (const c of creatures) drawCreature(c);
}

// â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateUI() {
  const alive = creatures.filter(c => c.alive);
  document.getElementById('hPop').textContent   = alive.filter(c => c.dna.type === 'herbivore').length;
  document.getElementById('cPop').textContent   = alive.filter(c => c.dna.type === 'carnivore').length;
  document.getElementById('fPop').textContent   = foods.length;
  document.getElementById('genNum').textContent  = generation;
  document.getElementById('tickNum').textContent = tick;

  if (selectedCreature) {
    const c = selectedCreature, d = c.dna;
    const info = document.getElementById('infoBox');
    if (!c.alive) {
      info.innerHTML = '<b>DECEASED</b><br>Age: ' + c.age;
    } else {
      const energyPct = Math.round((c.energy / 300) * 100);
      const isSated = c.energy >= 270;
      const maxedOut = c.mateCount >= 3;
      const stateTag = c.sleeping
        ? `<br><b style="color:#a0b4f0">ğŸ’¤ SLEEPING (${c.sleepTicks} ticks)</b>`
        : c.matingWith
          ? `<br><b style="color:#a29bfe">â— MATING ${Math.round((c.matingTicks/MATING_DURATION)*100)}%</b>`
          : isSated && !maxedOut
            ? `<br><b style="color:#ffd166">â—ˆ SATED â€” seeking mate</b>`
            : isSated && maxedOut
              ? `<br><b style="color:#ffd166">â—ˆ SATED â€” retired</b>`
              : maxedOut
                ? `<br><b style="color:#636e72">âœ• RETIRED â€” 3/3 matings</b>`
                : c.matingCooldown > 0
                  ? `<br><b style="color:#636e72">â—Œ COOLDOWN ${c.matingCooldown}</b>`
                  : '';
      info.innerHTML = `
        <b>TYPE:</b> ${d.type.toUpperCase()}<br>
        <b>ENERGY:</b> ${Math.round(c.energy)} <b style="opacity:0.5">(${energyPct}%)</b><br>
        <b>AGE:</b> ${c.age}<br>
        <b>GEN:</b> ${c.gen}<br>
        <b>MATINGS:</b> ${c.mateCount}/3${maxedOut ? ' <b style="color:var(--accent2)">RETIRED</b>' : ''}<br>
        <br>
        <b>â€” GENOME â€”</b><br>
        <b>SPEED:</b> ${d.speed.toFixed(2)}<br>
        <b>SENSE:</b> ${Math.round(d.sense)}<br>
        <b>SIZE:</b> ${d.size.toFixed(2)}<br>
        <b>FERTILITY:</b> ${(d.fertility*1000).toFixed(2)}â€°<br>
        <b>METABOLISM:</b> ${d.metabolism.toFixed(3)}<br>
        <b>AGGRESSION:</b> ${d.aggression.toFixed(2)}${stateTag}
      `;
    }
  }
}

// â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastFPSTime = performance.now(), frames = 0;

function loop() {
  const now = performance.now();
  frames++;
  if (now - lastFPSTime > 1000) {
    document.getElementById('fpsDisplay').textContent = frames + ' FPS';
    frames = 0; lastFPSTime = now;
  }
  if (playing) {
    for (let i = 0; i < speed; i++) updateSim();
  }
  updateUI(); // Always refresh panel so selected creature info stays live
  render();
  drawChart();
  requestAnimationFrame(loop);
}

// â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function togglePlay() {
  playing = !playing;
  const btn = document.getElementById('playBtn');
  btn.textContent = playing ? 'â¸ PAUSE' : 'â–¶ PLAY';
  btn.classList.toggle('active', playing);
}

function updateSpeed(el) {
  speed = parseInt(el.value);
  document.getElementById('speedVal').textContent = speed;
}

function updateParam(key, el) {
  params[key] = parseInt(el.value);
  document.getElementById(key + 'Val').textContent = params[key] + (key === 'mutRate' ? '%' : '');
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  let clicked = null;
  // Generous hit radius so small creatures are easy to click
  for (const c of creatures) {
    if (c.alive && dist(c, { x: mx, y: my }) < Math.max(c.dna.size + 12, 18)) { clicked = c; break; }
  }
  if (clicked) {
    selectedCreature = clicked;
    updateUI(); // Refresh panel immediately, even when paused
  } else {
    selectedCreature = null; // Just deselect â€” no food placement on empty click
  }
});

function resize() {
  const panel  = document.querySelector('.panel');
  const header = document.querySelector('header');
  const footer = document.querySelector('footer');
  canvas.width        = window.innerWidth - panel.offsetWidth;
  canvas.height       = window.innerHeight - header.offsetHeight - footer.offsetHeight;
  chartCanvas.width   = panel.offsetWidth - 24;
  chartCanvas.height  = 60;
}

window.addEventListener('resize', resize);
resize();
resetSim();
loop();

// â”€â”€ Spawn quantity selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentQty = 1;

function spawnAmt() { return currentQty; }

function setQty(n) {
  currentQty = n;
  document.querySelectorAll('.qty-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('qty' + n).classList.add('active');
  // Update button labels
  const plural = s => n === 1 ? '' : 'S';
  document.getElementById('spawnHlbl').textContent = n;
  document.getElementById('spawnClbl').textContent = n;
  document.getElementById('spawnFlbl').textContent = n;
  document.getElementById('spawnHs').textContent = plural('S');
  document.getElementById('spawnCs').textContent = plural('S');
}
</script>
</body>
</html>
