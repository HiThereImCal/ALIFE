<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ALIFE â€” Artificial Life Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Syncopate:wght@400;700&display=swap');

  :root {
    --bg: #060810;
    --panel: #0a0e1a;
    --border: #1a2240;
    --accent: #00f5c4;
    --accent2: #ff4d6d;
    --accent3: #ffd166;
    --text: #8899bb;
    --text-bright: #ccd6f6;
    --grid: rgba(0,245,196,0.04);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
  }

  .logo {
    font-family: 'Syncopate', sans-serif;
    font-weight: 700;
    font-size: 18px;
    letter-spacing: 6px;
    color: var(--accent);
    text-shadow: 0 0 20px rgba(0,245,196,0.5);
  }
  .logo span { color: var(--text); font-weight: 400; }

  .header-stats {
    display: flex;
    gap: 24px;
    font-size: 11px;
    letter-spacing: 1px;
  }

  .stat { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .stat-val { color: var(--accent); font-size: 16px; font-weight: bold; }
  .stat-lbl { color: var(--text); opacity: 0.6; font-size: 9px; letter-spacing: 2px; text-transform: uppercase; }

  .by-cal-link {
    display: flex;
    align-items: center;
    gap: 7px;
    text-decoration: none;
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--text);
    opacity: 0.8;
    border: 1px solid var(--border);
    padding: 5px 11px;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .by-cal-link:hover {
    border-color: var(--accent);
    color: var(--accent);
    opacity: 1;
    box-shadow: 0 0 12px rgba(0,245,196,0.15);
  }

  .main { display: flex; flex: 1; overflow: hidden; }

  canvas { flex: 1; display: block; cursor: crosshair; }

  .panel {
    width: 220px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
    flex-shrink: 0;
  }
  .panel::-webkit-scrollbar { width: 3px; }
  .panel::-webkit-scrollbar-track { background: transparent; }
  .panel::-webkit-scrollbar-thumb { background: var(--border); }

  .section { border-bottom: 1px solid var(--border); padding: 12px; }

  .section-title {
    font-family: 'Syncopate', sans-serif;
    font-size: 8px;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 10px;
    text-transform: uppercase;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 10px;
  }
  .control-label { color: var(--text); letter-spacing: 1px; }

  input[type=range] {
    -webkit-appearance: none;
    width: 90px; height: 2px;
    background: var(--border);
    outline: none; border-radius: 2px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(0,245,196,0.6);
  }

  .val-display { color: var(--accent); font-size: 10px; min-width: 28px; text-align: right; }

  .btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; letter-spacing: 2px; text-transform: uppercase;
    border: 1px solid var(--border); background: transparent;
    color: var(--text-bright); padding: 7px 10px;
    cursor: pointer; transition: all 0.15s;
    width: 100%; margin-bottom: 6px; text-align: left;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.05); box-shadow: 0 0 10px rgba(0,245,196,0.1); }
  .btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.08); }
  .btn.danger:hover { border-color: var(--accent2); color: var(--accent2); background: rgba(255,77,109,0.05); }

  .legend { display: flex; flex-direction: column; gap: 5px; }
  .legend-item { display: flex; align-items: center; gap: 8px; font-size: 9px; letter-spacing: 1px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

  .mini-chart { width: 100%; height: 60px; border: 1px solid var(--border); margin-top: 8px; overflow: hidden; }
  .mini-chart canvas { width: 100%; height: 100%; }

  .info-box { font-size: 9px; line-height: 1.8; color: var(--text); letter-spacing: 0.5px; }

  /* Collapsible legend */
  .section-title-row {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 10px;
  }
  .section-title-row .section-title { margin-bottom: 0; }
  .collapse-btn {
    background: none; border: none; cursor: pointer;
    color: var(--accent); font-size: 11px; line-height: 1;
    padding: 2px 4px; transition: transform 0.2s;
  }
  .collapse-btn.collapsed { transform: rotate(-90deg); }

  /* Species grid */
  .species-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
    margin-top: 4px;
  }
  .species-cell {
    display: flex; flex-direction: column; align-items: center;
    gap: 2px; font-size: 8px; color: var(--text);
    background: rgba(255,255,255,0.02);
    border: 1px solid var(--border);
    padding: 4px 2px; border-radius: 2px;
    cursor: pointer; transition: border-color 0.15s, background 0.15s;
    user-select: none;
  }
  .species-cell:hover {
    border-color: var(--accent);
    background: rgba(0,245,196,0.07);
  }
  .species-cell:active { background: rgba(0,245,196,0.14); }
  .species-cell canvas { display: block; pointer-events: none; }
  .info-box b { color: var(--accent); font-weight: normal; }

  footer {
    padding: 6px 16px; font-size: 9px; letter-spacing: 2px;
    color: var(--border); border-top: 1px solid var(--border);
    background: var(--panel); display: flex; justify-content: space-between; flex-shrink: 0;
  }

  /* Weather/Season banner */
  #weatherBanner {
    position: fixed; top: 56px; left: 50%; transform: translateX(-50%);
    background: rgba(10,14,26,0.92); border: 1px solid var(--accent3);
    color: var(--accent3); font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 3px; text-transform: uppercase;
    padding: 8px 24px 7px; pointer-events: none; z-index: 100;
    opacity: 0; transition: opacity 0.5s;
    text-shadow: 0 0 12px rgba(255,209,102,0.6);
    box-shadow: 0 0 20px rgba(255,209,102,0.15);
    text-align: center; min-width: 240px;
  }
  #weatherBanner.visible { opacity: 1; }
  #weatherBannerSub {
    font-size: 8px; letter-spacing: 2px; opacity: 0.65;
    margin-top: 3px; text-transform: uppercase;
  }

  /* Season progress bar under header */
  #seasonBar {
    position: fixed; top: 54px; left: 0; right: 220px;
    height: 2px; z-index: 99; pointer-events: none;
    background: transparent;
  }
  #seasonBarFill {
    height: 100%; width: 0%;
    transition: background 1s;
  }

  /* Selected species highlight ring */
  .species-cell.selected-species {
    border-color: var(--accent3) !important;
    background: rgba(255,209,102,0.12) !important;
    box-shadow: 0 0 8px rgba(255,209,102,0.3);
  }
</style>
</head>
<body>

<div id="weatherBanner"><div id="weatherBannerTitle"></div><div id="weatherBannerSub"></div></div>
<div id="seasonBar"><div id="seasonBarFill"></div></div>

<header>
  <div class="logo">ALIFE <span>/ SIM</span></div>
  <div class="header-stats">
    <div class="stat"><div class="stat-val" id="hPop">0</div><div class="stat-lbl">Herbivores</div></div>
    <div class="stat"><div class="stat-val" id="cPop" style="color:var(--accent2)">0</div><div class="stat-lbl">Carnivores</div></div>
    <div class="stat"><div class="stat-val" id="oPop" style="color:#2bbcff">0</div><div class="stat-lbl">Omnivores</div></div>
    <div class="stat"><div class="stat-val" id="fPop" style="color:var(--accent3)">0</div><div class="stat-lbl">Food</div></div>
    <div class="stat"><div class="stat-val" id="sPop" style="color:#2d8a30">0</div><div class="stat-lbl">Seeds</div></div>
    <div class="stat"><div class="stat-val" id="genNum" style="color:#a29bfe">0</div><div class="stat-lbl">Generation</div></div>
    <div class="stat"><div class="stat-val" id="tickNum">0</div><div class="stat-lbl">Tick</div></div>
    <div class="stat"><div class="stat-val" id="seasonDisplay" style="color:#ffd166">ğŸŒ±</div><div class="stat-lbl">Season</div></div>
  </div>
  <a href="https://www.linkedin.com/in/callum-smith-55118071/" target="_blank" rel="noopener" class="by-cal-link">
    <svg width="13" height="13" viewBox="0 0 24 24" fill="currentColor">
      <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
    </svg>
    BY CAL
  </a>
</header>

<div class="main">
  <canvas id="canvas"></canvas>
  <div class="panel">
    <div class="section">
      <div class="section-title">Simulation</div>
      <button class="btn active" id="playBtn" onclick="togglePlay()">â¸ PAUSE</button>
      <button class="btn danger" onclick="resetSim()">â†º RESET</button>
      <div class="control-row">
        <div class="control-label">SPEED</div>
        <input type="range" id="speedSlider" min="0" max="13" value="2" oninput="updateSpeed(this)">
        <div class="val-display" id="speedVal">1Ã—</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Environment</div>
      <div class="control-row">
        <div class="control-label">FOOD SPREAD</div>
        <input type="range" id="foodRate" min="1" max="50" value="8" oninput="updateParam('foodRate', this)">
        <div class="val-display" id="foodRateVal">8</div>
      </div>
      <div class="control-row">
        <div class="control-label">MAX FOOD</div>
        <input type="range" id="maxFood" min="20" max="1000" value="120" oninput="updateParam('maxFood', this)">
        <div class="val-display" id="maxFoodVal">120</div>
      </div>
      <div class="control-row">
        <div class="control-label">MUTATION</div>
        <input type="range" id="mutRate" min="0" max="50" value="10" oninput="updateParam('mutRate', this)">
        <div class="val-display" id="mutRateVal">10%</div>
      </div>
      <div class="control-row">
        <div class="control-label">FLOCK STR</div>
        <input type="range" id="flockStr" min="0" max="20" value="10" oninput="updateParam('flockStr', this)">
        <div class="val-display" id="flockStrVal">10</div>
      </div>
      <button class="btn" id="pheroBtn" onclick="togglePhero()" style="margin-top:2px;">â— SHOW SCENT TRAILS</button>
    </div>
    <div class="section">
      <div class="section-title">Spawn</div>
      <button class="btn" id="spawnH" onclick="spawnCreatures('herbivore', spawnAmt())">+ <span id="spawnHlbl">1</span> HERBIVORE<span id="spawnHs"></span></button>
      <button class="btn" id="spawnC" onclick="spawnCreatures('carnivore', spawnAmt())">+ <span id="spawnClbl">1</span> CARNIVORE<span id="spawnCs"></span></button>
      <button class="btn" id="spawnO" onclick="spawnCreatures('omnivore', spawnAmt())">+ <span id="spawnOlbl">1</span> OMNIVORE<span id="spawnOs"></span></button>
      <button class="btn" id="spawnS" onclick="spawnSeed(spawnAmt())">+ <span id="spawnSlbl">1</span> SEED<span id="spawnSs"></span></button>
      <button class="btn" id="spawnF" onclick="spawnFood(spawnAmt())">+ <span id="spawnFlbl">1</span> FOOD</button>
      <div style="display:flex;gap:6px;margin-top:8px;">
        <button class="btn qty-btn active" id="qty1" onclick="setQty(1)" style="flex:1;text-align:center;padding:6px 0;">1</button>
        <button class="btn qty-btn" id="qty10" onclick="setQty(10)" style="flex:1;text-align:center;padding:6px 0;">10</button>
        <button class="btn qty-btn" id="qty25" onclick="setQty(25)" style="flex:1;text-align:center;padding:6px 0;">25</button>
      </div>
    </div>
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Legend</div>
        <button class="collapse-btn" id="legendToggle" onclick="toggleLegend()" title="Toggle legend">â–¼</button>
      </div>
      <div class="legend" id="legendBody">
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>HERBIVORE â€” eats food</div>
        <div class="legend-item"><div class="legend-dot" style="background:#00dce0"></div>OMNIVORE â€” food + corpses</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent2)"></div>CARNIVORE â€” hunts prey</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent3)"></div>FOOD â€” energy pellets</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffd166;border:1px dashed rgba(255,200,50,0.6)"></div>SEED â€” disperses food, vanishes</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a29bfe"></div>MATING â€” purple, vulnerable!</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffd166;opacity:0.7"></div>SATED (90%+) â€” behaviour shift</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a0b4f0;opacity:0.7"></div>SLEEPING â€” inert, vulnerable</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffa032;opacity:0.8"></div>SPRINTING â€” burning stamina</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(0,245,196,0.4)"></div>HERB SCENT â€” carnivores track</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(0,210,255,0.5)"></div>OMNI SCENT â€” distinct cyan</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(255,77,109,0.4)"></div>CARN SCENT â€” herbivores flee</div>
        <div class="legend-item"><div class="legend-dot" style="background:#5c3d1a;opacity:0.7"></div>CORPSE â€” carnivore food</div>
        <div class="legend-item"><div class="legend-dot" style="background:#636e72;opacity:0.4"></div>OLD AGE â€” no corpse</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Population Graph</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:5px;">
        <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#00f5c4"><div style="width:8px;height:8px;background:#00f5c4;border-radius:1px;flex-shrink:0"></div>HERB</div>
        <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#ff4d6d"><div style="width:8px;height:8px;background:#ff4d6d;border-radius:1px;flex-shrink:0"></div>CARN</div>
        <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#2bbcff"><div style="width:8px;height:8px;background:#2bbcff;border-radius:1px;flex-shrink:0"></div>OMNI</div>
        <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#ffd166"><div style="width:8px;height:8px;background:#ffd166;border-radius:1px;flex-shrink:0"></div>FOOD</div>
      </div>
      <div class="mini-chart"><canvas id="chartCanvas"></canvas></div>
    </div>
    <div class="section">
      <div class="section-title">Species <span id="speciesCount" style="color:var(--text);font-size:9px;letter-spacing:1px">0</span></div>
      <div class="species-grid" id="speciesGrid"></div>
    </div>
    <div class="section">
      <div class="section-title">Selection Info</div>
      <div class="info-box" id="infoBox"><b>Click a creature</b> to inspect its genes and status.</div>
    </div>
  </div>
</div>

<footer>
  <span>ARTIFICIAL LIFE SIMULATOR â€” EVOLUTIONARY GENETICS ENGINE</span>
  <span id="fpsDisplay">60 FPS</span>
</footer>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const chartCanvas = document.getElementById('chartCanvas');
const chartCtx = chartCanvas.getContext('2d');

let creatures = [];
let foods = [];
let seeds = []; // Seeds generate food but can't be eaten
let selectedSpeciesId = null; // for species highlight feature

// â”€â”€ Species registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each species = { id, type, shape, count } where shape is a polygon vertex count
// Base shapes per type: herbivore=6(hex), carnivore=4(diamond), omnivore=0(circle)
// New species get shapes: 3(tri), 5(pent), 7(hept), 8(oct)...
const EXTRA_SHAPES   = [3, 5, 7, 8, 9, 10, 11, 12, 3, 5, 7, 8, 9, 10]; // cycling pool â€” 14 distinct shapes
let   speciesRegistry = {}; // key: speciesId -> { id, type, shape, color }
let   nextShapeIdx    = 0;

// Species distance threshold: creatures with genome distance > this fork a new species
// Speciation distance threshold.
// genomeVec normalises 7 traits into [0,1]; max possible distance = sqrt(7/7) = 1.0
// With 10% mutation rate, children drift ~0.05â€“0.15 per generation.
// Threshold of 0.25 means ~4-6 generations of directional drift before forking.
const SPECIATION_THRESHOLD = 0.25;

function genomeVec(dna) {
  // Normalised vector of heritable traits for distance comparison
  return [
    dna.speed      / 5,
    dna.sense      / 200,
    dna.size       / 12,
    dna.fertility  / 0.01,
    dna.metabolism / 0.08,
    dna.aggression,
    (dna.stamina ?? 1.0),
  ];
}

function genomeDist(a, b) {
  const va = genomeVec(a), vb = genomeVec(b);
  let s = 0;
  for (let i = 0; i < va.length; i++) s += (va[i]-vb[i])**2;
  return Math.sqrt(s / va.length);
}

function assignSpecies(c) {
  // Find the closest registered species of same type
  let bestId = null, bestDist = Infinity;
  for (const [sid, sp] of Object.entries(speciesRegistry)) {
    if (sp.type !== c.dna.type) continue;
    const d = genomeDist(c.dna, sp.centroid);
    if (d < bestDist) { bestDist = d; bestId = sid; }
  }
  if (bestId !== null && bestDist < SPECIATION_THRESHOLD) {
    c.speciesId = bestId;
  } else {
    // Fork a new species
    const sid = 'sp_' + Math.random().toString(36).slice(2,7);
    const sameTypeSpecies = Object.values(speciesRegistry).filter(s => s.type === c.dna.type);
    const isBase = sameTypeSpecies.length === 0;
    const baseShape = c.dna.type === 'herbivore' ? 6
                    : c.dna.type === 'omnivore'  ? 0
                    : 4;
    // Rotate through extra shapes; each type has its own counter
    const shape = isBase ? baseShape : EXTRA_SHAPES[nextShapeIdx++ % EXTRA_SHAPES.length];
    speciesRegistry[sid] = {
      id: sid, type: c.dna.type, shape,
      centroid: { type: c.dna.type, ...c.dna }
    };
    c.speciesId = sid;
    console.log(`New species: ${sid} (${c.dna.type}, shape=${shape}, dist=${bestDist?.toFixed(3)})`);
  }
}

function updateSpeciesCentroids() {
  // Recalculate centroid (average genome) of each living species
  const sums   = {};
  const counts = {};
  for (const c of creatures) {
    if (!c.alive || !c.speciesId) continue;
    const sid = c.speciesId;
    if (!sums[sid]) { sums[sid] = genomeVec(c.dna).map(() => 0); counts[sid] = 0; }
    const v = genomeVec(c.dna);
    for (let i = 0; i < v.length; i++) sums[sid][i] += v[i];
    counts[sid]++;
  }
  const keys = ['speed','sense','size','fertility','metabolism','aggression','stamina'];
  const scale = [5, 200, 12, 0.01, 0.08, 1, 1.0];
  for (const [sid, sp] of Object.entries(speciesRegistry)) {
    if (!counts[sid]) continue;
    const avg = sums[sid].map((s,i) => s / counts[sid]);
    keys.forEach((k,i) => { sp.centroid[k] = avg[i] * scale[i]; });
    sp.centroid.type = sp.type; // preserve type field
  }
  // Prune extinct species
  const activeSids = new Set(creatures.filter(c => c.alive && c.speciesId).map(c => c.speciesId));
  for (const sid of Object.keys(speciesRegistry)) {
    if (!activeSids.has(sid)) delete speciesRegistry[sid];
  }
}
let tick = 0;
let generation = 1;
let playing = true;
let speed = 1;
let selectedCreature = null;
let corpses = [];

// â”€â”€ Pheromone grids â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PHERO_CELL = 8;        // pixels per grid cell
let pheroW = 1, pheroH = 1; // grid dimensions, set on resize
let pheroHerb = null;        // herbivore scent (teal) â€” carnivores follow this
let pheroCarn = null;        // carnivore scent (red)  â€” herbivores flee this
let pheroOmni = null;        // omnivore scent (cyan)  â€” distinct from herb
let pheroCanvas = null;      // offscreen canvas for pre-blended pheromone image
let pheroCtx2   = null;
let pheroNeedsRedraw = true; // flag: redraw offscreen when data changes

function initPhero() {
  pheroW = Math.ceil(canvas.width  / PHERO_CELL);
  pheroH = Math.ceil(canvas.height / PHERO_CELL);
  pheroHerb = new Float32Array(pheroW * pheroH);
  pheroCarn = new Float32Array(pheroW * pheroH);
  pheroOmni = new Float32Array(pheroW * pheroH);
  // Offscreen canvas mirrors the phero grid
  pheroCanvas = document.createElement('canvas');
  pheroCanvas.width  = pheroW * PHERO_CELL;
  pheroCanvas.height = pheroH * PHERO_CELL;
  pheroCtx2 = pheroCanvas.getContext('2d');
  pheroNeedsRedraw = true;
}

function pheroIdx(gx, gy) { return gy * pheroW + gx; }

function depositPhero(grid, x, y, amount) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  if (gx < 0 || gx >= pheroW || gy < 0 || gy >= pheroH) return;
  grid[pheroIdx(gx, gy)] = Math.min(1, grid[pheroIdx(gx, gy)] + amount);
}

function samplePhero(grid, x, y) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  if (gx < 0 || gx >= pheroW || gy < 0 || gy >= pheroH) return 0;
  return grid[pheroIdx(gx, gy)];
}

// Read gradient of grid at position â€” returns (dx,dy) pointing uphill
function pheroGradient(grid, x, y) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  const get = (gx2, gy2) => {
    if (gx2 < 0 || gx2 >= pheroW || gy2 < 0 || gy2 >= pheroH) return 0;
    return grid[pheroIdx(gx2, gy2)];
  };
  const dx = get(gx+1, gy) - get(gx-1, gy);
  const dy = get(gx, gy+1) - get(gx, gy-1);
  return { dx, dy };
}

// Evaporate and diffuse the grid â€” called each tick
function updatePhero(grid) {
  const evap    = 0.992; // retain 99.2% each tick â€” slow fade
  const diffuse = 0.06;  // how much bleeds to neighbours
  const next = new Float32Array(grid.length);
  for (let gy = 0; gy < pheroH; gy++) {
    for (let gx = 0; gx < pheroW; gx++) {
      const i   = pheroIdx(gx, gy);
      const val = grid[i] * evap;
      const bleed = val * diffuse;
      next[i] += val - bleed;
      // Spread a fraction to the 4 neighbours
      if (gx > 0)          next[pheroIdx(gx-1, gy)] += bleed * 0.25;
      if (gx < pheroW - 1) next[pheroIdx(gx+1, gy)] += bleed * 0.25;
      if (gy > 0)          next[pheroIdx(gx, gy-1)] += bleed * 0.25;
      if (gy < pheroH - 1) next[pheroIdx(gx, gy+1)] += bleed * 0.25;
    }
  }
  grid.set(next);
}


// â”€â”€ Spatial Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Bins all objects into fixed-size cells so neighbour lookups are O(1) average
// instead of O(n). Rebuilt from scratch each tick (cheap for <1000 objects).
const GRID_CELL = 80; // px â€” tune to ~2Ã— typical sense radius
class SpatialGrid {
  constructor(W, H) {
    this.cols = Math.ceil(W / GRID_CELL);
    this.rows = Math.ceil(H / GRID_CELL);
    this.cells = new Array(this.cols * this.rows).fill(null).map(() => []);
  }
  _idx(x, y) {
    const col = Math.max(0, Math.min(this.cols-1, Math.floor(x / GRID_CELL)));
    const row = Math.max(0, Math.min(this.rows-1, Math.floor(y / GRID_CELL)));
    return row * this.cols + col;
  }
  insert(obj) { this.cells[this._idx(obj.x, obj.y)].push(obj); }
  // Query all objects within radius r of (x,y)
  query(x, y, r) {
    const c0 = Math.max(0, Math.floor((x-r)/GRID_CELL));
    const c1 = Math.min(this.cols-1, Math.floor((x+r)/GRID_CELL));
    const r0 = Math.max(0, Math.floor((y-r)/GRID_CELL));
    const r1 = Math.min(this.rows-1, Math.floor((y+r)/GRID_CELL));
    const out = [];
    const r2  = r*r;
    for (let row = r0; row <= r1; row++) {
      for (let col = c0; col <= c1; col++) {
        for (const o of this.cells[row*this.cols+col]) {
          const dx = o.x-x, dy = o.y-y;
          if (dx*dx+dy*dy <= r2) out.push(o);
        }
      }
    }
    return out;
  }
}

// Per-tick grids (rebuilt in updateSim before creature updates)
let sgCreatures = null; // all alive creatures
let sgFoods     = null; // food pellets
let sgCorpses   = null; // corpses

function rebuildGrids() {
  const W = canvas.width, H = canvas.height;
  sgCreatures = new SpatialGrid(W, H);
  sgFoods     = new SpatialGrid(W, H);
  sgCorpses   = new SpatialGrid(W, H);
  for (const c of creatures) { if (c.alive) sgCreatures.insert(c); }
  for (const f of foods)     sgFoods.insert(f);
  for (const co of corpses)  sgCorpses.insert(co);
}

// Grid-accelerated nearest-neighbour (replaces findNearest for hot paths)
function gridNearest(x, y, grid, maxDist, filterFn) {
  const candidates = grid ? grid.query(x, y, maxDist) : [];
  let best = null, bd = maxDist * maxDist;
  for (const o of candidates) {
    if (filterFn && !filterFn(o)) continue;
    const dx = o.x-x, dy = o.y-y;
    const d2 = dx*dx+dy*dy;
    if (d2 < bd) { bd = d2; best = o; }
  }
  return best;
}

// Grid-accelerated cone search
function gridInCone(cx, cy, vx, vy, grid, range, halfArc, filterFn) {
  const candidates = grid ? grid.query(cx, cy, range) : [];
  const heading = Math.atan2(vy, vx);
  const spd     = Math.sqrt(vx*vx + vy*vy);
  const useCone = spd > 0.1;
  let best = null, bd = range*range;
  for (const o of candidates) {
    if (filterFn && !filterFn(o)) continue;
    const dx = o.x-cx, dy = o.y-cy;
    const d2 = dx*dx+dy*dy;
    if (d2 >= bd) continue;
    if (useCone) {
      let diff = Math.atan2(dy, dx) - heading;
      while (diff >  Math.PI) diff -= 2*Math.PI;
      while (diff < -Math.PI) diff += 2*Math.PI;
      if (Math.abs(diff) > halfArc) continue;
    }
    bd = d2; best = o;
  }
  return best;
}

// How many ticks creatures stay in the purple mating state before baby spawns
const MATING_DURATION = 60;

const params = { foodRate: 8, maxFood: 120, mutRate: 10, flockStr: 10, showPhero: false };
const history = { h: [], c: [], o: [], f: [] };
const MAX_HISTORY = 196;

// â”€â”€ Seasons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SEASON_LENGTH = 1200; // ticks per season
const SEASONS = [
  { name: 'SPRING', emoji: 'ğŸŒ±', color: '#00f5c4', foodMult: 2.2,  metaMult: 0.85, barColor: '#00f5c4' },
  { name: 'SUMMER', emoji: 'â˜€ï¸', color: '#ffd166', foodMult: 1.0,  metaMult: 1.0,  barColor: '#ffd166' },
  { name: 'AUTUMN', emoji: 'ğŸ‚', color: '#ff9a3c', foodMult: 0.55, metaMult: 1.15, barColor: '#ff9a3c' },
  { name: 'WINTER', emoji: 'â„ï¸', color: '#a0b4f0', foodMult: 0.2,  metaMult: 1.45, barColor: '#a0b4f0' },
];
let currentSeasonIdx = 0;
let seasonTick = 0; // ticks elapsed in current season

function getCurrentSeason() { return SEASONS[currentSeasonIdx]; }

// â”€â”€ Weather events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WEATHER_EVENTS = [
  { name: 'DROUGHT',        emoji: 'ğŸ”¥', color: '#ff6b35', foodMult: 0.15, metaMult: 1.1,  duration: 700,  desc: 'Food growth halted. All creatures burn more energy.' },
  { name: 'PLAGUE WIND',    emoji: 'ğŸ’¨', color: '#c084fc', foodMult: 1.0,  metaMult: 1.5,  duration: 600,  desc: 'A toxic wind raises metabolism across the ecosystem.' },
  { name: 'FEEDING FRENZY', emoji: 'âš¡', color: '#00f5c4', foodMult: 2.8,  metaMult: 0.9,  duration: 450,  desc: 'Food explodes. Populations surge â€” then crash.' },
  { name: 'BLIZZARD',       emoji: 'ğŸŒ¨ï¸', color: '#7dd3fc', foodMult: 0.05, metaMult: 1.6,  duration: 600,  desc: 'Near-zero food. Metabolism spikes. Only the fat survive.' },
];
let activeWeather = null;    // { event, ticksLeft }
let weatherCooldown = 800;   // ticks until next possible event

// â”€â”€ DNA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function randomDNA(type) {
  return {
    type,
    speed:      0.5 + Math.random() * 2.5,
    sense:      30  + Math.random() * 120,
    size:       3   + Math.random() * 5,
    fertility:  0.001 + Math.random() * 0.004,
    metabolism: 0.015 + Math.random() * 0.03,
    aggression: type === 'carnivore' ? 0.5 + Math.random() * 0.5 : Math.random() * 0.3,
    stamina:    (type === 'carnivore' || type === 'omnivore') ? 0.4 + Math.random() * 0.6 : 1.0,
  };
}

function mutateDNA(dna) {
  const m = params.mutRate / 100;
  const mut = v => v * (1 + (Math.random() * 2 - 1) * m);
  return {
    type:       dna.type,
    speed:      Math.max(0.2, Math.min(5,    mut(dna.speed))),
    sense:      Math.max(15,  Math.min(200,  mut(dna.sense))),
    size:       Math.max(2,   Math.min(12,   mut(dna.size))),
    fertility:  Math.max(0.0005, Math.min(0.01, mut(dna.fertility))),
    metabolism: Math.max(0.005,  Math.min(0.08, mut(dna.metabolism))),
    aggression: Math.max(0,   Math.min(1,    mut(dna.aggression))),
    stamina:    Math.max(0.1, Math.min(1.0,  mut(dna.stamina ?? 1.0))),
  };
}

// â”€â”€ Factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createCreature(type, x, y, dna) {
  dna = dna || randomDNA(type);
  const c = {
    id:             Math.random().toString(36).slice(2),
    dna,
    x:              x ?? Math.random() * canvas.width,
    y:              y ?? Math.random() * canvas.height,
    vx:             (Math.random() - 0.5) * 2,
    vy:             (Math.random() - 0.5) * 2,
    energy:         150, // Start at 50% of max (300) â€” must eat before mating
    age:            0,
    alive:          true,
    matingWith:     null,  // partner reference during active mating
    matingTicks:    0,     // progress through MATING_DURATION
    matingCooldown: 0,     // post-birth cooldown
    mateCount:      0,     // successful matings; capped at 3
    sleeping:       false, // currently asleep
    sleepTicks:     0,     // ticks remaining in sleep
    sleepCooldown:  Math.floor(Math.random() * 400) + 200, // ticks until next sleep check
    wakeScatter:    0,     // >0 = startled, flee at full speed
    sprinting:      false, // is currently sprinting
    packTarget:     null,  // shared prey reference for pack hunting
    status:         'WANDERING',
    speciesId:      null,  // assigned by speciation system
    // â”€â”€ Memory (individual learning) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    memFoodX:       null,  // last position where food was successfully eaten
    memFoodY:       null,
    memFoodAge:     0,     // how many ticks ago food was found (fades usefulness)
    memHuntWins:    {},    // { preyType: successCount } for predator intelligence
    memHuntAttempts:{},    // { preyType: attemptCount }
    trail:          [],
    gen:            generation,
  };
  assignSpecies(c);
  return c;
}

function createFood(x, y) {
  return {
    x:      x ?? Math.random() * canvas.width,
    y:      y ?? Math.random() * canvas.height,
    energy: 20 + Math.random() * 30,
  };
}

function createSeed(x, y) {
  return {
    x:       x ?? Math.random() * canvas.width,
    y:       y ?? Math.random() * canvas.height,
    budget:  100 + Math.floor(Math.random() * 200), // disperses 100â€“300 food then dies
    spawned: 0,
    age:     0,
  };
}
function spawnSeed(n) { for (let i = 0; i < (n||1); i++) seeds.push(createSeed()); }

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetSim() {
  creatures = []; foods = []; corpses = []; seeds = []; initPhero();
  tick = 0; generation = 1;
  history.h = []; history.c = []; history.o = []; history.f = [];
  selectedCreature = null;
  speciesRegistry = {}; nextShapeIdx = 0;
  currentSeasonIdx = 0; seasonTick = 0;
  activeWeather = null; weatherCooldown = 800;
  selectedSpeciesId = null;
  for (let i = 0; i < 40; i++) creatures.push(createCreature('herbivore'));
  for (let i = 0; i < 10; i++) creatures.push(createCreature('carnivore'));
  for (let i = 0; i < 15; i++) creatures.push(createCreature('omnivore'));
  for (let i = 0; i < 50; i++) foods.push(createFood());
}

function spawnCreatures(type, n) { for (let i = 0; i < n; i++) creatures.push(createCreature(type)); }

function spawnFromSpecies(sid) {
  const sp = speciesRegistry[sid];
  if (!sp) { console.warn('spawnFromSpecies: unknown sid', sid); return; }
  const n = spawnAmt();
  for (let i = 0; i < n; i++) {
    const dna = mutateDNA({ ...sp.centroid, type: sp.type });
    // Build directly â€” don't use createCreature() which calls assignSpecies()
    // and would reassign speciesId based on genome distance
    const creature = {
      id:              Math.random().toString(36).slice(2),
      dna,
      x:               Math.random() * canvas.width,
      y:               Math.random() * canvas.height,
      vx:              (Math.random() - 0.5) * 2,
      vy:              (Math.random() - 0.5) * 2,
      energy:          150,
      age:             0,
      alive:           true,
      matingWith:      null,
      matingTicks:     0,
      matingCooldown:  0,
      mateCount:       0,
      sleeping:        false,
      sleepTicks:      0,
      sleepCooldown:   Math.floor(Math.random() * 400) + 200,
      wakeScatter:     0,
      sprinting:       false,
      packTarget:      null,
      status:          'WANDERING',
      speciesId:       sid,
      memFoodX:        null,
      memFoodY:        null,
      memFoodAge:      0,
      memHuntWins:     {},
      memHuntAttempts: {},
      trail:           [],
      gen:             generation,
    };
    creatures.push(creature);
  }
}
function spawnFood(n)            { for (let i = 0; i < n; i++) foods.push(createFood()); }

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dist(a, b) {
  const dx = a.x - b.x, dy = a.y - b.y;
  return Math.sqrt(dx*dx + dy*dy);
}

function findNearest(c, list, maxDist) {
  let best = null, bd = maxDist;
  for (const item of list) {
    const d = dist(c, item);
    if (d < bd) { bd = d; best = item; }
  }
  return best;
}

// Returns success rate [0..1] for a given prey key, defaulting to 0.5 (neutral) if no data
function huntSuccessRate(c, preyType, extra) {
  const key = preyType + (extra || '');
  const wins = c.memHuntWins    ? (c.memHuntWins[key]     || 0) : 0;
  const att  = c.memHuntAttempts? (c.memHuntAttempts[key] || 0) : 0;
  if (att < 3) return 0.5; // insufficient data â€” neutral
  return wins / att;
}

// Cone vision for carnivores â€” forward-facing arc, longer range
// angle is half-arc in radians (Math.PI/3 = 60Â° each side = 120Â° total)
function findInCone(c, list, range, halfArc) {
  const heading = Math.atan2(c.vy, c.vx);
  // Fallback to full circle if barely moving
  const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
  const useCone = spd > 0.1;
  let best = null, bd = range;
  for (const item of list) {
    const dx = item.x - c.x, dy = item.y - c.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d >= bd) continue;
    if (useCone) {
      const angle = Math.atan2(dy, dx);
      let diff = angle - heading;
      // Normalise to -PI..PI
      while (diff >  Math.PI) diff -= 2*Math.PI;
      while (diff < -Math.PI) diff += 2*Math.PI;
      if (Math.abs(diff) > halfArc) continue;
    }
    bd = d; best = item;
  }
  return best;
}

// â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCreature(c) {
  if (!c.alive) return;

  c.age++;
  if (c.matingCooldown > 0) c.matingCooldown--;
  // Normal metabolism; slow down in the last 20% to give the boom-bust cycle
  // more time to stabilise rather than crash
  const baseDrain = c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002;
  const seasonMult = window._seasonMetaMult || 1.0;
  const drainMult = (c.energy < 60 ? 0.45 : 1.0) * seasonMult; // 55% slower when starving
  c.energy -= baseDrain * drainMult;

  if (c.energy <= 0 || c.age > 4000) {
    if (c.matingWith) { c.matingWith.matingWith = null; c.matingWith.matingTicks = 0; }
    // All deaths leave a corpse (burst carnivore pheromone too â€” death smell)
    corpses.push({ x: c.x, y: c.y, energy: 20 + Math.random() * 25, decay: 0, fromType: c.dna.type });
    // Large pheromone burst on death â€” attracts carnivores and omnivores
    if (pheroCarn) depositPhero(pheroCarn, c.x, c.y, 1.0);
    if (pheroOmni) depositPhero(pheroOmni, c.x, c.y, 0.7);
    c.alive = false;
    return;
  }

  const W = canvas.width, H = canvas.height;

  // â”€â”€ SLEEP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (c.sleeping) {
    c.sleepTicks--;
    // Sleeping metabolism is 10% of normal
    // (energy was already deducted at 100% above; refund 90%)
    c.energy += (c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002) * 0.9;

    // Dampen velocity â€” nearly still
    c.vx *= 0.05; c.vy *= 0.05;
    c.x += c.vx; c.y += c.vy;
    if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
    if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;
    c.trail.push({ x: c.x, y: c.y });
    if (c.trail.length > 8) c.trail.shift();

    if (c.sleepTicks <= 0) {
      c.sleeping = false;
      // Re-randomise cooldown each time to prevent synchronised sleep waves
      c.sleepCooldown = 200 + Math.floor(Math.random() * 600);
    }
    c.energy = Math.min(c.energy, 300);
    return; // Skip all other behaviour while asleep
  }

  // Startled â€” flee at max speed for a short burst
  if (c.wakeScatter > 0) {
    c.wakeScatter--;
    // Random scatter direction was set when startled; just let velocity carry
    const spd0 = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
    if (spd0 > c.dna.speed * 2) { c.vx = (c.vx/spd0)*c.dna.speed*2; c.vy = (c.vy/spd0)*c.dna.speed*2; }
  }

  // Tick down sleep cooldown; trigger sleep when it hits zero
  if (c.sleepCooldown > 0) {
    c.sleepCooldown--;
  } else if (!c.matingWith && c.wakeScatter === 0) {
    // Fall asleep: duration 180-360 ticks
    c.sleeping = true;
    c.sleepTicks = 180 + Math.floor(Math.random() * 180);
    c.vx *= 0.1; c.vy *= 0.1;
    c.energy = Math.min(c.energy, 300);
    return;
  }

  // â”€â”€ ACTIVE MATING (creature is purple) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (c.matingWith) {
    const partner = c.matingWith;

    // Safety checks: cancel if partner died, or partner no longer points back (stale link)
    if (!partner.alive || partner.matingWith !== c) {
      c.matingWith = null; c.matingTicks = 0;
    } else {
      // Only the lower-id creature drives the tick counter to avoid double-counting
      if (c.id < partner.id) c.matingTicks++;
      else c.matingTicks = partner.matingTicks; // mirror the master's progress

      // Drift slowly toward partner â€” easy prey for carnivores!
      const dx = partner.x - c.x, dy = partner.y - c.y;
      const d  = Math.sqrt(dx*dx + dy*dy) + 0.001;
      c.vx += (dx/d) * 0.15;
      c.vy += (dy/d) * 0.15;
      const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
      const cap = c.dna.speed * 0.3;
      if (spd > cap) { c.vx = (c.vx/spd)*cap; c.vy = (c.vy/spd)*cap; }
      c.x += c.vx; c.y += c.vy;
      if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
      if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 8) c.trail.shift();

      // Spawn babies at end â€” only the lower-id creature (the "mother") births
      if (c.matingTicks >= MATING_DURATION && c.id < partner.id) {
        const avg = (a, b) => (a + b) / 2;
        const newGen = Math.max(c.gen, partner.gen) + 1;
        generation = Math.max(generation, newGen);
        // 80% = 1 offspring, 15% = 2, 5% = 3
        const roll = Math.random();
        const numOffspring = roll < 0.80 ? 1 : roll < 0.95 ? 2 : 3;
        for (let n = 0; n < numOffspring; n++) {
          const childDNA = mutateDNA({
            type:       c.dna.type,
            speed:      avg(c.dna.speed,      partner.dna.speed),
            sense:      avg(c.dna.sense,      partner.dna.sense),
            size:       avg(c.dna.size,       partner.dna.size),
            fertility:  avg(c.dna.fertility,  partner.dna.fertility),
            metabolism: avg(c.dna.metabolism, partner.dna.metabolism),
            aggression: avg(c.dna.aggression, partner.dna.aggression),
            stamina:    avg(c.dna.stamina ?? 1.0, partner.dna.stamina ?? 1.0),
          });
          const child = createCreature(
            c.dna.type,
            c.x + (Math.random()-0.5)*24,
            c.y + (Math.random()-0.5)*24,
            childDNA
          );
          child.gen = newGen;
          assignSpecies(child); // child may fork new species if sufficiently mutated
          creatures.push(child);
        }
        // Energy cost scales with number of offspring; carnivores pay 50% less
        const baseCost = 30 + numOffspring * 15;
        const costMult = (c.dna.type === 'carnivore' || c.dna.type === 'omnivore') ? 0.5 : 1.0;
        const cost = baseCost * costMult;
        c.energy -= cost; partner.energy -= cost * 0.5;
        c.matingCooldown = 120; partner.matingCooldown = 120;
        c.mateCount++;       // track successful births
        partner.mateCount++; // both parents count it
      }

      // End mating phase for both
      if (c.matingTicks >= MATING_DURATION) {
        partner.matingWith = null; partner.matingTicks = 0;
        c.matingWith       = null; c.matingTicks       = 0;
      }
    }

    c.energy = Math.min(c.energy, 300);
    return; // Skip normal behaviour while mating
  }

  // â”€â”€ NORMAL BEHAVIOUR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  c.trail.push({ x: c.x, y: c.y });
  if (c.trail.length > 8) c.trail.shift();

  const MATE_ENERGY  = 240; // 80% of max 300 â€” required to mate
  const SATED_ENERGY = 270; // 90% of max 300 â€” above this, behaviour shifts
  const MAX_MATES    = c.dna.type === 'herbivore' ? 3 : 5; // carns/omnis retire at 5

  const isSated    = c.energy >= SATED_ENERGY;
  const canMate    = c.matingCooldown === 0 && c.mateCount < MAX_MATES && !c.matingWith;
  const mateElig   = canMate && c.energy >= MATE_ENERGY;

  let tx = null, ty = null;

  if (c.dna.type === 'herbivore') {
    c.status = 'FORAGING';
    // Shepherded herbivores feel protected â€” they don't flee (shepherd provides safety)
    const isShepherded = !!(c._shepherdRef && c._shepherdRef.alive);
    // Always flee carnivores UNLESS currently shepherded
    if (!isShepherded) {
      const fleeRange = isSated ? c.dna.sense * 1.4 : c.dna.sense;
      const predator = gridNearest(c.x, c.y, sgCreatures, fleeRange,
        o => o !== c && o.dna.type === 'carnivore');
      if (predator) {
        const dx = c.x - predator.x, dy = c.y - predator.y;
        const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
        tx = c.x + (dx/d) * (isSated ? 120 : 80);
        ty = c.y + (dy/d) * (isSated ? 120 : 80);
        c.status = 'FLEEING';
      }
    } else {
      c.status = 'SHEPHERDED';
    }
    // Mildly repelled by corpses (smell of death = predator nearby)
    if (tx === null) {
      const corpse = gridNearest(c.x, c.y, sgCorpses, c.dna.sense * 0.5, null);
      if (corpse) {
        const dx = c.x - corpse.x, dy = c.y - corpse.y;
        const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
        tx = c.x + (dx/d) * 40; ty = c.y + (dy/d) * 40;
      }
    }
    // Flee carnivore pheromone trail â€” avoid areas carnivores recently passed through
    // (Herbivores only â€” omnivores don't fear carnivore scent)
    if (tx === null && pheroCarn) {
      const grad = pheroGradient(pheroCarn, c.x, c.y);
      const mag  = Math.sqrt(grad.dx*grad.dx + grad.dy*grad.dy);
      if (mag > 0.02) {
        c.vx -= (grad.dx/mag) * 0.25;
        c.vy -= (grad.dy/mag) * 0.25;
      }
    }
    // Only seek food when NOT sated
    if (tx === null && !isSated) {
      const food = gridNearest(c.x, c.y, sgFoods, c.dna.sense, null);
      if (food) { tx = food.x; ty = food.y; c.status = 'SEEKING FOOD'; }
    }
    // Seek mate when eligible
    if (tx === null && mateElig) {
      const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.8,
        o => o !== c && o.dna.type === 'herbivore' && o.energy >= MATE_ENERGY
          && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
      if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
    }
    if (isSated && tx === null) c.status = 'SATED â€” WANDERING';

  } else if (c.dna.type === 'omnivore') {
    // â”€â”€ OMNIVORE BEHAVIOUR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Dual vision: cone (forward, long) + circle (close, omnidirectional)
    const CONE_RANGE  = c.dna.sense * 1.8;
    const CONE_ARC    = Math.PI / 3;

    c.sprinting = false;
    c.status = 'FORAGING';

    const lists = window._simLists || {};
    const dangerCarn = gridNearest(c.x, c.y, sgCreatures, c.dna.sense,
      o => o !== c && o.dna.type === 'carnivore');

    if (isSated) {
      // SHEPHERDING: attract nearby herbivores to follow
      c.status = 'SHEPHERDING';
      // Seek mates if eligible
      if (mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.8,
          o => o !== c && o.dna.type === 'omnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
    } else {
      // Flee awake carnivores
      if (dangerCarn && !dangerCarn.sleeping) {
        const dx = c.x - dangerCarn.x, dy = c.y - dangerCarn.y;
        const d = Math.sqrt(dx*dx+dy*dy)+0.001;
        tx = c.x + (dx/d)*100; ty = c.y + (dy/d)*100;
        c.status = 'FLEEING CARNIVORE';
      }
      // Scavenge corpses (omnis eat all corpses â€” priority)
      if (tx === null) {
        const nc = gridNearest(c.x, c.y, sgCorpses, c.dna.sense, null);
        if (nc) { tx = nc.x; ty = nc.y; c.packTarget = null; c.status = 'SCAVENGING'; }
      }
      // Eat food like herbivore
      if (tx === null) {
        const food = gridNearest(c.x, c.y, sgFoods, c.dna.sense, null);
        if (food) { tx = food.x; ty = food.y; c.status = 'SEEKING FOOD'; }
      }
      // Seek mate if nothing else
      if (tx === null && mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.5,
          o => o !== c && o.dna.type === 'omnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
      if (tx === null) { c.status = 'WANDERING'; c.packTarget = null; }
    }

  } else {
    // â”€â”€ CARNIVORE BEHAVIOUR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const CONE_RANGE  = c.dna.sense * 2.8;
    const CONE_ARC    = Math.PI / 3;

    c.sprinting = false;
    const lists = window._simLists || {};

    // Avoid safe omnivores â€” keep distance unless sleeping, mating, or <20% energy
    const safeOmni = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.7,
      o => o !== c && o.dna.type === 'omnivore' && !o.sleeping && !o.matingWith && o.energy >= 60);
    if (safeOmni) {
      const dx = c.x - safeOmni.x, dy = c.y - safeOmni.y;
      const d = Math.sqrt(dx*dx+dy*dy)+0.001;
      c.vx += (dx/d) * 0.35; c.vy += (dy/d) * 0.35;
    }

    if (isSated) {
      c.status = 'SEEKING MATE';
      if (mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.8,
          o => o !== c && o.dna.type === 'carnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; }
      }
      if (tx === null) c.status = 'SATED â€” WANDERING';
    } else {
      c.status = 'HUNTING';

      // Pack hunting coordination
      let packInterceptX = null, packInterceptY = null;
      for (const pack of (lists.carns || [])) {
        if (pack === c || !pack.packTarget) continue;
        if (dist(c, pack) > c.dna.sense * 1.2) continue;
        const prey = pack.packTarget;
        if (!prey.alive) continue;
        const interceptX = prey.x + prey.vx * 20;
        const interceptY = prey.y + prey.vy * 20;
        if (dist(c, prey) > dist(pack, prey)) {
          packInterceptX = interceptX; packInterceptY = interceptY; break;
        }
      }
      if (packInterceptX !== null) { tx = packInterceptX; ty = packInterceptY; c.status = 'PACK FLANKING'; }

      // Cone prey detection â€” sleeping first (grid-accelerated)
      if (tx === null) {
        const sp = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.sleeping);
        if (sp) { tx = sp.x; ty = sp.y; c.packTarget = sp; c.status = 'STALKING'; }
      }
      // Mating prey
      if (tx === null) {
        const pp = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.matingWith !== null);
        if (pp) { tx = pp.x; ty = pp.y; c.packTarget = pp; c.status = 'HUNTING MATING PREY'; }
      }
      // Cannibalism (weak young carnivore)
      if (tx === null) {
        const wc = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.dna.type === 'carnivore' && o.energy < 30 && o.age < c.age*0.5);
        if (wc) { tx = wc.x; ty = wc.y; c.packTarget = wc; c.status = 'CANNIBALISING'; }
      }
      // Vulnerable omnivore: sleeping, mating, or <10% energy
      if (tx === null) {
        const vo = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.dna.type === 'omnivore'
            && (o.sleeping || o.matingWith !== null || o.energy < 30));
        if (vo) { tx = vo.x; ty = vo.y; c.packTarget = vo; c.status = 'HUNTING OMNIVORE'; }
      }
      // Corpses (omnidirectional smell)
      if (tx === null) {
        const nc = gridNearest(c.x, c.y, sgCorpses, c.dna.sense, null);
        if (nc) { tx = nc.x; ty = nc.y; c.packTarget = null; c.status = 'SCAVENGING'; }
      }
      // Herbivores in cone â€” grid-accelerated + scored by hunt memory
      if (tx === null) {
        const rawCands = sgCreatures ? sgCreatures.query(c.x, c.y, CONE_RANGE) : [];
        const heading = Math.atan2(c.vy, c.vx);
        const spd = Math.sqrt(c.vx*c.vx+c.vy*c.vy);
        const useCone = spd > 0.1;
        const candidates = rawCands.filter(h => {
          if (!h.alive || h === c || h.dna.type !== 'herbivore') return false;
          if (!useCone) return true;
          const dx = h.x-c.x, dy = h.y-c.y;
          let diff = Math.atan2(dy,dx) - heading;
          while (diff >  Math.PI) diff -= 2*Math.PI;
          while (diff < -Math.PI) diff += 2*Math.PI;
          return Math.abs(diff) <= CONE_ARC;
        });
        if (candidates.length > 0) {
          // Score each by success rate + proximity; experienced hunters chase the right prey
          let best = null, bestScore = -1;
          for (const h of candidates) {
            const rate = huntSuccessRate(c, 'herbivore');
            const proximity = 1 - dist(c, h) / CONE_RANGE;
            // Intelligence factor: weight success rate more heavily with age
            const intFactor = Math.min(1, c.age / 800);
            const score = proximity * (1 - intFactor) + rate * intFactor * proximity;
            if (score > bestScore) { bestScore = score; best = h; }
          }
          if (best) { tx = best.x; ty = best.y; c.packTarget = best; c.status = 'CHASING'; }
        }
      }
      // Follow pheromone trails when no direct target
      if (tx === null && (pheroHerb || pheroOmni)) {
        // Combine herb (full) + omni (60%) gradient signals
        let gdx = 0, gdy = 0;
        if (pheroHerb) { const g = pheroGradient(pheroHerb, c.x, c.y); gdx += g.dx; gdy += g.dy; }
        if (pheroOmni) { const g = pheroGradient(pheroOmni, c.x, c.y); gdx += g.dx * 0.6; gdy += g.dy * 0.6; }
        const mag = Math.sqrt(gdx*gdx + gdy*gdy);
        if (mag > 0.03) {
          c.vx += (gdx/mag) * 0.3; c.vy += (gdy/mag) * 0.3;
          c.packTarget = null; c.status = 'TRACKING SCENT';
        } else { c.packTarget = null; c.status = 'PATROLLING'; }
      } else if (tx === null) { c.packTarget = null; c.status = 'PATROLLING'; }

      if (tx === null && mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.5,
          o => o !== c && o.dna.type === 'carnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
    }
  }

  // Memory-biased wandering: drift toward last known food patch when no other goal
  if (tx !== null) {
    const dx = tx - c.x, dy = ty - c.y;
    const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
    c.vx += (dx/d) * 0.4; c.vy += (dy/d) * 0.4;
  } else if ((c.dna.type === 'herbivore' || c.dna.type === 'omnivore')
             && c.memFoodX !== null && c.memFoodAge < 400) {
    // Bias toward remembered food patch; strength fades with time
    const memStr = Math.max(0, 1 - c.memFoodAge / 400) * 0.25;
    const dx = c.memFoodX - c.x, dy = c.memFoodY - c.y;
    const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
    c.vx += (dx/d) * memStr; c.vy += (dy/d) * memStr;
    c.vx += (Math.random()-0.5) * 0.3; c.vy += (Math.random()-0.5) * 0.3;
  } else {
    c.vx += (Math.random()-0.5) * 0.5; c.vy += (Math.random()-0.5) * 0.5;
  }

  // â”€â”€ FLOCKING (Boids) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const flockRadius = c.dna.sense * 0.6;
  const sepRadius   = c.dna.size * 3.5;

  let sepX = 0, sepY = 0, sepN = 0;
  let aliX = 0, aliY = 0, aliN = 0;
  let cohX = 0, cohY = 0, cohN = 0;

  // Use spatial grid â€” only checks nearby cells instead of all creatures
  const flockNeighbours = sgCreatures ? sgCreatures.query(c.x, c.y, flockRadius) : [];
  for (const o of flockNeighbours) {
    if (o === c || o.sleeping || o.dna.type !== c.dna.type) continue;
    const dx = o.x - c.x, dy = o.y - c.y;
    const d2 = dx*dx + dy*dy;
    const d = Math.sqrt(d2) + 0.001;

    // Separation â€” push away from very close neighbours
    if (d < sepRadius) {
      sepX -= dx / d; sepY -= dy / d;
      sepN++;
    }
    // Alignment â€” match velocity of neighbours
    aliX += o.vx; aliY += o.vy; aliN++;
    // Cohesion â€” move toward centre of neighbours
    cohX += o.x; cohY += o.y; cohN++;
  }

  const fs = params.flockStr / 10;
  if (c.dna.type === 'herbivore') {
    // Herbivore flocking â€” safety in numbers
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.35 * fs; c.vy += (sepY/sepN) * 0.35 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.08 * fs; c.vy += (aliY/aliN - c.vy) * 0.08 * fs; }
    if (cohN > 0) {
      const cx = cohX/cohN - c.x, cy = cohY/cohN - c.y;
      const cd = Math.sqrt(cx*cx+cy*cy)+0.001;
      if (tx === null) { c.vx += (cx/cd) * 0.12 * fs; c.vy += (cy/cd) * 0.12 * fs; }
    }
    // Shepherd pull: if a nearby sated omnivore is shepherding, be drawn toward it
    const lists = window._simLists || {};
    const shepherd = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 1.6,
      o => o !== c && o.dna.type === 'omnivore' && o.alive && o.energy >= 270);
    if (shepherd) {
      const sdx = shepherd.x - c.x, sdy = shepherd.y - c.y;
      const sd  = Math.sqrt(sdx*sdx+sdy*sdy)+0.001;
      // Don't pull toward shepherd if already mid-flee (shepherd pull irrelevant)
      if (c.status !== 'FLEEING') {
        const shepherdPull = fs * 0.22;
        c.vx += (sdx/sd) * shepherdPull; c.vy += (sdy/sd) * shepherdPull;
      }
      // Shepherded herbivores share the omnivore's cone vision range (boosted)
      c._shepherdRef  = shepherd; // keep reference so we can draw the distinction
      c._shepherdVision = shepherd.dna.sense * 2.4;
    } else {
      c._shepherdVision = null;
      c._shepherdRef    = null;
    }
  } else if (c.dna.type === 'omnivore') {
    // Omnivores flock loosely with own kind â€” mild separation only
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.3 * fs; c.vy += (sepY/sepN) * 0.3 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.05 * fs; c.vy += (aliY/aliN - c.vy) * 0.05 * fs; }
  } else {
    // Carnivores spread out
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.5 * fs; c.vy += (sepY/sepN) * 0.5 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.04 * fs; c.vy += (aliY/aliN - c.vy) * 0.04 * fs; }
  }

  // Sprint: carnivores/omnivores chasing prey burn ENERGY for speed boost
  // stamina gene = efficiency multiplier; low stamina = more energy per sprint tick
  let maxSpd = c.dna.speed;
  const canSprint = (c.dna.type === 'carnivore' || c.dna.type === 'omnivore')
                    && tx !== null && c.energy > 75  // need >25% energy to sprint
                    && (c.status === 'CHASING' || c.status === 'STALKING'
                        || c.status === 'PACK FLANKING' || c.status === 'HUNTING MATING PREY'
                        || c.status === 'CANNIBALISING');
  if (canSprint) {
    maxSpd = c.dna.speed * 1.6;
    // Energy cost: base 0.08 per tick, divided by stamina gene (0.1â€“1.0)
    // Low stamina = more expensive sprint; high stamina = efficient
    const sprintCost = 0.08 / Math.max(0.1, c.dna.stamina);
    c.energy -= sprintCost;
    c.sprinting = true;
  }

  const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
  if (spd > maxSpd) { c.vx = (c.vx/spd)*maxSpd; c.vy = (c.vy/spd)*maxSpd; }
  c.x += c.vx; c.y += c.vy;
  if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
  if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

  // Herbivores and omnivores eat food when below sated threshold
  if ((c.dna.type === 'herbivore' || c.dna.type === 'omnivore') && !isSated) {
    for (let i = foods.length - 1; i >= 0; i--) {
      if (dist(c, foods[i]) < c.dna.size + 4) {
        c.energy += foods[i].energy;
        // Record memory of this food location
        c.memFoodX = foods[i].x; c.memFoodY = foods[i].y; c.memFoodAge = 0;
        foods.splice(i, 1);
        break;
      }
    }
  }
  // Age memory each tick
  if (c.memFoodX !== null) c.memFoodAge++;
  // Omnivores scavenge corpses (all types)
  if (c.dna.type === 'omnivore' && !isSated) {
    for (let i = corpses.length - 1; i >= 0; i--) {
      if (dist(c, corpses[i]) < c.dna.size + 5) {
        c.energy += corpses[i].energy;
        corpses.splice(i, 1);
        break;
      }
    }
  }

  // Carnivores hunt ONLY when below sated threshold (90%)
  if (c.dna.type === 'carnivore' && !isSated) {
    // Record hunt attempt periodically while actively chasing
    if (c.packTarget && c.packTarget.alive && c.age % 60 === 0) {
      const pKey = c.packTarget.dna.type + (c.packTarget.sleeping ? '_sleep' : c.packTarget.matingWith ? '_mating' : '');
      c.memHuntAttempts[pKey] = (c.memHuntAttempts[pKey] || 0) + 1;
    }
    let ate = false;
    for (const prey of creatures) {
      if (!prey.alive || prey === c) continue;
      const isPurple       = prey.matingWith !== null;
      const isHerbivore    = prey.dna.type === 'herbivore';
      const isSleeping     = prey.sleeping;
      const isWeakCarnivore = prey.dna.type === 'carnivore'
                              && prey.energy < 30 && prey.age < c.age * 0.5;
      const isVulnOmnivore = prey.dna.type === 'omnivore'
                              && (prey.sleeping || prey.matingWith !== null || prey.energy < 30);
      const edible = isPurple || isHerbivore || (isSleeping && prey !== c) || isWeakCarnivore || isVulnOmnivore;
      if (edible && dist(c, prey) < c.dna.size + prey.dna.size) {
        c.energy += prey.energy * 0.6;
        if (prey.matingWith) { prey.matingWith.matingWith = null; prey.matingWith.matingTicks = 0; }
        // Wake nearby sleepers if this prey was asleep
        if (prey.sleeping) {
          for (const neighbour of creatures) {
            if (neighbour !== prey && neighbour.sleeping && dist(neighbour, prey) < neighbour.dna.sense) {
              neighbour.sleeping = false;
              neighbour.sleepTicks = 0;
              neighbour.sleepCooldown = 400 + Math.floor(Math.random() * 300);
              // Scatter in random direction at high speed
              const ang = Math.random() * Math.PI * 2;
              neighbour.vx = Math.cos(ang) * neighbour.dna.speed * 2;
              neighbour.vy = Math.sin(ang) * neighbour.dna.speed * 2;
              neighbour.wakeScatter = 60;
            }
          }
        }
        // Record successful hunt in memory
        const pKey = prey.dna.type + (prey.sleeping ? '_sleep' : prey.matingWith ? '_mating' : '');
        c.memHuntWins[pKey]    = (c.memHuntWins[pKey]    || 0) + 1;
        c.memHuntAttempts[pKey]= (c.memHuntAttempts[pKey]|| 0) + 1;
        prey.alive = false;
        ate = true;
        break;
      }
    }
    // Also scavenge nearby corpses
    if (!ate) {
      for (let i = corpses.length - 1; i >= 0; i--) {
        if (dist(c, corpses[i]) < c.dna.size + 5) {
          c.energy += corpses[i].energy;
          corpses.splice(i, 1);
          break;
        }
      }
    }
  }

  // Initiate mating â€” requires 80%+ energy, under retirement limit, not sleeping
  if (mateElig && !c.sleeping && c.wakeScatter === 0) {
    const lists = window._simLists || {};
    const sameType = (c.dna.type === 'herbivore' ? lists.herbs
                    : c.dna.type === 'carnivore' ? lists.carns
                    : lists.omnis) || [];
    for (const other of sameType) {
      if (other === c || other.matingWith || other.matingCooldown > 0) continue;
      const otherMax = other.dna.type === 'herbivore' ? 3 : 5;
      if (other.mateCount >= otherMax || other.energy < MATE_ENERGY) continue;
      if (dist(c, other) < c.dna.size + other.dna.size + 5) {
        c.matingWith = other; c.matingTicks = 0;
        other.matingWith = c; other.matingTicks = 0;
        break;
      }
    }
  }

  c.energy = Math.min(c.energy, 300);
}

function updateSim() {
  tick++;

  // â”€â”€ Seasons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  seasonTick++;
  if (seasonTick >= SEASON_LENGTH) {
    seasonTick = 0;
    currentSeasonIdx = (currentSeasonIdx + 1) % 4;
    const ns = SEASONS[currentSeasonIdx];
    const seasonDescs = {
      SPRING: 'Food blooms. Population surges incoming.',
      SUMMER: 'Balanced conditions. The ecosystem breathes.',
      AUTUMN: 'Food slows. Prepare for harder times.',
      WINTER: 'Scarce food. High drain. Only the strong endure.',
    };
    showWeatherBanner(ns.emoji + ' ' + ns.name, ns.color, 180, seasonDescs[ns.name]);
  }

  // â”€â”€ Weather events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (activeWeather) {
    activeWeather.ticksLeft--;
    if (activeWeather.ticksLeft <= 0) {
      const endedName = activeWeather.event.name;
      activeWeather = null;
      weatherCooldown = 600 + Math.floor(Math.random() * 800);
      showWeatherBanner('EVENT ENDED', '#8899bb', 80, endedName + ' HAS PASSED');
    }
  } else {
    if (weatherCooldown > 0) { weatherCooldown--; }
    else {
      // Only trigger certain events in matching seasons
      const ev = WEATHER_EVENTS[Math.floor(Math.random() * WEATHER_EVENTS.length)];
      // Blizzard only in winter/autumn, drought only in summer/autumn
      const s = SEASONS[currentSeasonIdx].name;
      const valid = (ev.name === 'BLIZZARD' && (s === 'WINTER' || s === 'AUTUMN'))
                 || (ev.name === 'DROUGHT'  && (s === 'SUMMER' || s === 'AUTUMN'))
                 || (ev.name === 'FEEDING FRENZY' && (s === 'SPRING' || s === 'SUMMER'))
                 || (ev.name === 'PLAGUE WIND');
      if (valid) {
        activeWeather = { event: ev, ticksLeft: ev.duration };
        showWeatherBanner(ev.emoji + ' ' + ev.name, ev.color, ev.duration, ev.desc);
      } else {
        weatherCooldown = 200; // retry soon
      }
    }
  }

  // Effective multipliers = season * weather (if active)
  const season = getCurrentSeason();
  const weatherFoodMult = activeWeather ? activeWeather.event.foodMult : 1.0;
  const weatherMetaMult = activeWeather ? activeWeather.event.metaMult : 1.0;
  const effectiveFoodMult = season.foodMult * weatherFoodMult;
  const effectiveMetaMult = season.metaMult * weatherMetaMult;
  // Store on window so creature update can access
  window._seasonMetaMult = effectiveMetaMult;

  // Food grows by spreading from existing food â€” no random teleport spawning
  if (foods.length < params.maxFood && foods.length > 0) {
    // Each tick, each food pellet has a small chance to sprout a neighbour nearby
    const growthChance = params.foodRate * 0.0003 * effectiveFoodMult; // slider controls spread speed
    for (let i = 0; i < foods.length && foods.length < params.maxFood; i++) {
      if (Math.random() < growthChance) {
        const parent = foods[i];
        // Spread radius: closer neighbours more likely, max 60px
        const angle = Math.random() * Math.PI * 2;
        const r = 10 + Math.random() * 50;
        const nx = parent.x + Math.cos(angle) * r;
        const ny = parent.y + Math.sin(angle) * r;
        // Only sprout if within canvas bounds
        if (nx > 0 && nx < canvas.width && ny > 0 && ny < canvas.height) {
          foods.push(createFood(nx, ny));
        }
      }
    }
  }

  // Seeds disperse food based on foodRate, then expire
  for (let i = seeds.length - 1; i >= 0; i--) {
    const s = seeds[i];
    s.age++;
    if (foods.length < params.maxFood) {
      // Use the same growth chance as normal food spread, but slightly boosted
      const seedChance = params.foodRate * 0.0005 * effectiveFoodMult;
      if (Math.random() < seedChance) {
        const angle = Math.random() * Math.PI * 2;
        const r = 8 + Math.random() * 60;
        const nx = s.x + Math.cos(angle) * r;
        const ny = s.y + Math.sin(angle) * r;
        if (nx > 0 && nx < canvas.width && ny > 0 && ny < canvas.height) {
          foods.push(createFood(nx, ny));
          s.spawned++;
        }
      }
    }
    if (s.spawned >= s.budget) seeds.splice(i, 1);
  }

  // Deposit pheromones â€” alive, non-sleeping agents leave scent trails
  if (pheroHerb && pheroCarn) {
    for (const c of creatures) {
      if (!c.alive || c.sleeping) continue;
      if (c.dna.type === 'herbivore') depositPhero(pheroHerb, c.x, c.y, 0.18);
      else if (c.dna.type === 'carnivore') depositPhero(pheroCarn, c.x, c.y, 0.18);
      // Omnivores deposit on their own channel â€” distinct cyan, carnivores can still track
      else if (c.dna.type === 'omnivore') depositPhero(pheroOmni, c.x, c.y, 0.18);
    }
    // Diffuse only every 3 ticks â€” evaporation is slow enough that this is imperceptible
    if (tick % 3 === 0) {
      updatePhero(pheroHerb);
      updatePhero(pheroCarn);
      updatePhero(pheroOmni);
    }
    pheroNeedsRedraw = true; // deposits happened, mark dirty
  }

  // Pre-build filtered lists once per tick for performance
  const _alive      = creatures.filter(c => c.alive);
  const _herbs      = _alive.filter(c => c.dna.type === 'herbivore');
  const _carns      = _alive.filter(c => c.dna.type === 'carnivore');
  const _omnis      = _alive.filter(c => c.dna.type === 'omnivore');
  const _mating     = _alive.filter(c => c.matingWith !== null);
  const _sleeping   = _alive.filter(c => c.sleeping);
  window._simLists  = { alive: _alive, herbs: _herbs, carns: _carns, omnis: _omnis, mating: _mating, sleeping: _sleeping };

  rebuildGrids(); // spatial index for O(1) neighbour queries this tick
  for (const c of creatures) updateCreature(c);

  // Decay corpses over time
  for (const corp of corpses) {
    corp.decay++;
    // Fresh corpses keep emitting scent â€” re-deposit each tick, fading with age
    if (corp.decay % 8 === 0 && corp.decay < 300) {
      const strength = (1 - corp.decay / 600) * 0.18;
      if (pheroCarn) depositPhero(pheroCarn, corp.x, corp.y, strength);
      if (pheroOmni) depositPhero(pheroOmni, corp.x, corp.y, strength * 0.7);
    }
  }
  corpses = corpses.filter(corp => corp.decay < 600); // 2Ã— longer life

  creatures = creatures.filter(c => c.alive || (c.age++ < 60));

  // Soft density cap â€” overcrowding raises metabolism rather than killing randomly
  // This creates natural pressure without sudden die-offs
  const hCount = creatures.filter(c => c.alive && c.dna.type === 'herbivore').length;
  const cCount = creatures.filter(c => c.alive && c.dna.type === 'carnivore').length;
  const oCount = creatures.filter(c => c.alive && c.dna.type === 'omnivore').length;
  if (hCount > 150 || cCount > 60 || oCount > 80) {
    for (const c of creatures) {
      if (!c.alive) continue;
      const cnt = c.dna.type === 'herbivore' ? hCount
                : c.dna.type === 'carnivore' ? cCount : oCount;
      const cap = c.dna.type === 'herbivore' ? 150
                : c.dna.type === 'carnivore' ? 60 : 80;
      if (cnt > cap) {
        const overRatio = Math.min(1, (cnt - cap) / cap);
        c.energy -= 0.03 * overRatio; // flat density penalty // extra pressure proportional to overcrowding
      }
    }
  }
  // Hard failsafe â€” only kicks in at extreme numbers to prevent memory issues
  if (creatures.filter(c => c.alive).length > 600)
    creatures = creatures.filter(c => !c.alive || Math.random() > 0.05);

  if (tick % 300 === 0) updateSpeciesCentroids();

  if (tick % 60 === 0) {
    const alive = creatures.filter(c => c.alive);
    history.h.push(alive.filter(c => c.dna.type === 'herbivore').length);
    history.c.push(alive.filter(c => c.dna.type === 'carnivore').length);
    history.o.push(alive.filter(c => c.dna.type === 'omnivore').length);
    history.f.push(foods.length);
    if (history.h.length > MAX_HISTORY) { history.h.shift(); history.c.shift(); history.o.shift(); history.f.shift(); }
  }
}

// â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Draw a polygon or circle at cx,cy with radius r
// sides=0 â†’ circle, sides=4 â†’ diamond, sides=N â†’ regular polygon
function drawShape(ctx2, cx, cy, r, sides) {
  ctx2.beginPath();
  if (sides === 0) {
    ctx2.arc(cx, cy, r, 0, Math.PI * 2);
  } else if (sides === 4) {
    // Diamond (pointed top/bottom)
    ctx2.moveTo(cx,     cy - r * 1.3);
    ctx2.lineTo(cx + r, cy);
    ctx2.lineTo(cx,     cy + r * 1.3);
    ctx2.lineTo(cx - r, cy);
    ctx2.closePath();
  } else {
    // Regular polygon (hexagon=6, triangle=3, pentagon=5 etc.)
    for (let i = 0; i < sides; i++) {
      const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
      const px = cx + Math.cos(angle) * r;
      const py = cy + Math.sin(angle) * r;
      i === 0 ? ctx2.moveTo(px, py) : ctx2.lineTo(px, py);
    }
    ctx2.closePath();
  }
}

function drawCreature(c) {
  const alive = c.alive;
  const alpha = alive ? 1.0 : Math.max(0, 1 - (c.age - 3940) / 60);
  if (alpha <= 0) return;
  // Viewport culling: skip expensive drawing for off-screen creatures
  const cullR = c.dna.size * 4 + 12; // generous margin for glow/ring
  if (c.x + cullR < 0 || c.x - cullR > canvas.width ||
      c.y + cullR < 0 || c.y - cullR > canvas.height) return;

  const isH      = c.dna.type === 'herbivore';
  const isO      = c.dna.type === 'omnivore';
  const isMating = alive && c.matingWith !== null;
  const r        = c.dna.size;

  // Energy-based brightness/saturation: 20% min -> 100% at full energy
  const ePct = alive ? Math.max(0, Math.min(1, c.energy / 300)) : 0;
  const sat  = Math.round(30 + ePct * 70);  // 30%â€“100% saturation
  const lit  = Math.round(20 + ePct * 45);  // 20%â€“65% lightness

  // Base hue per type: mating=267(purple), herbivore=168(teal), carnivore=348(red)
  const isSleepingDraw = alive && c.sleeping;
  const hue = isMating ? 267 : isSleepingDraw ? 220 : (isH ? 168 : isO ? 205 : 348);
  // glowRGB per type for rgba() calls
  const typeGlowRGB = isH ? '0,245,196' : isO ? '0,170,180' : '255,77,109';
  const baseColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#2a2a3a';
  const glowColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#444';
  // Extract approximate RGB for rgba() glow uses
  const glowRGB    = alive ? (isMating ? '162,155,254' : typeGlowRGB) : '68,68,68';
  const trailColor = isMating ? `hsla(267,${sat}%,${lit}%,0.2)` : `hsla(${hue},${sat}%,${lit}%,0.15)`;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Trail â€” skip when creature is near (but not quite at) the viewport edge
  const nearViewport = c.x > -40 && c.x < canvas.width+40 && c.y > -40 && c.y < canvas.height+40;
  if (alive && c.trail.length > 1 && nearViewport) {
    ctx.strokeStyle = trailColor;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(c.trail[0].x, c.trail[0].y);
    for (let i = 1; i < c.trail.length; i++) {
      const a = c.trail[i - 1];
      const b = c.trail[i];
      if (Math.abs(b.x - a.x) > canvas.width / 2 || Math.abs(b.y - a.y) > canvas.height / 2) {
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
      } else {
        ctx.lineTo(b.x, b.y);
      }
    }
    ctx.stroke();
  }

  // Vision indicator (selected only)
  if (c === selectedCreature && alive) {
    const heading = Math.atan2(c.vy, c.vx);
    ctx.setLineDash([3, 5]);
    if (isH) {
      // Own sense circle â€” always shown at agent's actual range
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.15)`; ctx.lineWidth = 1; ctx.stroke();
      // Shepherd-boosted vision â€” outer ring in omnivore cyan, dashed, translucent
      if (c._shepherdVision) {
        ctx.setLineDash([5, 7]);
        ctx.beginPath(); ctx.arc(c.x, c.y, c._shepherdVision, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0,220,255,0.22)`;
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([3, 5]); // restore for rest of vision block
      }
    } else if (isO) {
      // Omnivore: cone + circle (dual)
      const coneRange = c.dna.sense * 1.8;
      ctx.beginPath(); ctx.moveTo(c.x, c.y);
      ctx.arc(c.x, c.y, coneRange, heading - Math.PI/3, heading + Math.PI/3);
      ctx.closePath();
      ctx.strokeStyle = `rgba(${glowRGB},0.12)`; ctx.fillStyle = `rgba(${glowRGB},0.04)`;
      ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense * 0.6, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.08)`; ctx.setLineDash([2,6]); ctx.stroke();
    } else {
      // Carnivore: cone only
      const coneRange = c.dna.sense * 1.8;
      ctx.beginPath(); ctx.moveTo(c.x, c.y);
      ctx.arc(c.x, c.y, coneRange, heading - Math.PI/3, heading + Math.PI/3);
      ctx.closePath();
      ctx.strokeStyle = `rgba(${glowRGB},0.12)`; ctx.fillStyle = `rgba(${glowRGB},0.04)`;
      ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
      ctx.setLineDash([2,6]);
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense * 0.4, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.07)`; ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  // Sleep indicator: zzz rings when asleep
  if (alive && c.sleeping) {
    ctx.save();
    ctx.globalAlpha = (alpha * 0.6);
    // Pulsing outer ring in dim blue-grey
    const pulse = 0.5 + 0.5 * Math.sin(tick * 0.08);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + pulse * 4, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(120,140,200,${0.4 + pulse * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([3, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
    // Tiny 'z' indicators floating upward
    for (let z = 0; z < 3; z++) {
      const zAge = (tick + z * 30) % 90;
      const zAlpha = zAge < 45 ? zAge / 45 : (90 - zAge) / 45;
      const zY = c.y - r - 6 - zAge * 0.25;
      const zX = c.x + r + 2 + z * 4;
      ctx.globalAlpha = alpha * zAlpha * 0.7;
      ctx.fillStyle = 'rgba(160,180,240,1)';
      ctx.font = `${7 + z}px monospace`;
      ctx.fillText('z', zX, zY);
    }
    ctx.restore();
  }

  // Mating pulse ring + progress arc
  if (isMating) {
    const progress = c.matingTicks / MATING_DURATION;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + Math.sin(tick * 0.25) * 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(162,155,254,${0.25 + progress * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 9, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
    ctx.strokeStyle = 'rgba(162,155,254,0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Outer glow â€” dimmed for sated omnivores so shepherd ring reads clearly
  if (alive) {
    const glowA = (isO && c.energy >= 270) ? 0.12 : 0.3;
    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r * 3);
    g.addColorStop(0, `rgba(${glowRGB},${glowA})`);
    g.addColorStop(1, `rgba(${glowRGB},0)`);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r * 3, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
  }

  // Body â€” shape determined by species (colour stays type-based)
  const sp = c.speciesId ? speciesRegistry[c.speciesId] : null;
  const bodyShape = sp ? sp.shape : (isH ? 6 : isO ? 0 : 4);
  ctx.beginPath();
  drawShape(ctx, c.x, c.y, r, bodyShape);

  if (alive) {
    ctx.fillStyle = baseColor;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = isMating ? 14 : 8;
    ctx.fill();
    ctx.shadowBlur = 0;
  } else {
    ctx.fillStyle = '#1a1a2a';
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }


  // Shepherding indicator ring (omnivore, sated) â€” drawn AFTER body so it's separate from icon
  if (alive && isO && c.energy >= 270) {
    ctx.save();
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    // Main transparency knob for the ring (independent of the icon)
    ctx.globalAlpha = alpha * 0.18;

    const rr = r * 7.0 + Math.sin(tick * 0.05) * 2;
    ctx.setLineDash([5, 8]);
    ctx.lineCap = 'round';

    // Dark under-stroke to visually separate it from glow/background
    ctx.beginPath();
    ctx.arc(c.x, c.y, rr, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,0,0,0.75)';
    ctx.lineWidth = 2.6;
    ctx.stroke();

    // Cyan ring on top
    ctx.beginPath();
    ctx.arc(c.x, c.y, rr, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,220,255,1)';
    ctx.lineWidth = 1.1;
    ctx.stroke();

    ctx.setLineDash([]);
    ctx.restore();
  }

  // (duplicate shepherd ring removed)

  // Direction nub + sprint streak
  if (alive) {
    const angle = Math.atan2(c.vy, c.vx);
    if (c.sprinting) {
      // Orange motion streak behind the carnivore
      ctx.beginPath();
      ctx.moveTo(c.x, c.y);
      ctx.lineTo(c.x - Math.cos(angle) * r * 4, c.y - Math.sin(angle) * r * 4);
      ctx.strokeStyle = `rgba(255,160,50,${0.3 + (c.dna.stamina ?? 1.0) * 0.4})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x + Math.cos(angle) * r * 1.8, c.y + Math.sin(angle) * r * 1.8);
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Energy bar
  if (alive) {
    const bw = r * 2.5, bh = 2;
    const bx = c.x - bw/2, by = c.y + r + 3;
    const pct = Math.min(1, c.energy / 300);
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = isMating ? '#a29bfe'
                  : pct > 0.5 ? '#00f5c4'
                  : pct > 0.25 ? '#ffd166' : '#ff4d6d';
    ctx.fillRect(bx, by, bw * pct, bh);
  }

  // Status icons â€” floating above creature
  if (alive) {
    const iconY = c.y - r - 10;
    ctx.shadowBlur = 0;
    ctx.font = `${Math.max(8, r * 0.9)}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    const ePct = c.energy / 300;
    if (ePct < 0.20 && !c.sleeping && !isMating) {
      // Skull warning for critically low energy
      const pulse2 = 0.5 + 0.5 * Math.sin(tick * 0.2);
      ctx.globalAlpha = alpha * (0.7 + pulse2 * 0.3);
      ctx.fillStyle = '#ff4d6d';
      ctx.fillText('ğŸ’€', c.x, iconY);
    } else if (c.sprinting) {
      ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = '#ffa032';
      ctx.fillText('âš¡', c.x, iconY);
    } else if (c.status === 'SEEKING MATE' || c.status === 'SATED â€” WANDERING') {
      ctx.globalAlpha = alpha * 0.75;
      ctx.fillText('â¤ï¸', c.x, iconY);
    }
  }

  // Selected species highlight ring
  if (alive && selectedSpeciesId && c.speciesId === selectedSpeciesId) {
    const pulse3 = 0.5 + 0.5 * Math.sin(tick * 0.15);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 6 + pulse3 * 4, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,209,102,${0.55 + pulse3 * 0.35})`;
    ctx.lineWidth = 2;
    ctx.shadowColor = 'rgba(255,209,102,0.8)';
    ctx.shadowBlur = 8;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  ctx.restore();
}

function drawSeed(s) {
  const progress = Math.min(1, s.spawned / s.budget);
  const alpha = 1 - progress * 0.5; // fades as it exhausts
  const pulse = 0.7 + 0.3 * Math.sin(tick * 0.04 + s.x);
  ctx.save();
  ctx.globalAlpha = alpha;
  // Outer glow ring
  ctx.beginPath();
  ctx.arc(s.x, s.y, 7 * pulse, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(40,160,50,0.45)`;
  ctx.lineWidth = 1.5;
  ctx.setLineDash([3, 4]);
  ctx.stroke();
  ctx.setLineDash([]);
  // Core
  ctx.beginPath();
  ctx.arc(s.x, s.y, 3.5, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(120,60%,${28 - progress*10}%)`; // dark green
  ctx.shadowColor = '#2d8a30';
  ctx.shadowBlur = 8;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Small progress tick marks around ring (how much budget remains)
  const ticks = 8;
  for (let i = 0; i < ticks; i++) {
    const filled = i / ticks < (1 - progress);
    if (!filled) continue;
    const a = (i / ticks) * Math.PI * 2 - Math.PI / 2;
    ctx.beginPath();
    ctx.moveTo(s.x + Math.cos(a)*5, s.y + Math.sin(a)*5);
    ctx.lineTo(s.x + Math.cos(a)*7, s.y + Math.sin(a)*7);
    ctx.strokeStyle = `rgba(60,200,70,0.7)`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  ctx.restore();
}

function drawFood(f) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#ffd166';
  ctx.shadowColor = '#ffd166';
  ctx.shadowBlur = 6;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawCorpse(corp) {
  const age = corp.decay / 600; // 0=fresh, 1=gone â€” matches 600-tick lifetime
  const alpha = 1 - age * 0.8;
  const r = 3 + (1 - age) * 2;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.arc(corp.x, corp.y, r, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(30,${Math.round(40 - age*30)}%,${Math.round(18 + age*8)}%)`;
  ctx.shadowColor = 'rgba(80,40,0,0.3)';
  ctx.shadowBlur = 4;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Small X to distinguish from food
  ctx.strokeStyle = `rgba(100,60,20,${0.5 * alpha})`;
  ctx.lineWidth = 0.7;
  ctx.beginPath(); ctx.moveTo(corp.x - r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x + r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(corp.x + r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x - r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.restore();
}

function drawChart() {
  const w = chartCanvas.width, h = chartCanvas.height;
  chartCtx.clearRect(0, 0, w, h);
  chartCtx.fillStyle = '#060810';
  chartCtx.fillRect(0, 0, w, h);

  // Season background tint
  const s = getCurrentSeason();
  chartCtx.fillStyle = s.barColor + '0a'; // 4% opacity tint
  chartCtx.fillRect(0, 0, w, h);

  const all = [...history.h, ...history.c, ...history.o, ...history.f];
  const maxVal = Math.max(...all, 1);
  if (history.h.length < 2) return;

  const line = (data, color) => {
    chartCtx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = (i / (MAX_HISTORY - 1)) * w;
      const y = h - (data[i] / maxVal) * h * 0.9 - 2;
      i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
    }
    chartCtx.strokeStyle = color;
    chartCtx.lineWidth = 1.5;
    chartCtx.stroke();
  };
  line(history.h, '#00f5c4');
  line(history.c, '#ff4d6d');
  line(history.o, '#2bbcff');
  line(history.f, '#ffd166');
}

function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(6,8,16,0.85)';
  ctx.fillRect(0, 0, W, H);

  // Seasonal ambient overlay
  const seasonTints = {
    SPRING: 'rgba(0,245,196,0.025)',
    SUMMER: 'rgba(255,209,102,0.02)',
    AUTUMN: 'rgba(255,120,50,0.03)',
    WINTER: 'rgba(100,140,255,0.04)',
  };
  const st = seasonTints[getCurrentSeason().name];
  if (st) { ctx.fillStyle = st; ctx.fillRect(0, 0, W, H); }

  // Active weather overlay
  if (activeWeather) {
    const wTints = {
      'DROUGHT':        'rgba(255,100,30,0.04)',
      'PLAGUE WIND':    'rgba(180,80,240,0.03)',
      'FEEDING FRENZY': 'rgba(0,245,196,0.05)',
      'BLIZZARD':       'rgba(150,200,255,0.06)',
    };
    const wt = wTints[activeWeather.event.name];
    if (wt) { ctx.fillStyle = wt; ctx.fillRect(0, 0, W, H); }
  }

  // Pheromone render â€” update offscreen canvas when dirty, then blit in one drawImage call
  if (pheroHerb && pheroCarn && params.showPhero) {
    if (pheroNeedsRedraw && tick % 5 === 0 && pheroCtx2) {
      pheroCtx2.clearRect(0, 0, pheroCanvas.width, pheroCanvas.height);
      for (let gy = 0; gy < pheroH; gy++) {
        for (let gx = 0; gx < pheroW; gx++) {
          const hi = pheroHerb[pheroIdx(gx, gy)];
          const ci = pheroCarn[pheroIdx(gx, gy)];
          const oi = pheroOmni ? pheroOmni[pheroIdx(gx, gy)] : 0;
          const px = gx * PHERO_CELL, py = gy * PHERO_CELL;
          if (hi > 0.03) {
            pheroCtx2.fillStyle = `rgba(0,245,196,${Math.min(1,hi*0.25).toFixed(3)})`;
            pheroCtx2.fillRect(px, py, PHERO_CELL, PHERO_CELL);
          }
          if (oi > 0.03) {
            pheroCtx2.fillStyle = `rgba(0,210,255,${Math.min(1,oi*0.28).toFixed(3)})`;
            pheroCtx2.fillRect(px, py, PHERO_CELL, PHERO_CELL);
          }
          if (ci > 0.03) {
            pheroCtx2.fillStyle = `rgba(255,77,109,${Math.min(1,ci*0.22).toFixed(3)})`;
            pheroCtx2.fillRect(px, py, PHERO_CELL, PHERO_CELL);
          }
        }
      }
      pheroNeedsRedraw = false;
    }
    // Single drawImage blit â€” far cheaper than per-cell fillRect every frame
    if (pheroCanvas) ctx.drawImage(pheroCanvas, 0, 0);
  }

  if (selectedCreature && selectedCreature.alive) {
    ctx.beginPath();
    ctx.arc(selectedCreature.x, selectedCreature.y, selectedCreature.dna.size + 10, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  for (const corp of corpses) drawCorpse(corp);
  for (const s of seeds) drawSeed(s);
  for (const f of foods) drawFood(f);
  for (const c of creatures) drawCreature(c);
}

// â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateUI() {
  const alive = creatures.filter(c => c.alive);
  document.getElementById('hPop').textContent   = alive.filter(c => c.dna.type === 'herbivore').length;
  document.getElementById('cPop').textContent   = alive.filter(c => c.dna.type === 'carnivore').length;
  const oPop = document.getElementById('oPop'); if (oPop) oPop.textContent = alive.filter(c => c.dna.type === 'omnivore').length;
  document.getElementById('fPop').textContent   = foods.length;
  const sPop2 = document.getElementById('sPop'); if (sPop2) sPop2.textContent = seeds.length;
  document.getElementById('genNum').textContent  = generation;

  // Species panel â€” only rebuild DOM when membership actually changes (not every frame)
  const speciesEntries = Object.values(speciesRegistry);
  const sc = document.getElementById('speciesCount');
  if (sc) sc.textContent = `(${speciesEntries.length})`;
  const spCounts = {};
  for (const c of creatures) { if (c.alive && c.speciesId) spCounts[c.speciesId] = (spCounts[c.speciesId]||0)+1; }
  const newFingerprint = speciesEntries
    .filter(sp => (spCounts[sp.id]||0) > 0)
    .map(sp => sp.id + ':' + (spCounts[sp.id]||0))
    .join('|');
  const grid = document.getElementById('speciesGrid');
  if (grid && newFingerprint !== grid.dataset.fp) {
    // If selected species went extinct, clear it
    if (selectedSpeciesId && !(selectedSpeciesId in spCounts)) selectedSpeciesId = null;
    grid.dataset.fp = newFingerprint;
    grid.innerHTML = '';
    for (const sp of speciesEntries) {
      const cnt = spCounts[sp.id] || 0;
      if (cnt === 0) continue;
      const cell = document.createElement('div');
      cell.className = 'species-cell';
      cell.title = `Click to highlight species | Shift+click to spawn (${sp.type}, ${sp.id.slice(3,8)})`;
      // Use data attribute + global handler â€” avoids closure/DOM timing issues
      cell.dataset.sid = sp.id;
      // No per-cell listener â€” handled by delegation on #speciesGrid
      // Mini canvas icon
      const mc = document.createElement('canvas');
      mc.width = 24; mc.height = 24;
      const mctx = mc.getContext('2d');
      const col = sp.type === 'herbivore' ? '#00f5c4'
                : sp.type === 'omnivore'  ? '#2bbcff' : '#ff4d6d';
      mctx.strokeStyle = col;
      mctx.fillStyle   = col + '55';
      mctx.lineWidth   = 1.5;
      drawShape(mctx, 12, 12, 8, sp.shape);
      mctx.fill();
      mctx.stroke();
      cell.appendChild(mc);
      const lbl = document.createElement('div');
      lbl.textContent = cnt;
      cell.appendChild(lbl);
      // Re-apply highlight if this was the selected species
      if (selectedSpeciesId === sp.id) cell.classList.add('selected-species');
      grid.appendChild(cell);
    }
  }
  document.getElementById('tickNum').textContent = tick;

  // Season display
  const seasonEl = document.getElementById('seasonDisplay');
  if (seasonEl) {
    const s = getCurrentSeason();
    seasonEl.textContent = s.emoji + ' ' + s.name;
    seasonEl.style.color = s.color;
    seasonEl.style.fontSize = '10px';
    seasonEl.style.letterSpacing = '1px';
  }
  // Season bar
  const barFill = document.getElementById('seasonBarFill');
  if (barFill) {
    const pct = (seasonTick / SEASON_LENGTH) * 100;
    barFill.style.width = pct + '%';
    barFill.style.background = getCurrentSeason().barColor;
    barFill.style.boxShadow = `0 0 6px ${getCurrentSeason().barColor}88`;
  }

  if (selectedCreature) {
    const c = selectedCreature, d = c.dna;
    const info = document.getElementById('infoBox');
    if (!c.alive) {
      info.innerHTML = '<b>DECEASED</b><br>Age: ' + c.age;
    } else {
      const energyPct = Math.round((c.energy / 300) * 100);
      const isSated = c.energy >= 270;
      const mateMax  = c.dna.type === 'herbivore' ? 3 : 5;
      const maxedOut = c.mateCount >= mateMax;
      const stateTag = c.sleeping
        ? `<br><b style="color:#a0b4f0">ğŸ’¤ SLEEPING (${c.sleepTicks} ticks)</b>`
        : c.matingWith
          ? `<br><b style="color:#a29bfe">â— MATING ${Math.round((c.matingTicks/MATING_DURATION)*100)}%</b>`
          : isSated && !maxedOut
            ? `<br><b style="color:#ffd166">â—ˆ SATED â€” seeking mate</b>`
            : isSated && maxedOut
              ? `<br><b style="color:#ffd166">â—ˆ SATED â€” retired</b>`
              : maxedOut
                ? `<br><b style="color:#636e72">âœ• RETIRED â€” 3/3 matings</b>`
                : c.matingCooldown > 0
                  ? `<br><b style="color:#636e72">â—Œ COOLDOWN ${c.matingCooldown}</b>`
                  : '';
      const staminaBar = (d.type === 'carnivore' || d.type === 'omnivore')
        ? `<br><b>STAMINA:</b> <b style="opacity:0.5">gene ${(d.stamina??1).toFixed(2)}</b>${c.sprinting ? ' <b style="color:#ffa032">âš¡ SPRINTING</b>' : ''}`
        : '';
      // Predator intelligence summary
      let huntMemHTML = '';
      if (d.type === 'carnivore') {
        const entries = Object.entries(c.memHuntAttempts || {})
          .filter(([k,v]) => v >= 3)
          .map(([k,v]) => {
            const wins = (c.memHuntWins || {})[k] || 0;
            return `${k.split('_')[0][0].toUpperCase()}:${Math.round(wins/v*100)}%`;
          });
        if (entries.length) huntMemHTML = `<br><b style="opacity:0.5">HUNT MEM: ${entries.join(' ')}</b>`;
      }
      info.innerHTML = `
        <b>TYPE:</b> ${d.type.toUpperCase()}<br>
        <b>STATUS:</b> <b style="color:var(--accent)">${c.status || 'â€”'}</b><br>
        <b>ENERGY:</b> ${Math.round(c.energy)} <b style="opacity:0.5">(${energyPct}%)</b><br>
        <b>AGE:</b> ${c.age}<br>
        <b>GEN:</b> ${c.gen}<br>
        <b>MATINGS:</b> ${c.mateCount}/${mateMax}${maxedOut ? ' <b style="color:var(--accent2)">RETIRED</b>' : ''}<br>
        <br>
        <b>â€” GENOME â€”</b><br>
        <b>SPEED:</b> ${d.speed.toFixed(2)}<br>
        <b>SENSE:</b> ${Math.round(d.sense)}${d.type==='carnivore' ? ' <b style="opacity:0.4">(cone)</b>' : ''}<br>
        <b>SIZE:</b> ${d.size.toFixed(2)}<br>
        <b>FERTILITY:</b> ${(d.fertility*1000).toFixed(2)}â€°<br>
        <b>METABOLISM:</b> ${d.metabolism.toFixed(3)}<br>
        <b>AGGRESSION:</b> ${d.aggression.toFixed(2)}${staminaBar}<br>
        <b>SPECIES:</b> <b style="opacity:0.5">${c.speciesId ? c.speciesId.slice(3,8) : '?'}</b>${huntMemHTML}${stateTag}
      `;
    }
  }
}

// â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastFPSTime = performance.now(), frames = 0;

function loop() {
  const now = performance.now();
  frames++;
  if (now - lastFPSTime > 1000) {
    document.getElementById('fpsDisplay').textContent = frames + ' FPS';
    frames = 0; lastFPSTime = now;
  }
  if (playing) {
    if (speed >= 1) {
      const iters = Math.round(speed);
      for (let i = 0; i < iters; i++) updateSim();
    } else {
      // Slow motion: accumulate fractional ticks
      speedFraction += speed;
      if (speedFraction >= 1) {
        speedFraction -= 1;
        updateSim();
      }
    }
  }
  updateUI(); // Always refresh panel so selected creature info stays live
  render();
  drawChart();
  requestAnimationFrame(loop);
}

// â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ Speed levels (0=0.25x, 1=0.5x, 2=1x, 3=2x, ... 13=12x) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SPEED_LEVELS = [0.25, 0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
let speedFraction = 0; // sub-tick accumulator for slow-motion

function updateSpeed(el) {
  const idx = parseInt(el.value);
  speed = SPEED_LEVELS[idx] || 1;
  const lbl = speed < 1 ? speed + 'Ã—' : Math.round(speed) + 'Ã—';
  document.getElementById('speedVal').textContent = lbl;
}

// â”€â”€ Weather banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let bannerTimeout = null;
function showWeatherBanner(text, color, durationTicks, subtitle) {
  const el = document.getElementById('weatherBanner');
  const titleEl = document.getElementById('weatherBannerTitle');
  const subEl = document.getElementById('weatherBannerSub');
  if (!el) return;
  if (titleEl) titleEl.textContent = text;
  if (subEl) subEl.textContent = subtitle || '';
  el.style.borderColor = color;
  el.style.color = color;
  el.style.textShadow = `0 0 12px ${color}88`;
  el.classList.add('visible');
  if (bannerTimeout) clearTimeout(bannerTimeout);
  bannerTimeout = setTimeout(() => { el.classList.remove('visible'); }, 4500);
}

function togglePlay() {
  playing = !playing;
  const btn = document.getElementById('playBtn');
  btn.textContent = playing ? 'â¸ PAUSE' : 'â–¶ PLAY';
  btn.classList.toggle('active', playing);
}

function updateParam(key, el) {
  params[key] = parseInt(el.value);
  document.getElementById(key + 'Val').textContent = params[key] + (key === 'mutRate' ? '%' : '');
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  let clicked = null;
  // Generous hit radius so small creatures are easy to click
  for (const c of creatures) {
    if (c.alive && dist(c, { x: mx, y: my }) < Math.max(c.dna.size + 12, 18)) { clicked = c; break; }
  }
  if (clicked) {
    selectedCreature = clicked;
    updateUI(); // Refresh panel immediately, even when paused
  } else {
    selectedCreature = null; // Just deselect â€” no food placement on empty click
  }
});

function resize() {
  const panel  = document.querySelector('.panel');
  const header = document.querySelector('header');
  const footer = document.querySelector('footer');
  canvas.width        = window.innerWidth - panel.offsetWidth;
  canvas.height       = window.innerHeight - header.offsetHeight - footer.offsetHeight;
  chartCanvas.width   = panel.offsetWidth - 24;
  chartCanvas.height  = 60;
  initPhero();
}

window.addEventListener('resize', resize);
resize();
resetSim();
loop();

// â”€â”€ Species grid event delegation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Using delegation on the parent so clicks always register even after innerHTML rebuild
document.getElementById('speciesGrid').addEventListener('click', function(e) {
  const cell = e.target.closest('.species-cell');
  if (!cell) return;
  const sid = cell.dataset.sid;
  if (!sid) return;
  if (e.shiftKey) { spawnFromSpecies(sid); return; }
  if (selectedSpeciesId === sid) {
    selectedSpeciesId = null;
  } else {
    selectedSpeciesId = sid;
  }
  // Visual highlight update
  document.querySelectorAll('.species-cell').forEach(c2 => {
    c2.classList.toggle('selected-species', c2.dataset.sid === selectedSpeciesId);
  });
});

function toggleLegend() {
  const body = document.getElementById('legendBody');
  const btn  = document.getElementById('legendToggle');
  const collapsed = body.style.display === 'none';
  body.style.display = collapsed ? '' : 'none';
  btn.textContent = collapsed ? 'â–¼' : 'â–¶';
  btn.classList.toggle('collapsed', !collapsed);
}

function togglePhero() {
  params.showPhero = !params.showPhero;
  const btn = document.getElementById('pheroBtn');
  btn.textContent = params.showPhero ? 'â— HIDE SCENT TRAILS' : 'â— SHOW SCENT TRAILS';
  btn.classList.toggle('active', params.showPhero);
}

// â”€â”€ Spawn quantity selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentQty = 1;

function spawnAmt() { return currentQty; }

function setQty(n) {
  currentQty = n;
  document.querySelectorAll('.qty-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('qty' + n).classList.add('active');
  // Update button labels
  const plural = s => n === 1 ? '' : 'S';
  document.getElementById('spawnHlbl').textContent = n;
  document.getElementById('spawnClbl').textContent = n;
  document.getElementById('spawnOlbl').textContent = n;
  document.getElementById('spawnSlbl').textContent = n;
  document.getElementById('spawnFlbl').textContent = n;
  document.getElementById('spawnHs').textContent = plural('S');
  document.getElementById('spawnCs').textContent = plural('S');
  document.getElementById('spawnOs').textContent = plural('S');
  document.getElementById('spawnSs').textContent = plural('S');
}
</script>
</body>
</html>
