<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ALIFE â€” Artificial Life Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Syncopate:wght@400;700&display=swap');

  :root {
    --bg: #060810;
    --panel: #0a0e1a;
    --border: #1a2240;
    --accent: #00f5c4;
    --accent2: #ff4d6d;
    --accent3: #ffd166;
    --text: #8899bb;
    --text-bright: #ccd6f6;
    --grid: rgba(0,245,196,0.04);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
  }

  .logo {
    font-family: 'Syncopate', sans-serif;
    font-weight: 700;
    font-size: 18px;
    letter-spacing: 6px;
    color: var(--accent);
    text-shadow: 0 0 20px rgba(0,245,196,0.5);
  }
  .logo span { color: var(--text); font-weight: 400; }

  .header-stats {
    display: flex;
    gap: 24px;
    font-size: 11px;
    letter-spacing: 1px;
  }

  .stat { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .stat-val { color: var(--accent); font-size: 16px; font-weight: bold; }
  .stat-lbl { color: var(--text); opacity: 0.6; font-size: 9px; letter-spacing: 2px; text-transform: uppercase; }

  .by-cal-link {
    display: flex;
    align-items: center;
    gap: 7px;
    text-decoration: none;
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--text);
    opacity: 0.8;
    border: 1px solid var(--border);
    padding: 5px 11px;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .by-cal-link:hover {
    border-color: var(--accent);
    color: var(--accent);
    opacity: 1;
    box-shadow: 0 0 12px rgba(0,245,196,0.15);
  }

  .main { display: flex; flex: 1; overflow: hidden; }

  canvas { flex: 1; display: block; cursor: crosshair; }

  .panel {
    width: 220px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
    flex-shrink: 0;
  }
  .panel::-webkit-scrollbar { width: 3px; }
  .panel::-webkit-scrollbar-track { background: transparent; }
  .panel::-webkit-scrollbar-thumb { background: rgba(0,245,196,0.2); border-radius: 2px; }
  .panel::-webkit-scrollbar-thumb:hover { background: rgba(0,245,196,0.45); }

  .section { border-bottom: 1px solid var(--border); padding: 12px; }

  .section-title {
    font-family: 'Syncopate', sans-serif;
    font-size: 8px;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 10px;
    text-transform: uppercase;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 10px;
  }
  .control-label { color: var(--text); letter-spacing: 1px; }

  input[type=range] {
    -webkit-appearance: none;
    width: 90px; height: 2px;
    background: var(--border);
    outline: none; border-radius: 2px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(0,245,196,0.6);
  }

  .val-display { color: var(--accent); font-size: 10px; min-width: 28px; text-align: right; }

  .btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; letter-spacing: 2px; text-transform: uppercase;
    border: 1px solid var(--border); background: transparent;
    color: var(--text-bright); padding: 7px 10px;
    cursor: pointer; transition: all 0.15s;
    width: 100%; margin-bottom: 6px; text-align: left;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.05); box-shadow: 0 0 10px rgba(0,245,196,0.1); }
  .btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.08); }
  .btn.danger:hover { border-color: var(--accent2); color: var(--accent2); background: rgba(255,77,109,0.05); }

  .legend { display: flex; flex-direction: column; gap: 5px; }
  .legend-item { display: flex; align-items: center; gap: 8px; font-size: 9px; letter-spacing: 1px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

  .mini-chart { width: 100%; height: 60px; border: 1px solid var(--border); margin-top: 8px; overflow: hidden; }
  .mini-chart canvas { width: 100%; height: 100%; }

  .info-box { font-size: 9px; line-height: 1.8; color: var(--text); letter-spacing: 0.5px; }

  /* Collapsible legend */
  .section-title-row {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 10px;
  }
  .section-title-row .section-title { margin-bottom: 0; }
  .collapse-btn {
    background: none; border: none; cursor: pointer;
    color: var(--accent); font-size: 11px; line-height: 1;
    padding: 2px 4px; transition: transform 0.2s;
  }
  .collapse-btn.collapsed { transform: rotate(-90deg); }

  /* Species grid */
  .species-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
    margin-top: 4px;
  }
  .species-cell {
    display: flex; flex-direction: column; align-items: center;
    gap: 2px; font-size: 8px; color: var(--text);
    background: rgba(255,255,255,0.02);
    border: 1px solid var(--border);
    padding: 4px 2px; border-radius: 2px;
    cursor: pointer; transition: border-color 0.15s, background 0.15s;
    user-select: none;
  }
  .species-cell:hover {
    border-color: var(--accent);
    background: rgba(0,245,196,0.07);
  }
  .species-cell:active { background: rgba(0,245,196,0.14); }
  .species-cell canvas { display: block; pointer-events: none; }
  .info-box b { color: var(--accent); font-weight: normal; }

  footer {
    padding: 6px 16px; font-size: 9px; letter-spacing: 2px;
    color: var(--border); border-top: 1px solid var(--border);
    background: var(--panel); display: flex; justify-content: space-between; flex-shrink: 0;
  }

  /* Weather/Season banner */
  #weatherBanner {
    position: fixed; top: 56px; left: 50%; transform: translateX(-50%);
    background: rgba(6,8,16,0.82);
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--accent3);
    color: var(--accent3); font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 3px; text-transform: uppercase;
    padding: 9px 28px 8px; pointer-events: none; z-index: 100;
    opacity: 0; transition: opacity 0.6s;
    text-shadow: 0 0 14px rgba(255,209,102,0.5);
    box-shadow: 0 0 30px rgba(255,209,102,0.1), inset 0 1px 0 rgba(255,255,255,0.04);
    text-align: center; min-width: 260px;
  }
  #weatherBanner.visible { opacity: 1; }
  #weatherBannerSub {
    font-size: 8px; letter-spacing: 2px; opacity: 0.6;
    margin-top: 4px; text-transform: uppercase;
  }

  /* Season progress bar under header */
  #seasonBar {
    position: fixed; top: 54px; left: 0; right: 220px;
    height: 2px; z-index: 99; pointer-events: none;
    background: transparent;
  }
  #seasonBarFill {
    height: 100%; width: 0%;
    transition: background 1s;
  }

  /* Selected species highlight ring */
  .species-cell.selected-species {
    border-color: var(--accent3) !important;
    background: rgba(255,209,102,0.12) !important;
    box-shadow: 0 0 8px rgba(255,209,102,0.3);
  }

  /* Species +/âˆ’ buttons â€” proper classes instead of inline styles */
  .sp-btn-row { display:flex; gap:2px; margin-top:3px; width:100%; }
  .sp-btn {
    flex: 1; font-size: 9px; padding: 2px 0;
    border: 1px solid var(--border); background: transparent;
    cursor: pointer; font-family: 'Share Tech Mono', monospace;
    transition: all 0.12s; line-height: 1;
  }
  .sp-btn.minus { color: rgba(255,77,109,0.65); border-color: rgba(255,77,109,0.25); }
  .sp-btn.minus:hover { color: var(--accent2); border-color: rgba(255,77,109,0.6); background: rgba(255,77,109,0.08); }
  .sp-btn.plus  { color: rgba(0,245,196,0.65); border-color: rgba(0,245,196,0.25); }
  .sp-btn.plus:hover  { color: var(--accent); border-color: rgba(0,245,196,0.6); background: rgba(0,245,196,0.08); }

  /* â”€â”€ Deus Ex Machina panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .deus-section {
    border-bottom: 1px solid var(--border);
    padding: 12px;
    background: rgba(255,77,109,0.03);
  }
  .deus-title {
    font-family: 'Syncopate', sans-serif;
    font-size: 8px; letter-spacing: 3px;
    color: var(--accent2); margin-bottom: 10px;
    text-transform: uppercase;
    text-shadow: 0 0 10px rgba(255,77,109,0.4);
  }
  .deus-subtitle {
    display: flex; align-items: center; gap: 6px;
    font-size: 7px; letter-spacing: 2px; color: var(--text);
    opacity: 0.45; margin-bottom: 7px; margin-top: 10px;
    text-transform: uppercase;
  }
  .deus-subtitle::before,
  .deus-subtitle::after {
    content: ''; flex: 1; height: 1px;
    background: linear-gradient(to right, transparent, var(--border));
  }
  .deus-subtitle::after {
    background: linear-gradient(to left, transparent, var(--border));
  }
  .btn.deus {
    border-color: rgba(255,77,109,0.3);
    color: rgba(255,180,180,0.85);
  }
  .btn.deus:hover {
    border-color: var(--accent2); color: var(--accent2);
    background: rgba(255,77,109,0.07);
    box-shadow: 0 0 10px rgba(255,77,109,0.2);
  }
  .btn.deus.armed {
    border-color: var(--accent2) !important;
    color: var(--accent2) !important;
    background: rgba(255,77,109,0.15) !important;
    box-shadow: 0 0 14px rgba(255,77,109,0.4) !important;
    animation: pulse-red 0.8s ease-in-out infinite alternate;
  }
  .btn.deus.active-event {
    border-color: #c084fc !important;
    color: #c084fc !important;
    background: rgba(192,132,252,0.1) !important;
  }
  @keyframes pulse-red {
    from { box-shadow: 0 0 8px rgba(255,77,109,0.3); }
    to   { box-shadow: 0 0 20px rgba(255,77,109,0.7); }
  }

  /* Mutation nudge rows */
  .mut-row {
    display: flex; align-items: center; gap: 4px;
    margin-bottom: 4px;
  }
  .mut-label {
    font-size: 8px; letter-spacing: 1px; color: var(--text);
    flex: 1; text-transform: uppercase;
  }
  .mut-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; width: 22px; height: 22px;
    border: 1px solid var(--border); background: transparent;
    color: var(--text-bright); cursor: pointer;
    transition: all 0.12s; display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
  }
  .mut-btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.07); }
  .mut-btn.minus:hover { border-color: var(--accent2); color: var(--accent2); background: rgba(255,77,109,0.07); }

  /* Type selector tabs for mutations */
  .type-tabs {
    display: flex; gap: 4px; margin-bottom: 8px;
  }
  .type-tab {
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px; letter-spacing: 1px;
    border: 1px solid var(--border); background: transparent;
    color: var(--text); padding: 4px 6px; cursor: pointer;
    transition: all 0.12s; flex: 1; text-align: center;
    text-transform: uppercase;
  }
  .type-tab.active { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.08); }
  .type-tab.herb.active  { border-color: #00f5c4; color: #00f5c4; background: rgba(0,245,196,0.08); }
  .type-tab.carn.active  { border-color: #ff4d6d; color: #ff4d6d; background: rgba(255,77,109,0.08); }
  .type-tab.omni.active  { border-color: #2bbcff; color: #2bbcff; background: rgba(43,188,255,0.08); }

  /* â”€â”€ Mobile layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media (max-width: 768px) {

    /* Slim the header */
    header {
      padding: 7px 12px;
      gap: 8px;
    }
    .logo { font-size: 13px; letter-spacing: 3px; }
    .by-cal-link { display: none; }
    .header-stats { gap: 10px; }
    .stat-val { font-size: 13px; }
    .stat-lbl { font-size: 7px; letter-spacing: 1px; }
    /* Hide Seeds & Generation & Tick on mobile â€” keep H/C/O/F/Season */
    .stat-hide-mobile { display: none; }

    /* Canvas fills all space, panel hidden */
    .main { position: relative; overflow: hidden; }
    .panel { display: none; }

    /* Hide desktop footer */
    footer { display: none; }

    /* Season bar spans full width on mobile */
    #seasonBar { right: 0; }

    /* Weather banner adjusts for smaller screen */
    #weatherBanner {
      top: auto; bottom: 70px;
      font-size: 9px; letter-spacing: 2px;
      padding: 7px 14px 6px; min-width: 0; width: 85%;
    }
    #weatherBannerSub { font-size: 7px; }

    /* â”€â”€ Bottom tab bar â”€â”€ */
    #mobileTabBar {
      position: fixed; bottom: 0; left: 0; right: 0;
      height: 52px;
      background: rgba(6,8,16,0.96);
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      border-top: 1px solid var(--border);
      display: flex; z-index: 200;
    }
    .mob-tab {
      flex: 1; display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 3px; font-size: 7px; letter-spacing: 1px;
      color: var(--text); text-transform: uppercase;
      background: transparent; border: none; cursor: pointer;
      transition: color 0.15s; padding: 0;
      -webkit-tap-highlight-color: transparent;
    }
    .mob-tab .mob-icon { font-size: 16px; line-height: 1; }
    .mob-tab.active { color: var(--accent); }
    .mob-tab.active .mob-icon { filter: drop-shadow(0 0 6px var(--accent)); }
    .mob-tab.deus-tab.active { color: var(--accent2); }
    .mob-tab.deus-tab.active .mob-icon { filter: drop-shadow(0 0 6px var(--accent2)); }

    /* â”€â”€ Bottom sheet â”€â”€ */
    #mobileSheet {
      position: fixed; bottom: 52px; left: 0; right: 0;
      background: rgba(8,10,20,0.97);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border-top: 1px solid var(--border);
      z-index: 190; overflow: hidden;
      max-height: 0; transition: max-height 0.3s cubic-bezier(0.4,0,0.2,1);
    }
    #mobileSheet.open { max-height: 55vh; }
    @media (orientation: landscape) {
      #mobileSheet.open { max-height: 65vh; }
    }
    .mob-sheet-inner {
      padding: 14px 16px 10px;
      overflow-y: auto; max-height: 55vh;
    }
    @media (orientation: landscape) {
      .mob-sheet-inner { max-height: 65vh; }
    }
    .mob-sheet-inner::-webkit-scrollbar { width: 2px; }
    .mob-sheet-inner::-webkit-scrollbar-thumb { background: rgba(0,245,196,0.2); }

    /* Sheet section headings */
    .mob-heading {
      font-family: 'Syncopate', sans-serif;
      font-size: 7px; letter-spacing: 3px; color: var(--accent);
      text-transform: uppercase; margin-bottom: 10px;
    }
    .mob-heading.red { color: var(--accent2); text-shadow: 0 0 8px rgba(255,77,109,0.4); }

    /* Larger tap targets for mobile buttons */
    #mobileSheet .btn { padding: 10px 12px; font-size: 11px; margin-bottom: 8px; }
    #mobileSheet .control-row { margin-bottom: 12px; font-size: 11px; }
    #mobileSheet input[type=range] { width: 120px; height: 4px; }
    #mobileSheet input[type=range]::-webkit-slider-thumb { width: 16px; height: 16px; }
    #mobileSheet .val-display { font-size: 11px; }
    #mobileSheet .control-label { font-size: 10px; }

    /* Spawn grid â€” 2 columns on mobile */
    #mobSpawnGrid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
      margin-bottom: 10px;
    }
    #mobSpawnGrid .btn { margin-bottom: 0; font-size: 10px; padding: 10px 6px; text-align: center; letter-spacing: 1px; }
    .mob-qty-row { display: flex; gap: 6px; margin-bottom: 8px; }
    .mob-qty-row .btn { flex: 1; text-align: center; padding: 8px 0; margin-bottom: 0; }

    /* Species grid â€” 5 columns on mobile (wider viewport) */
    #mobSpeciesGrid.species-grid { grid-template-columns: repeat(5, 1fr); gap: 5px; }

    /* Deus grid */
    .mob-deus-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 6px; }
    .mob-deus-grid .btn { margin-bottom: 0; font-size: 9px; padding: 9px 5px; }

    /* Mutation nudge rows on mobile */
    #mobileSheet .mut-row { margin-bottom: 7px; }
    #mobileSheet .mut-btn { width: 30px; height: 30px; font-size: 14px; }
    #mobileSheet .mut-label { font-size: 10px; }
    #mobileSheet .type-tab { padding: 7px 4px; font-size: 9px; }
  }

  /* Hide mobile-only elements on desktop */
  #mobileTabBar, #mobileSheet { display: none; }
</style>
</head>
<body>

<div id="weatherBanner"><div id="weatherBannerTitle"></div><div id="weatherBannerSub"></div></div>
<div id="seasonBar"><div id="seasonBarFill"></div></div>

<header>
  <div class="logo">ALIFE <span>/ SIM</span></div>
  <div class="header-stats">
    <div class="stat"><div class="stat-val" id="hPop">0</div><div class="stat-lbl">Herbivores</div></div>
    <div class="stat"><div class="stat-val" id="cPop" style="color:var(--accent2)">0</div><div class="stat-lbl">Carnivores</div></div>
    <div class="stat"><div class="stat-val" id="oPop" style="color:#2bbcff">0</div><div class="stat-lbl">Omnivores</div></div>
    <div class="stat"><div class="stat-val" id="fPop" style="color:var(--accent3)">0</div><div class="stat-lbl">Food</div></div>
    <div class="stat stat-hide-mobile"><div class="stat-val" id="sPop" style="color:#2d8a30">0</div><div class="stat-lbl">Seeds</div></div>
    <div class="stat stat-hide-mobile"><div class="stat-val" id="genNum" style="color:#a29bfe">0</div><div class="stat-lbl">Generation</div></div>
    <div class="stat stat-hide-mobile"><div class="stat-val" id="tickNum">0</div><div class="stat-lbl">Tick</div></div>
    <div class="stat"><div class="stat-val" id="seasonDisplay" style="color:#ffd166">ğŸŒ±</div><div class="stat-lbl">Season</div></div>
  </div>
  <a href="https://www.linkedin.com/in/callum-smith-55118071/" target="_blank" rel="noopener" class="by-cal-link">
    <svg width="13" height="13" viewBox="0 0 24 24" fill="currentColor">
      <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
    </svg>
    BY CAL
  </a>
</header>

<div class="main">
  <canvas id="canvas"></canvas>
  <div class="panel">
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Simulation</div>
        <button class="collapse-btn" onclick="toggleSection('simBody',this)" title="Toggle">â–¼</button>
      </div>
      <div id="simBody">
        <button class="btn active" id="playBtn" onclick="togglePlay()">â¸ PAUSE</button>
        <button class="btn danger" onclick="resetSim()">â†º RESET</button>
        <div class="control-row">
          <div class="control-label">SPEED</div>
          <input type="range" id="speedSlider" min="0" max="13" value="2" oninput="updateSpeed(this)">
          <div class="val-display" id="speedVal">1Ã—</div>
        </div>
      </div>
    </div>
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Environment</div>
        <button class="collapse-btn" onclick="toggleSection('envBody',this)" title="Toggle">â–¼</button>
      </div>
      <div id="envBody">
        <div class="control-row">
          <div class="control-label">FOOD SPREAD</div>
          <input type="range" id="foodRate" min="1" max="50" value="8" oninput="updateParam('foodRate', this)">
          <div class="val-display" id="foodRateVal">8</div>
        </div>
        <div class="control-row">
          <div class="control-label">MAX FOOD</div>
          <input type="range" id="maxFood" min="20" max="1000" value="120" oninput="updateParam('maxFood', this)">
          <div class="val-display" id="maxFoodVal">120</div>
        </div>
        <div class="control-row">
          <div class="control-label">MUTATION</div>
          <input type="range" id="mutRate" min="0" max="50" value="10" oninput="updateParam('mutRate', this)">
          <div class="val-display" id="mutRateVal">10%</div>
        </div>
        <div class="control-row">
          <div class="control-label">FLOCK STR</div>
          <input type="range" id="flockStr" min="0" max="20" value="10" oninput="updateParam('flockStr', this)">
          <div class="val-display" id="flockStrVal">10</div>
        </div>
        <button class="btn" id="pheroBtn" onclick="togglePhero()" style="margin-top:2px;">â— SHOW SCENT TRAILS</button>
      </div>
    </div>
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Spawn</div>
        <button class="collapse-btn" onclick="toggleSection('spawnBody',this)" title="Toggle">â–¼</button>
      </div>
      <div id="spawnBody">
        <button class="btn" id="spawnH" onclick="spawnCreatures('herbivore', spawnAmt())">+ <span id="spawnHlbl">1</span> HERBIVORE<span id="spawnHs"></span></button>
        <button class="btn" id="spawnC" onclick="spawnCreatures('carnivore', spawnAmt())">+ <span id="spawnClbl">1</span> CARNIVORE<span id="spawnCs"></span></button>
        <button class="btn" id="spawnO" onclick="spawnCreatures('omnivore', spawnAmt())">+ <span id="spawnOlbl">1</span> OMNIVORE<span id="spawnOs"></span></button>
        <button class="btn" id="spawnS" onclick="spawnSeed(spawnAmt())">+ <span id="spawnSlbl">1</span> SEED<span id="spawnSs"></span></button>
        <button class="btn" id="spawnF" onclick="spawnFood(spawnAmt())">+ <span id="spawnFlbl">1</span> FOOD</button>
        <div style="display:flex;gap:6px;margin-top:8px;">
          <button class="btn qty-btn active" id="qty1" onclick="setQty(1)" style="flex:1;text-align:center;padding:6px 0;">1</button>
          <button class="btn qty-btn" id="qty10" onclick="setQty(10)" style="flex:1;text-align:center;padding:6px 0;">10</button>
          <button class="btn qty-btn" id="qty25" onclick="setQty(25)" style="flex:1;text-align:center;padding:6px 0;">25</button>
        </div>
      </div>
    </div>
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Legend</div>
        <button class="collapse-btn" id="legendToggle" onclick="toggleLegend()" title="Toggle legend">â–¼</button>
      </div>
      <div class="legend" id="legendBody">
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>HERBIVORE â€” eats food</div>
        <div class="legend-item"><div class="legend-dot" style="background:#00dce0"></div>OMNIVORE â€” food + corpses</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent2)"></div>CARNIVORE â€” hunts prey</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent3)"></div>FOOD â€” energy pellets</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffd166;border:1px dashed rgba(255,200,50,0.6)"></div>SEED â€” disperses food, vanishes</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a29bfe"></div>MATING â€” purple, vulnerable!</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffd166;opacity:0.7"></div>SATED (90%+) â€” behaviour shift</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a0b4f0;opacity:0.7"></div>SLEEPING â€” inert, vulnerable</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffa032;opacity:0.8"></div>SPRINTING â€” burning stamina</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(0,245,196,0.4)"></div>HERB SCENT â€” carnivores track</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(0,210,255,0.5)"></div>OMNI SCENT â€” distinct cyan</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(255,77,109,0.4)"></div>CARN SCENT â€” herbivores flee</div>
        <div class="legend-item"><div class="legend-dot" style="background:#5c3d1a;opacity:0.7"></div>CORPSE â€” carnivore food</div>
        <div class="legend-item"><div class="legend-dot" style="background:#636e72;opacity:0.4"></div>OLD AGE â€” no corpse</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Population Graph</div>
        <button class="collapse-btn" onclick="toggleSection('graphBody',this)" title="Toggle">â–¼</button>
      </div>
      <div id="graphBody">
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:5px;">
          <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#00f5c4"><div style="width:8px;height:8px;background:#00f5c4;border-radius:1px;flex-shrink:0"></div>HERB</div>
          <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#ff4d6d"><div style="width:8px;height:8px;background:#ff4d6d;border-radius:1px;flex-shrink:0"></div>CARN</div>
          <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#2bbcff"><div style="width:8px;height:8px;background:#2bbcff;border-radius:1px;flex-shrink:0"></div>OMNI</div>
          <div style="display:flex;align-items:center;gap:3px;font-size:8px;letter-spacing:1px;color:#ffd166"><div style="width:8px;height:8px;background:#ffd166;border-radius:1px;flex-shrink:0"></div>FOOD</div>
        </div>
        <div class="mini-chart"><canvas id="chartCanvas"></canvas></div>
      </div>
    </div>
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Species <span id="speciesCount" style="color:var(--text);font-size:9px;letter-spacing:1px">0</span></div>
        <button class="collapse-btn" onclick="toggleSection('speciesBody',this)" title="Toggle">â–¼</button>
      </div>
      <div id="speciesBody">
        <div class="species-grid" id="speciesGrid"></div>
      </div>
    </div>
    <div class="section">
      <div class="section-title-row">
        <div class="section-title" style="margin-bottom:0">Selection Info</div>
        <button class="collapse-btn" onclick="toggleSection('infoBody',this)" title="Toggle">â–¼</button>
      </div>
      <div id="infoBody">
        <div class="info-box" id="infoBox"><b>Click a creature</b> to inspect its genes and status.</div>
      </div>
    </div>

    <!-- â”€â”€ DEUS EX MACHINA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="deus-section">
      <div class="section-title-row" style="margin-bottom:10px;">
        <div class="deus-title" style="margin-bottom:0;">âš¡ Deus Ex Machina</div>
        <button class="collapse-btn" style="color:var(--accent2);" onclick="toggleSection('deusBody',this)" title="Toggle">â–¼</button>
      </div>
      <div id="deusBody">

      <div class="deus-subtitle">â€” Seasons â€”</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-bottom:2px;">
        <button class="btn deus" style="margin-bottom:0;font-size:9px;padding:5px 4px;" onclick="deusSetSeason(0)">ğŸŒ± SPRING</button>
        <button class="btn deus" style="margin-bottom:0;font-size:9px;padding:5px 4px;" onclick="deusSetSeason(1)">â˜€ï¸ SUMMER</button>
        <button class="btn deus" style="margin-bottom:0;font-size:9px;padding:5px 4px;" onclick="deusSetSeason(2)">ğŸ‚ AUTUMN</button>
        <button class="btn deus" style="margin-bottom:0;font-size:9px;padding:5px 4px;" onclick="deusSetSeason(3)">â„ï¸ WINTER</button>
      </div>
      <button class="btn deus" id="longWinterBtn" onclick="deusLongWinter()" style="font-size:9px;margin-top:4px;">ğŸ§Š TRIGGER LONG WINTER</button>

      <div class="deus-subtitle">â€” Weather â€”</div>
      <button class="btn deus" id="randomWeatherBtn" onclick="toggleRandomWeather()" style="font-size:9px;">ğŸ² RANDOM EVENTS: OFF</button>
      <button class="btn deus" id="deusdroughtBtn"  onclick="deusTriggerWeather('DROUGHT')"        style="font-size:9px;">ğŸ”¥ DROUGHT</button>
      <button class="btn deus" id="deusplagueBtn"   onclick="deusTriggerWeather('PLAGUE WIND')"    style="font-size:9px;">ğŸ’¨ PLAGUE WIND</button>
      <button class="btn deus" id="deusfrenzywBtn"  onclick="deusTriggerWeather('FEEDING FRENZY')" style="font-size:9px;">âš¡ FEEDING FRENZY</button>
      <button class="btn deus" id="deusblizzardBtn" onclick="deusTriggerWeather('BLIZZARD')"       style="font-size:9px;">ğŸŒ¨ï¸ BLIZZARD</button>
      <button class="btn deus" id="deustoxicBtn"    onclick="deusTriggerWeather('TOXIC RAIN')"     style="font-size:9px;">â˜ ï¸ TOXIC RAIN</button>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-bottom:6px;">
        <button class="btn deus" id="clearWeatherBtn" onclick="deusClearWeather()" style="font-size:9px;margin-bottom:0;">âœ• CLEAR</button>
        <button class="btn deus" id="clearToxicBtn"   onclick="deusClearToxic()"   style="font-size:9px;margin-bottom:0;">ğŸ§¹ PURGE TOXIC</button>
      </div>

      <div class="deus-subtitle">â€” Catastrophes â€”</div>
      <button class="btn deus" id="meteorBtn"   onclick="deusArmMeteor()"   style="font-size:9px;">â˜„ï¸ METEOR STRIKE <span style="opacity:0.5;font-size:8px;">[click canvas]</span></button>
      <button class="btn deus" id="frenzyCBtn"  onclick="deusFrenzy()"      style="font-size:9px;">ğŸ©¸ CARNIVORE FRENZY</button>

      <div class="deus-subtitle">â€” Divine Intervention â€”</div>
      <button class="btn deus" id="championBtn"  onclick="deusArmChampion()"  style="font-size:9px;">ğŸ‘‘ CHAMPION <span style="opacity:0.5;font-size:8px;">[click creature]</span></button>
      <button class="btn deus" id="teleportBtn"  onclick="deusArmTeleport()"  style="font-size:9px;">ğŸŒ€ TELEPORT <span style="opacity:0.5;font-size:8px;">[click creatureâ†’place]</span></button>

      <div class="deus-subtitle">â€” Targeted Mutations â€”</div>
      <div class="type-tabs">
        <button class="type-tab herb active" id="mutTabHerb" onclick="setMutTab('herbivore')">HERB</button>
        <button class="type-tab carn"        id="mutTabCarn" onclick="setMutTab('carnivore')">CARN</button>
        <button class="type-tab omni"        id="mutTabOmni" onclick="setMutTab('omnivore')">OMNI</button>
      </div>
      <div id="mutRows">
        <!-- Populated by JS -->
      </div>
      </div><!-- end #deusBody -->
    </div><!-- end .deus-section -->
  </div><!-- end .panel -->
</div><!-- end .main -->

<footer>
  <span>ARTIFICIAL LIFE SIMULATOR â€” EVOLUTIONARY GENETICS ENGINE</span>
  <span id="fpsDisplay">60 FPS</span>
</footer>

<!-- â”€â”€ MOBILE TAB BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="mobileTabBar">
  <button class="mob-tab active" onclick="mobSwitchTab('sim',this)">
    <span class="mob-icon">âš™ï¸</span><span>SIM</span>
  </button>
  <button class="mob-tab" onclick="mobSwitchTab('env',this)">
    <span class="mob-icon">ğŸŒ¿</span><span>ENV</span>
  </button>
  <button class="mob-tab" onclick="mobSwitchTab('spawn',this)">
    <span class="mob-icon">âœ¦</span><span>SPAWN</span>
  </button>
  <button class="mob-tab" onclick="mobSwitchTab('species',this)">
    <span class="mob-icon">â—ˆ</span><span>SPECIES</span>
  </button>
  <button class="mob-tab deus-tab" onclick="mobSwitchTab('deus',this)">
    <span class="mob-icon">âš¡</span><span>DEUS</span>
  </button>
</div>

<!-- â”€â”€ MOBILE BOTTOM SHEET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="mobileSheet">
  <div class="mob-sheet-inner">

    <!-- SIM panel -->
    <div id="mobPanelSim" class="mob-panel">
      <div class="mob-heading">Simulation</div>
      <div style="display:flex;gap:8px;margin-bottom:10px;">
        <button class="btn active" id="mobPlayBtn" onclick="togglePlay()" style="flex:2;margin-bottom:0;">â¸ PAUSE</button>
        <button class="btn danger" onclick="resetSim()" style="flex:1;margin-bottom:0;">â†º RESET</button>
      </div>
      <div class="control-row">
        <div class="control-label">SPEED</div>
        <input type="range" id="mobSpeedSlider" min="0" max="13" value="2" oninput="updateSpeed(this);document.getElementById('speedSlider').value=this.value;">
        <div class="val-display" id="mobSpeedVal">1Ã—</div>
      </div>
      <div class="control-row" style="margin-top:8px;">
        <div class="control-label">SCENT TRAILS</div>
        <button class="btn" id="mobPheroBtn" onclick="togglePhero()" style="width:auto;margin-bottom:0;padding:6px 10px;font-size:9px;">OFF</button>
      </div>
    </div>

    <!-- ENV panel -->
    <div id="mobPanelEnv" class="mob-panel" style="display:none;">
      <div class="mob-heading">Environment</div>
      <div class="control-row">
        <div class="control-label">FOOD SPREAD</div>
        <input type="range" id="mobFoodRate" min="1" max="50" value="8" oninput="updateParam('foodRate',this);document.getElementById('foodRate').value=this.value;">
        <div class="val-display" id="mobFoodRateVal">8</div>
      </div>
      <div class="control-row">
        <div class="control-label">MAX FOOD</div>
        <input type="range" id="mobMaxFood" min="20" max="1000" value="120" oninput="updateParam('maxFood',this);document.getElementById('maxFood').value=this.value;">
        <div class="val-display" id="mobMaxFoodVal">120</div>
      </div>
      <div class="control-row">
        <div class="control-label">MUTATION</div>
        <input type="range" id="mobMutRate" min="0" max="50" value="10" oninput="updateParam('mutRate',this);document.getElementById('mutRate').value=this.value;">
        <div class="val-display" id="mobMutRateVal">10%</div>
      </div>
      <div class="control-row">
        <div class="control-label">FLOCK STR</div>
        <input type="range" id="mobFlockStr" min="0" max="20" value="10" oninput="updateParam('flockStr',this);document.getElementById('flockStr').value=this.value;">
        <div class="val-display" id="mobFlockStrVal">10</div>
      </div>
    </div>

    <!-- SPAWN panel -->
    <div id="mobPanelSpawn" class="mob-panel" style="display:none;">
      <div class="mob-heading">Spawn</div>
      <div class="mob-qty-row">
        <button class="btn qty-btn active" id="mobQty1"  onclick="setQty(1)"  style="margin-bottom:0;">1</button>
        <button class="btn qty-btn"        id="mobQty10" onclick="setQty(10)" style="margin-bottom:0;">10</button>
        <button class="btn qty-btn"        id="mobQty25" onclick="setQty(25)" style="margin-bottom:0;">25</button>
      </div>
      <div id="mobSpawnGrid">
        <button class="btn" onclick="spawnCreatures('herbivore',spawnAmt())" style="margin-bottom:0;text-align:center;color:var(--accent);border-color:rgba(0,245,196,0.3);">+ HERB</button>
        <button class="btn" onclick="spawnCreatures('carnivore',spawnAmt())" style="margin-bottom:0;text-align:center;color:var(--accent2);border-color:rgba(255,77,109,0.3);">+ CARN</button>
        <button class="btn" onclick="spawnCreatures('omnivore',spawnAmt())"  style="margin-bottom:0;text-align:center;color:#2bbcff;border-color:rgba(43,188,255,0.3);">+ OMNI</button>
        <button class="btn" onclick="spawnFood(spawnAmt())"                  style="margin-bottom:0;text-align:center;color:var(--accent3);border-color:rgba(255,209,102,0.3);">+ FOOD</button>
        <button class="btn" onclick="spawnSeed(spawnAmt())"                  style="margin-bottom:0;text-align:center;color:#2d8a30;border-color:rgba(45,138,48,0.3);">+ SEED</button>
      </div>
    </div>

    <!-- SPECIES panel -->
    <div id="mobPanelSpecies" class="mob-panel" style="display:none;">
      <div class="mob-heading">Species <span id="mobSpeciesCount" style="color:var(--text);font-size:9px;">0</span></div>
      <div class="species-grid" id="mobSpeciesGrid" style="grid-template-columns:repeat(5,1fr);gap:5px;"></div>
    </div>

    <!-- DEUS panel -->
    <div id="mobPanelDeus" class="mob-panel" style="display:none;">
      <div class="mob-heading red">âš¡ Deus Ex Machina</div>

      <div class="deus-subtitle">Seasons</div>
      <div class="mob-deus-grid" style="grid-template-columns:repeat(4,1fr);">
        <button class="btn deus" onclick="deusSetSeason(0)" style="margin-bottom:0;font-size:9px;padding:8px 2px;text-align:center;">ğŸŒ±</button>
        <button class="btn deus" onclick="deusSetSeason(1)" style="margin-bottom:0;font-size:9px;padding:8px 2px;text-align:center;">â˜€ï¸</button>
        <button class="btn deus" onclick="deusSetSeason(2)" style="margin-bottom:0;font-size:9px;padding:8px 2px;text-align:center;">ğŸ‚</button>
        <button class="btn deus" onclick="deusSetSeason(3)" style="margin-bottom:0;font-size:9px;padding:8px 2px;text-align:center;">â„ï¸</button>
      </div>
      <button class="btn deus" id="mobLongWinterBtn" onclick="deusLongWinter()" style="font-size:9px;margin-top:6px;">ğŸ§Š LONG WINTER</button>

      <div class="deus-subtitle">Weather</div>
      <button class="btn deus" id="mobRandomWeatherBtn" onclick="toggleRandomWeather()" style="font-size:9px;">ğŸ² RANDOM EVENTS: OFF</button>
      <div class="mob-deus-grid">
        <button class="btn deus" id="mobDeusdroughtBtn"  onclick="deusTriggerWeather('DROUGHT')"        style="margin-bottom:0;font-size:9px;">ğŸ”¥ DROUGHT</button>
        <button class="btn deus" id="mobDeusplagueBtn"   onclick="deusTriggerWeather('PLAGUE WIND')"    style="margin-bottom:0;font-size:9px;">ğŸ’¨ PLAGUE</button>
        <button class="btn deus" id="mobDeusfrenzywBtn"  onclick="deusTriggerWeather('FEEDING FRENZY')" style="margin-bottom:0;font-size:9px;">âš¡ FRENZY</button>
        <button class="btn deus" id="mobDeusblizzardBtn" onclick="deusTriggerWeather('BLIZZARD')"       style="margin-bottom:0;font-size:9px;">ğŸŒ¨ï¸ BLIZZ</button>
        <button class="btn deus" id="mobDeustoxicBtn"    onclick="deusTriggerWeather('TOXIC RAIN')"     style="margin-bottom:0;font-size:9px;">â˜ ï¸ TOXIC</button>
        <button class="btn deus" id="mobClearWeatherBtn" onclick="deusClearWeather()"                   style="margin-bottom:0;font-size:9px;">âœ• CLEAR</button>
        <button class="btn deus" onclick="deusClearToxic()"   style="margin-bottom:0;font-size:9px;grid-column:span 2;">ğŸ§¹ PURGE TOXIC</button>
      </div>

      <div class="deus-subtitle">Catastrophes</div>
      <div class="mob-deus-grid">
        <button class="btn deus" id="mobMeteorBtn"  onclick="deusArmMeteor()"  style="margin-bottom:0;font-size:9px;">â˜„ï¸ METEOR</button>
        <button class="btn deus" id="mobFrenzyCBtn" onclick="deusFrenzy()"     style="margin-bottom:0;font-size:9px;">ğŸ©¸ FRENZY</button>
      </div>

      <div class="deus-subtitle">Divine</div>
      <div class="mob-deus-grid">
        <button class="btn deus" id="mobChampionBtn" onclick="deusArmChampion()" style="margin-bottom:0;font-size:9px;">ğŸ‘‘ CHAMPION</button>
        <button class="btn deus" id="mobTeleportBtn" onclick="deusArmTeleport()" style="margin-bottom:0;font-size:9px;">ğŸŒ€ TELEPORT</button>
      </div>

      <div class="deus-subtitle">Mutations</div>
      <div class="type-tabs" style="margin-bottom:10px;">
        <button class="type-tab herb active" id="mobMutTabHerb" onclick="setMutTab('herbivore')">HERB</button>
        <button class="type-tab carn"        id="mobMutTabCarn" onclick="setMutTab('carnivore')">CARN</button>
        <button class="type-tab omni"        id="mobMutTabOmni" onclick="setMutTab('omnivore')">OMNI</button>
      </div>
      <div id="mobMutRows"></div>
    </div>

  </div><!-- mob-sheet-inner -->
</div><!-- mobileSheet -->

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Declared early â€” used by resize() and updateUI() before mobile JS block runs
const isMobile = () => window.innerWidth <= 768;
const chartCanvas = document.getElementById('chartCanvas');
const chartCtx = chartCanvas.getContext('2d');

let creatures = [];
let foods = [];
let seeds = []; // Seeds generate food but can't be eaten
let selectedSpeciesId = null; // for species highlight feature

// â”€â”€ Species registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each species = { id, type, shape, count } where shape is a polygon vertex count
// Base shapes per type: herbivore=6(hex), carnivore=4(diamond), omnivore=0(circle)
// New species get shapes: 3(tri), 5(pent), 7(hept), 8(oct)...
const EXTRA_SHAPES   = [3, 5, 7, 8, 9, 10, 11, 12, 3, 5, 7, 8, 9, 10]; // cycling pool â€” 14 distinct shapes
let   speciesRegistry = {}; // key: speciesId -> { id, type, shape, color }
let   nextShapeIdx    = 0;

// Species distance threshold: creatures with genome distance > this fork a new species
// Speciation distance threshold.
// genomeVec normalises 7 traits into [0,1]; max possible distance = sqrt(7/7) = 1.0
// With 10% mutation rate, children drift ~0.05â€“0.15 per generation.
// Threshold of 0.25 means ~4-6 generations of directional drift before forking.
const SPECIATION_THRESHOLD = 0.25;

function genomeVec(dna) {
  // Normalised vector of heritable traits for distance comparison
  return [
    dna.speed      / 5,
    dna.sense      / 200,
    dna.size       / 12,
    dna.fertility  / 0.01,
    dna.metabolism / 0.08,
    dna.aggression,
    (dna.stamina ?? 1.0),
  ];
}

function genomeDist(a, b) {
  const va = genomeVec(a), vb = genomeVec(b);
  let s = 0;
  for (let i = 0; i < va.length; i++) s += (va[i]-vb[i])**2;
  return Math.sqrt(s / va.length);
}

function assignSpecies(c) {
  // Find the closest registered species of same type
  let bestId = null, bestDist = Infinity;
  for (const [sid, sp] of Object.entries(speciesRegistry)) {
    if (sp.type !== c.dna.type) continue;
    const d = genomeDist(c.dna, sp.centroid);
    if (d < bestDist) { bestDist = d; bestId = sid; }
  }
  if (bestId !== null && bestDist < SPECIATION_THRESHOLD) {
    c.speciesId = bestId;
  } else {
    // Fork a new species
    const sid = 'sp_' + Math.random().toString(36).slice(2,7);
    const sameTypeSpecies = Object.values(speciesRegistry).filter(s => s.type === c.dna.type);
    const isBase = sameTypeSpecies.length === 0;
    const baseShape = c.dna.type === 'herbivore' ? 6
                    : c.dna.type === 'omnivore'  ? 0
                    : 4;
    // Rotate through extra shapes; each type has its own counter
    const shape = isBase ? baseShape : EXTRA_SHAPES[nextShapeIdx++ % EXTRA_SHAPES.length];
    speciesRegistry[sid] = {
      id: sid, type: c.dna.type, shape,
      centroid: { type: c.dna.type, ...c.dna }
    };
    c.speciesId = sid;
    console.log(`New species: ${sid} (${c.dna.type}, shape=${shape}, dist=${bestDist?.toFixed(3)})`);
  }
}

function updateSpeciesCentroids() {
  // Recalculate centroid (average genome) of each living species
  const sums   = {};
  const counts = {};
  for (const c of creatures) {
    if (!c.alive || !c.speciesId) continue;
    const sid = c.speciesId;
    if (!sums[sid]) { sums[sid] = genomeVec(c.dna).map(() => 0); counts[sid] = 0; }
    const v = genomeVec(c.dna);
    for (let i = 0; i < v.length; i++) sums[sid][i] += v[i];
    counts[sid]++;
  }
  const keys = ['speed','sense','size','fertility','metabolism','aggression','stamina'];
  const scale = [5, 200, 12, 0.01, 0.08, 1, 1.0];
  for (const [sid, sp] of Object.entries(speciesRegistry)) {
    if (!counts[sid]) continue;
    const avg = sums[sid].map((s,i) => s / counts[sid]);
    keys.forEach((k,i) => { sp.centroid[k] = avg[i] * scale[i]; });
    sp.centroid.type = sp.type; // preserve type field
  }
  // Prune extinct species
  const activeSids = new Set(creatures.filter(c => c.alive && c.speciesId).map(c => c.speciesId));
  for (const sid of Object.keys(speciesRegistry)) {
    if (!activeSids.has(sid)) delete speciesRegistry[sid];
  }
}
let tick = 0;
let generation = 1;
let playing = true;
let speed = 1;
let selectedCreature = null;
let corpses = [];

// â”€â”€ Deus Ex Machina state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let deusMode = null;           // 'meteor' | 'champion' | 'teleport-pick' | 'teleport-place'
let deusTeleportCreature = null; // creature waiting to be teleported
let meteors = [];              // { x, y, countdown, maxCountdown } pending impacts
let craters = [];              // { x, y, r, age } scorched zones blocking food growth
const METEOR_COUNTDOWN = 120;  // ticks of warning before impact
const METEOR_RADIUS    = 80;   // kill radius on impact
const CRATER_DURATION  = 900;  // ticks before crater fades
let longWinterActive   = false;
let longWinterTicks    = 0;
let frenziedTicks      = 0;    // carnivore frenzy duration remaining
let toxicRainActive    = false; // food spawned is toxic
let mutTargetType      = 'herbivore'; // which type the mutation nudges target
let randomWeatherEnabled = false;    // whether random weather events fire automatically

// â”€â”€ Pheromone grids â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PHERO_CELL = 8;        // pixels per grid cell
let pheroW = 1, pheroH = 1; // grid dimensions, set on resize
let pheroHerb = null;        // herbivore scent (teal) â€” carnivores follow this
let pheroCarn = null;        // carnivore scent (red)  â€” herbivores flee this
let pheroOmni = null;        // omnivore scent (cyan)  â€” distinct from herb
let pheroCanvas = null;      // offscreen canvas for pre-blended pheromone image
let pheroCtx2   = null;
let pheroNeedsRedraw = true; // flag: redraw offscreen when data changes

function initPhero() {
  pheroW = Math.ceil(canvas.width  / PHERO_CELL);
  pheroH = Math.ceil(canvas.height / PHERO_CELL);
  pheroHerb = new Float32Array(pheroW * pheroH);
  pheroCarn = new Float32Array(pheroW * pheroH);
  pheroOmni = new Float32Array(pheroW * pheroH);
  // Offscreen canvas mirrors the phero grid
  pheroCanvas = document.createElement('canvas');
  pheroCanvas.width  = pheroW * PHERO_CELL;
  pheroCanvas.height = pheroH * PHERO_CELL;
  pheroCtx2 = pheroCanvas.getContext('2d');
  pheroNeedsRedraw = true;
}

function pheroIdx(gx, gy) { return gy * pheroW + gx; }

function depositPhero(grid, x, y, amount) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  if (gx < 0 || gx >= pheroW || gy < 0 || gy >= pheroH) return;
  grid[pheroIdx(gx, gy)] = Math.min(1, grid[pheroIdx(gx, gy)] + amount);
}

function samplePhero(grid, x, y) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  if (gx < 0 || gx >= pheroW || gy < 0 || gy >= pheroH) return 0;
  return grid[pheroIdx(gx, gy)];
}

// Read gradient of grid at position â€” returns (dx,dy) pointing uphill
function pheroGradient(grid, x, y) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  const get = (gx2, gy2) => {
    if (gx2 < 0 || gx2 >= pheroW || gy2 < 0 || gy2 >= pheroH) return 0;
    return grid[pheroIdx(gx2, gy2)];
  };
  const dx = get(gx+1, gy) - get(gx-1, gy);
  const dy = get(gx, gy+1) - get(gx, gy-1);
  return { dx, dy };
}

// Evaporate and diffuse the grid â€” called each tick
function updatePhero(grid) {
  const evap    = 0.992; // retain 99.2% each tick â€” slow fade
  const diffuse = 0.06;  // how much bleeds to neighbours
  const next = new Float32Array(grid.length);
  for (let gy = 0; gy < pheroH; gy++) {
    for (let gx = 0; gx < pheroW; gx++) {
      const i   = pheroIdx(gx, gy);
      const val = grid[i] * evap;
      const bleed = val * diffuse;
      next[i] += val - bleed;
      // Spread a fraction to the 4 neighbours
      if (gx > 0)          next[pheroIdx(gx-1, gy)] += bleed * 0.25;
      if (gx < pheroW - 1) next[pheroIdx(gx+1, gy)] += bleed * 0.25;
      if (gy > 0)          next[pheroIdx(gx, gy-1)] += bleed * 0.25;
      if (gy < pheroH - 1) next[pheroIdx(gx, gy+1)] += bleed * 0.25;
    }
  }
  grid.set(next);
}


// â”€â”€ Spatial Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Bins all objects into fixed-size cells so neighbour lookups are O(1) average
// instead of O(n). Rebuilt from scratch each tick (cheap for <1000 objects).
const GRID_CELL = 80; // px â€” tune to ~2Ã— typical sense radius
class SpatialGrid {
  constructor(W, H) {
    this.cols = Math.ceil(W / GRID_CELL);
    this.rows = Math.ceil(H / GRID_CELL);
    this.cells = new Array(this.cols * this.rows).fill(null).map(() => []);
  }
  _idx(x, y) {
    const col = Math.max(0, Math.min(this.cols-1, Math.floor(x / GRID_CELL)));
    const row = Math.max(0, Math.min(this.rows-1, Math.floor(y / GRID_CELL)));
    return row * this.cols + col;
  }
  insert(obj) { this.cells[this._idx(obj.x, obj.y)].push(obj); }
  // Query all objects within radius r of (x,y)
  query(x, y, r) {
    const c0 = Math.max(0, Math.floor((x-r)/GRID_CELL));
    const c1 = Math.min(this.cols-1, Math.floor((x+r)/GRID_CELL));
    const r0 = Math.max(0, Math.floor((y-r)/GRID_CELL));
    const r1 = Math.min(this.rows-1, Math.floor((y+r)/GRID_CELL));
    const out = [];
    const r2  = r*r;
    for (let row = r0; row <= r1; row++) {
      for (let col = c0; col <= c1; col++) {
        for (const o of this.cells[row*this.cols+col]) {
          const dx = o.x-x, dy = o.y-y;
          if (dx*dx+dy*dy <= r2) out.push(o);
        }
      }
    }
    return out;
  }
}

// Per-tick grids (rebuilt in updateSim before creature updates)
let sgCreatures = null; // all alive creatures
let sgFoods     = null; // food pellets
let sgCorpses   = null; // corpses

function rebuildGrids() {
  const W = canvas.width, H = canvas.height;
  sgCreatures = new SpatialGrid(W, H);
  sgFoods     = new SpatialGrid(W, H);
  sgCorpses   = new SpatialGrid(W, H);
  for (const c of creatures) { if (c.alive) sgCreatures.insert(c); }
  for (const f of foods)     sgFoods.insert(f);
  for (const co of corpses)  sgCorpses.insert(co);
}

// Grid-accelerated nearest-neighbour (replaces findNearest for hot paths)
function gridNearest(x, y, grid, maxDist, filterFn) {
  const candidates = grid ? grid.query(x, y, maxDist) : [];
  let best = null, bd = maxDist * maxDist;
  for (const o of candidates) {
    if (filterFn && !filterFn(o)) continue;
    const dx = o.x-x, dy = o.y-y;
    const d2 = dx*dx+dy*dy;
    if (d2 < bd) { bd = d2; best = o; }
  }
  return best;
}

// Grid-accelerated cone search
function gridInCone(cx, cy, vx, vy, grid, range, halfArc, filterFn) {
  const candidates = grid ? grid.query(cx, cy, range) : [];
  const heading = Math.atan2(vy, vx);
  const spd     = Math.sqrt(vx*vx + vy*vy);
  const useCone = spd > 0.1;
  let best = null, bd = range*range;
  for (const o of candidates) {
    if (filterFn && !filterFn(o)) continue;
    const dx = o.x-cx, dy = o.y-cy;
    const d2 = dx*dx+dy*dy;
    if (d2 >= bd) continue;
    if (useCone) {
      let diff = Math.atan2(dy, dx) - heading;
      while (diff >  Math.PI) diff -= 2*Math.PI;
      while (diff < -Math.PI) diff += 2*Math.PI;
      if (Math.abs(diff) > halfArc) continue;
    }
    bd = d2; best = o;
  }
  return best;
}

// How many ticks creatures stay in the purple mating state before baby spawns
const MATING_DURATION = 60;

const params = { foodRate: 8, maxFood: 120, mutRate: 10, flockStr: 10, showPhero: false };
const history = { h: [], c: [], o: [], f: [] };
const MAX_HISTORY = 196;

// â”€â”€ Seasons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SEASON_LENGTH = 1200; // ticks per season
const SEASONS = [
  { name: 'SPRING', emoji: 'ğŸŒ±', color: '#00f5c4', foodMult: 2.2,  metaMult: 0.85, barColor: '#00f5c4' },
  { name: 'SUMMER', emoji: 'â˜€ï¸', color: '#ffd166', foodMult: 1.0,  metaMult: 1.0,  barColor: '#ffd166' },
  { name: 'AUTUMN', emoji: 'ğŸ‚', color: '#ff9a3c', foodMult: 0.55, metaMult: 1.15, barColor: '#ff9a3c' },
  { name: 'WINTER', emoji: 'â„ï¸', color: '#a0b4f0', foodMult: 0.2,  metaMult: 1.45, barColor: '#a0b4f0' },
];
let currentSeasonIdx = 0;
let seasonTick = 0; // ticks elapsed in current season

function getCurrentSeason() { return SEASONS[currentSeasonIdx]; }

// â”€â”€ Weather events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WEATHER_EVENTS = [
  { name: 'DROUGHT',        emoji: 'ğŸ”¥', color: '#ff6b35', foodMult: 0.15, metaMult: 1.1,  duration: 700,  desc: 'Food growth halted. All creatures burn more energy.' },
  { name: 'PLAGUE WIND',    emoji: 'ğŸ’¨', color: '#c084fc', foodMult: 1.0,  metaMult: 1.5,  duration: 600,  desc: 'A toxic wind raises metabolism across the ecosystem.' },
  { name: 'FEEDING FRENZY', emoji: 'âš¡', color: '#00f5c4', foodMult: 2.8,  metaMult: 0.9,  duration: 450,  desc: 'Food explodes. Populations surge â€” then crash.' },
  { name: 'BLIZZARD',       emoji: 'ğŸŒ¨ï¸', color: '#7dd3fc', foodMult: 0.05, metaMult: 1.6,  duration: 600,  desc: 'Near-zero food. Metabolism spikes. Only the fat survive.' },
  { name: 'TOXIC RAIN',     emoji: 'â˜ ï¸', color: '#a3e635', foodMult: 1.8,  metaMult: 1.0,  duration: 500,  desc: 'Food blooms but poisons all who eat it. Carnivores thrive.' },
];
let activeWeather = null;    // { event, ticksLeft }
let weatherCooldown = 800;   // ticks until next possible event

// â”€â”€ DNA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function randomDNA(type) {
  return {
    type,
    speed:      0.5 + Math.random() * 2.5,
    sense:      30  + Math.random() * 120,
    size:       3   + Math.random() * 5,
    fertility:  0.001 + Math.random() * 0.004,
    metabolism: 0.015 + Math.random() * 0.03,
    aggression: type === 'carnivore' ? 0.5 + Math.random() * 0.5 : Math.random() * 0.3,
    stamina:    (type === 'carnivore' || type === 'omnivore') ? 0.4 + Math.random() * 0.6 : 1.0,
  };
}

function mutateDNA(dna) {
  const m = params.mutRate / 100;
  const mut = v => v * (1 + (Math.random() * 2 - 1) * m);
  return {
    type:       dna.type,
    speed:      Math.max(0.2, Math.min(5,    mut(dna.speed))),
    sense:      Math.max(15,  Math.min(200,  mut(dna.sense))),
    size:       Math.max(2,   Math.min(12,   mut(dna.size))),
    fertility:  Math.max(0.0005, Math.min(0.01, mut(dna.fertility))),
    metabolism: Math.max(0.005,  Math.min(0.08, mut(dna.metabolism))),
    aggression: Math.max(0,   Math.min(1,    mut(dna.aggression))),
    stamina:    Math.max(0.1, Math.min(1.0,  mut(dna.stamina ?? 1.0))),
  };
}

// â”€â”€ Factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createCreature(type, x, y, dna) {
  dna = dna || randomDNA(type);
  const c = {
    id:             Math.random().toString(36).slice(2),
    dna,
    x:              x ?? Math.random() * canvas.width,
    y:              y ?? Math.random() * canvas.height,
    vx:             (Math.random() - 0.5) * 2,
    vy:             (Math.random() - 0.5) * 2,
    energy:         150, // Start at 50% of max (300) â€” must eat before mating
    age:            0,
    alive:          true,
    matingWith:     null,  // partner reference during active mating
    matingTicks:    0,     // progress through MATING_DURATION
    matingCooldown: 0,     // post-birth cooldown
    mateCount:      0,     // successful matings; capped at 3
    sleeping:       false, // currently asleep
    sleepTicks:     0,     // ticks remaining in sleep
    sleepCooldown:  Math.floor(Math.random() * 400) + 200, // ticks until next sleep check
    wakeScatter:    0,     // >0 = startled, flee at full speed
    sprinting:      false, // is currently sprinting
    packTarget:     null,  // shared prey reference for pack hunting
    status:         'WANDERING',
    speciesId:      null,  // assigned by speciation system
    // â”€â”€ Memory (individual learning) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    memFoodX:       null,  // last position where food was successfully eaten
    memFoodY:       null,
    memFoodAge:     0,     // how many ticks ago food was found (fades usefulness)
    memHuntWins:    {},    // { preyType: successCount } for predator intelligence
    memHuntAttempts:{},    // { preyType: attemptCount }
    trail:          [],
    gen:            generation,
  };
  assignSpecies(c);
  return c;
}

function createFood(x, y, toxic) {
  return {
    x:      x ?? Math.random() * canvas.width,
    y:      y ?? Math.random() * canvas.height,
    energy: 20 + Math.random() * 30,
    toxic:  toxic || false,
  };
}

function createSeed(x, y) {
  return {
    x:       x ?? Math.random() * canvas.width,
    y:       y ?? Math.random() * canvas.height,
    budget:  100 + Math.floor(Math.random() * 200), // disperses 100â€“300 food then dies
    spawned: 0,
    age:     0,
  };
}
function spawnSeed(n) { for (let i = 0; i < (n||1); i++) seeds.push(createSeed()); }

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetSim() {
  creatures = []; foods = []; corpses = []; seeds = []; initPhero();
  tick = 0; generation = 1;
  history.h = []; history.c = []; history.o = []; history.f = [];
  selectedCreature = null;
  speciesRegistry = {}; nextShapeIdx = 0;
  currentSeasonIdx = 0; seasonTick = 0;
  activeWeather = null; weatherCooldown = 800;
  selectedSpeciesId = null;
  // Deus state
  deusMode = null; deusTeleportCreature = null;
  meteors = []; craters = [];
  longWinterActive = false; longWinterTicks = 0;
  frenziedTicks = 0; toxicRainActive = false;
  randomWeatherEnabled = false;
  ['randomWeatherBtn','mobRandomWeatherBtn'].forEach(id => {
    const b = document.getElementById(id);
    if (b) { b.textContent = 'ğŸ² RANDOM EVENTS: OFF'; b.classList.remove('active-event'); }
  });
  clearDeusArmed();
  for (let i = 0; i < 40; i++) creatures.push(createCreature('herbivore'));
  for (let i = 0; i < 10; i++) creatures.push(createCreature('carnivore'));
  for (let i = 0; i < 15; i++) creatures.push(createCreature('omnivore'));
  for (let i = 0; i < 50; i++) foods.push(createFood());
}

function spawnCreatures(type, n) { for (let i = 0; i < n; i++) creatures.push(createCreature(type)); }

function spawnFromSpecies(sid) {
  const sp = speciesRegistry[sid];
  if (!sp) { console.warn('spawnFromSpecies: unknown sid', sid); return; }
  const n = spawnAmt();
  for (let i = 0; i < n; i++) {
    const dna = mutateDNA({ ...sp.centroid, type: sp.type });
    // Build directly â€” don't use createCreature() which calls assignSpecies()
    // and would reassign speciesId based on genome distance
    const creature = {
      id:              Math.random().toString(36).slice(2),
      dna,
      x:               Math.random() * canvas.width,
      y:               Math.random() * canvas.height,
      vx:              (Math.random() - 0.5) * 2,
      vy:              (Math.random() - 0.5) * 2,
      energy:          150,
      age:             0,
      alive:           true,
      matingWith:      null,
      matingTicks:     0,
      matingCooldown:  0,
      mateCount:       0,
      sleeping:        false,
      sleepTicks:      0,
      sleepCooldown:   Math.floor(Math.random() * 400) + 200,
      wakeScatter:     0,
      sprinting:       false,
      packTarget:      null,
      status:          'WANDERING',
      speciesId:       sid,
      memFoodX:        null,
      memFoodY:        null,
      memFoodAge:      0,
      memHuntWins:     {},
      memHuntAttempts: {},
      trail:           [],
      gen:             generation,
    };
    creatures.push(creature);
  }
}
function spawnFood(n)            { for (let i = 0; i < n; i++) foods.push(createFood()); }

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dist(a, b) {
  const dx = a.x - b.x, dy = a.y - b.y;
  return Math.sqrt(dx*dx + dy*dy);
}

function findNearest(c, list, maxDist) {
  let best = null, bd = maxDist;
  for (const item of list) {
    const d = dist(c, item);
    if (d < bd) { bd = d; best = item; }
  }
  return best;
}

// Returns success rate [0..1] for a given prey key, defaulting to 0.5 (neutral) if no data
function huntSuccessRate(c, preyType, extra) {
  const key = preyType + (extra || '');
  const wins = c.memHuntWins    ? (c.memHuntWins[key]     || 0) : 0;
  const att  = c.memHuntAttempts? (c.memHuntAttempts[key] || 0) : 0;
  if (att < 3) return 0.5; // insufficient data â€” neutral
  return wins / att;
}

// Cone vision for carnivores â€” forward-facing arc, longer range
// angle is half-arc in radians (Math.PI/3 = 60Â° each side = 120Â° total)
function findInCone(c, list, range, halfArc) {
  const heading = Math.atan2(c.vy, c.vx);
  // Fallback to full circle if barely moving
  const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
  const useCone = spd > 0.1;
  let best = null, bd = range;
  for (const item of list) {
    const dx = item.x - c.x, dy = item.y - c.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d >= bd) continue;
    if (useCone) {
      const angle = Math.atan2(dy, dx);
      let diff = angle - heading;
      // Normalise to -PI..PI
      while (diff >  Math.PI) diff -= 2*Math.PI;
      while (diff < -Math.PI) diff += 2*Math.PI;
      if (Math.abs(diff) > halfArc) continue;
    }
    bd = d; best = item;
  }
  return best;
}

// â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCreature(c) {
  if (!c.alive) return;

  c.age++;
  if (c.matingCooldown > 0) c.matingCooldown--;
  // Normal metabolism; slow down in the last 20% to give the boom-bust cycle
  // more time to stabilise rather than crash
  const baseDrain = c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002;
  const seasonMult = window._seasonMetaMult || 1.0;
  const drainMult = (c.energy < 60 ? 0.45 : 1.0) * seasonMult; // 55% slower when starving
  c.energy -= baseDrain * drainMult;

  if (c.energy <= 0 || c.age > 4000) {
    if (c.matingWith) { c.matingWith.matingWith = null; c.matingWith.matingTicks = 0; }
    // All deaths leave a corpse (burst carnivore pheromone too â€” death smell)
    corpses.push({ x: c.x, y: c.y, energy: 20 + Math.random() * 25, decay: 0, fromType: c.dna.type });
    // Large pheromone burst on death â€” attracts carnivores and omnivores
    if (pheroCarn) depositPhero(pheroCarn, c.x, c.y, 1.0);
    if (pheroOmni) depositPhero(pheroOmni, c.x, c.y, 0.7);
    c.alive = false;
    return;
  }

  const W = canvas.width, H = canvas.height;

  // â”€â”€ SLEEP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (c.sleeping) {
    c.sleepTicks--;
    // Sleeping metabolism is 10% of normal
    // (energy was already deducted at 100% above; refund 90%)
    c.energy += (c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002) * 0.9;

    // Dampen velocity â€” nearly still
    c.vx *= 0.05; c.vy *= 0.05;
    c.x += c.vx; c.y += c.vy;
    if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
    if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;
    c.trail.push({ x: c.x, y: c.y });
    if (c.trail.length > 8) c.trail.shift();

    if (c.sleepTicks <= 0) {
      c.sleeping = false;
      // Re-randomise cooldown each time to prevent synchronised sleep waves
      c.sleepCooldown = 200 + Math.floor(Math.random() * 600);
    }
    c.energy = Math.min(c.energy, 300);
    return; // Skip all other behaviour while asleep
  }

  // Startled â€” flee at max speed for a short burst
  if (c.wakeScatter > 0) {
    c.wakeScatter--;
    // Random scatter direction was set when startled; just let velocity carry
    const spd0 = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
    if (spd0 > c.dna.speed * 2) { c.vx = (c.vx/spd0)*c.dna.speed*2; c.vy = (c.vy/spd0)*c.dna.speed*2; }
  }

  // Tick down sleep cooldown; trigger sleep when it hits zero
  if (c.sleepCooldown > 0) {
    c.sleepCooldown--;
  } else if (!c.matingWith && c.wakeScatter === 0) {
    // Fall asleep: duration 180-360 ticks
    c.sleeping = true;
    c.sleepTicks = 180 + Math.floor(Math.random() * 180);
    c.vx *= 0.1; c.vy *= 0.1;
    c.energy = Math.min(c.energy, 300);
    return;
  }

  // â”€â”€ ACTIVE MATING (creature is purple) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (c.matingWith) {
    const partner = c.matingWith;

    // Safety checks: cancel if partner died, or partner no longer points back (stale link)
    if (!partner.alive || partner.matingWith !== c) {
      c.matingWith = null; c.matingTicks = 0;
    } else {
      // Only the lower-id creature drives the tick counter to avoid double-counting
      if (c.id < partner.id) c.matingTicks++;
      else c.matingTicks = partner.matingTicks; // mirror the master's progress

      // Drift slowly toward partner â€” easy prey for carnivores!
      const dx = partner.x - c.x, dy = partner.y - c.y;
      const d  = Math.sqrt(dx*dx + dy*dy) + 0.001;
      c.vx += (dx/d) * 0.15;
      c.vy += (dy/d) * 0.15;
      const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
      const cap = c.dna.speed * 0.3;
      if (spd > cap) { c.vx = (c.vx/spd)*cap; c.vy = (c.vy/spd)*cap; }
      c.x += c.vx; c.y += c.vy;
      if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
      if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 8) c.trail.shift();

      // Spawn babies at end â€” only the lower-id creature (the "mother") births
      if (c.matingTicks >= MATING_DURATION && c.id < partner.id) {
        const avg = (a, b) => (a + b) / 2;
        const newGen = Math.max(c.gen, partner.gen) + 1;
        generation = Math.max(generation, newGen);
        // 80% = 1 offspring, 15% = 2, 5% = 3
        const roll = Math.random();
        const numOffspring = roll < 0.80 ? 1 : roll < 0.95 ? 2 : 3;
        for (let n = 0; n < numOffspring; n++) {
          const childDNA = mutateDNA({
            type:       c.dna.type,
            speed:      avg(c.dna.speed,      partner.dna.speed),
            sense:      avg(c.dna.sense,      partner.dna.sense),
            size:       avg(c.dna.size,       partner.dna.size),
            fertility:  avg(c.dna.fertility,  partner.dna.fertility),
            metabolism: avg(c.dna.metabolism, partner.dna.metabolism),
            aggression: avg(c.dna.aggression, partner.dna.aggression),
            stamina:    avg(c.dna.stamina ?? 1.0, partner.dna.stamina ?? 1.0),
          });
          const child = createCreature(
            c.dna.type,
            c.x + (Math.random()-0.5)*24,
            c.y + (Math.random()-0.5)*24,
            childDNA
          );
          child.gen = newGen;
          assignSpecies(child); // child may fork new species if sufficiently mutated
          creatures.push(child);
        }
        // Energy cost scales with number of offspring; carnivores pay 50% less
        const baseCost = 30 + numOffspring * 15;
        const costMult = (c.dna.type === 'carnivore' || c.dna.type === 'omnivore') ? 0.5 : 1.0;
        const cost = baseCost * costMult;
        c.energy -= cost; partner.energy -= cost * 0.5;
        c.matingCooldown = 120; partner.matingCooldown = 120;
        c.mateCount++;       // track successful births
        partner.mateCount++; // both parents count it
      }

      // End mating phase for both
      if (c.matingTicks >= MATING_DURATION) {
        partner.matingWith = null; partner.matingTicks = 0;
        c.matingWith       = null; c.matingTicks       = 0;
      }
    }

    c.energy = Math.min(c.energy, 300);
    return; // Skip normal behaviour while mating
  }

  // â”€â”€ NORMAL BEHAVIOUR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  c.trail.push({ x: c.x, y: c.y });
  if (c.trail.length > 8) c.trail.shift();

  const MATE_ENERGY  = 240; // 80% of max 300 â€” required to mate
  const SATED_ENERGY = 270; // 90% of max 300 â€” above this, behaviour shifts
  const MAX_MATES    = c.dna.type === 'herbivore' ? 3 : 5; // carns/omnis retire at 5

  const isSated    = c.energy >= SATED_ENERGY;
  const canMate    = c.matingCooldown === 0 && c.mateCount < MAX_MATES && !c.matingWith;
  const mateElig   = canMate && c.energy >= MATE_ENERGY;

  let tx = null, ty = null;

  if (c.dna.type === 'herbivore') {
    c.status = 'FORAGING';
    // Shepherded herbivores feel protected â€” they don't flee (shepherd provides safety)
    const isShepherded = !!(c._shepherdRef && c._shepherdRef.alive);
    // Always flee carnivores UNLESS currently shepherded
    if (!isShepherded) {
      const fleeRange = isSated ? c.dna.sense * 1.4 : c.dna.sense;
      const predator = gridNearest(c.x, c.y, sgCreatures, fleeRange,
        o => o !== c && o.dna.type === 'carnivore');
      if (predator) {
        const dx = c.x - predator.x, dy = c.y - predator.y;
        const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
        tx = c.x + (dx/d) * (isSated ? 120 : 80);
        ty = c.y + (dy/d) * (isSated ? 120 : 80);
        c.status = 'FLEEING';
      }
    } else {
      c.status = 'SHEPHERDED';
    }
    // Mildly repelled by corpses (smell of death = predator nearby)
    if (tx === null) {
      const corpse = gridNearest(c.x, c.y, sgCorpses, c.dna.sense * 0.5, null);
      if (corpse) {
        const dx = c.x - corpse.x, dy = c.y - corpse.y;
        const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
        tx = c.x + (dx/d) * 40; ty = c.y + (dy/d) * 40;
      }
    }
    // Flee carnivore pheromone trail â€” avoid areas carnivores recently passed through
    // (Herbivores only â€” omnivores don't fear carnivore scent)
    if (tx === null && pheroCarn) {
      const grad = pheroGradient(pheroCarn, c.x, c.y);
      const mag  = Math.sqrt(grad.dx*grad.dx + grad.dy*grad.dy);
      if (mag > 0.02) {
        c.vx -= (grad.dx/mag) * 0.25;
        c.vy -= (grad.dy/mag) * 0.25;
      }
    }
    // Only seek food when NOT sated
    if (tx === null && !isSated) {
      const food = gridNearest(c.x, c.y, sgFoods, c.dna.sense, null);
      if (food) { tx = food.x; ty = food.y; c.status = 'SEEKING FOOD'; }
    }
    // Seek mate when eligible
    if (tx === null && mateElig) {
      const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.8,
        o => o !== c && o.dna.type === 'herbivore' && o.energy >= MATE_ENERGY
          && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
      if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
    }
    if (isSated && tx === null) c.status = 'SATED â€” WANDERING';

  } else if (c.dna.type === 'omnivore') {
    // â”€â”€ OMNIVORE BEHAVIOUR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Dual vision: cone (forward, long) + circle (close, omnidirectional)
    const CONE_RANGE  = c.dna.sense * 1.8;
    const CONE_ARC    = Math.PI / 3;

    c.sprinting = false;
    c.status = 'FORAGING';

    const lists = window._simLists || {};
    const dangerCarn = gridNearest(c.x, c.y, sgCreatures, c.dna.sense,
      o => o !== c && o.dna.type === 'carnivore');

    if (isSated) {
      // SHEPHERDING: attract nearby herbivores to follow
      c.status = 'SHEPHERDING';
      // Seek mates if eligible
      if (mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.8,
          o => o !== c && o.dna.type === 'omnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
    } else {
      // Flee awake carnivores
      if (dangerCarn && !dangerCarn.sleeping) {
        const dx = c.x - dangerCarn.x, dy = c.y - dangerCarn.y;
        const d = Math.sqrt(dx*dx+dy*dy)+0.001;
        tx = c.x + (dx/d)*100; ty = c.y + (dy/d)*100;
        c.status = 'FLEEING CARNIVORE';
      }
      // Scavenge corpses (omnis eat all corpses â€” priority)
      if (tx === null) {
        const nc = gridNearest(c.x, c.y, sgCorpses, c.dna.sense, null);
        if (nc) { tx = nc.x; ty = nc.y; c.packTarget = null; c.status = 'SCAVENGING'; }
      }
      // Eat food like herbivore
      if (tx === null) {
        const food = gridNearest(c.x, c.y, sgFoods, c.dna.sense, null);
        if (food) { tx = food.x; ty = food.y; c.status = 'SEEKING FOOD'; }
      }
      // Seek mate if nothing else
      if (tx === null && mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.5,
          o => o !== c && o.dna.type === 'omnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
      if (tx === null) { c.status = 'WANDERING'; c.packTarget = null; }
    }

  } else {
    // â”€â”€ CARNIVORE BEHAVIOUR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const CONE_RANGE  = c.dna.sense * 2.8;
    const CONE_ARC    = Math.PI / 3;

    c.sprinting = false;
    const lists = window._simLists || {};

    // Avoid safe omnivores â€” keep distance unless sleeping, mating, or <20% energy
    // During FRENZY this avoidance is completely suppressed
    if (frenziedTicks <= 0) {
      const safeOmni = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.7,
        o => o !== c && o.dna.type === 'omnivore' && !o.sleeping && !o.matingWith && o.energy >= 60);
      if (safeOmni) {
        const dx = c.x - safeOmni.x, dy = c.y - safeOmni.y;
        const d = Math.sqrt(dx*dx+dy*dy)+0.001;
        c.vx += (dx/d) * 0.35; c.vy += (dy/d) * 0.35;
      }
    }

    if (isSated) {
      c.status = 'SEEKING MATE';
      if (mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.8,
          o => o !== c && o.dna.type === 'carnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; }
      }
      if (tx === null) c.status = 'SATED â€” WANDERING';
    } else {
      c.status = 'HUNTING';

      // Pack hunting coordination
      let packInterceptX = null, packInterceptY = null;
      for (const pack of (lists.carns || [])) {
        if (pack === c || !pack.packTarget) continue;
        if (dist(c, pack) > c.dna.sense * 1.2) continue;
        const prey = pack.packTarget;
        if (!prey.alive) continue;
        const interceptX = prey.x + prey.vx * 20;
        const interceptY = prey.y + prey.vy * 20;
        if (dist(c, prey) > dist(pack, prey)) {
          packInterceptX = interceptX; packInterceptY = interceptY; break;
        }
      }
      if (packInterceptX !== null) { tx = packInterceptX; ty = packInterceptY; c.status = 'PACK FLANKING'; }

      // Cone prey detection â€” sleeping first (grid-accelerated)
      if (tx === null) {
        const sp = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.sleeping);
        if (sp) { tx = sp.x; ty = sp.y; c.packTarget = sp; c.status = 'STALKING'; }
      }
      // Mating prey
      if (tx === null) {
        const pp = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.matingWith !== null);
        if (pp) { tx = pp.x; ty = pp.y; c.packTarget = pp; c.status = 'HUNTING MATING PREY'; }
      }
      // Cannibalism (weak young carnivore)
      if (tx === null) {
        const wc = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.dna.type === 'carnivore' && o.energy < 30 && o.age < c.age*0.5);
        if (wc) { tx = wc.x; ty = wc.y; c.packTarget = wc; c.status = 'CANNIBALISING'; }
      }
      // Vulnerable omnivore: sleeping, mating, or <10% energy; OR any omnivore during FRENZY
      if (tx === null) {
        const vo = gridInCone(c.x,c.y,c.vx,c.vy, sgCreatures, CONE_RANGE, CONE_ARC,
          o => o !== c && o.alive && o.dna.type === 'omnivore'
            && (frenziedTicks > 0 || o.sleeping || o.matingWith !== null || o.energy < 30));
        if (vo) { tx = vo.x; ty = vo.y; c.packTarget = vo; c.status = frenziedTicks > 0 ? 'FRENZIED HUNT' : 'HUNTING OMNIVORE'; }
      }
      // Corpses (omnidirectional smell)
      if (tx === null) {
        const nc = gridNearest(c.x, c.y, sgCorpses, c.dna.sense, null);
        if (nc) { tx = nc.x; ty = nc.y; c.packTarget = null; c.status = 'SCAVENGING'; }
      }
      // Herbivores in cone â€” grid-accelerated + scored by hunt memory
      if (tx === null) {
        const rawCands = sgCreatures ? sgCreatures.query(c.x, c.y, CONE_RANGE) : [];
        const heading = Math.atan2(c.vy, c.vx);
        const spd = Math.sqrt(c.vx*c.vx+c.vy*c.vy);
        const useCone = spd > 0.1;
        const candidates = rawCands.filter(h => {
          if (!h.alive || h === c || h.dna.type !== 'herbivore') return false;
          if (!useCone) return true;
          const dx = h.x-c.x, dy = h.y-c.y;
          let diff = Math.atan2(dy,dx) - heading;
          while (diff >  Math.PI) diff -= 2*Math.PI;
          while (diff < -Math.PI) diff += 2*Math.PI;
          return Math.abs(diff) <= CONE_ARC;
        });
        if (candidates.length > 0) {
          // Score each by success rate + proximity; experienced hunters chase the right prey
          let best = null, bestScore = -1;
          for (const h of candidates) {
            const rate = huntSuccessRate(c, 'herbivore');
            const proximity = 1 - dist(c, h) / CONE_RANGE;
            // Intelligence factor: weight success rate more heavily with age
            const intFactor = Math.min(1, c.age / 800);
            const score = proximity * (1 - intFactor) + rate * intFactor * proximity;
            if (score > bestScore) { bestScore = score; best = h; }
          }
          if (best) { tx = best.x; ty = best.y; c.packTarget = best; c.status = 'CHASING'; }
        }
      }
      // Follow pheromone trails when no direct target
      if (tx === null && (pheroHerb || pheroOmni)) {
        // Combine herb (full) + omni (60%) gradient signals
        let gdx = 0, gdy = 0;
        if (pheroHerb) { const g = pheroGradient(pheroHerb, c.x, c.y); gdx += g.dx; gdy += g.dy; }
        if (pheroOmni) { const g = pheroGradient(pheroOmni, c.x, c.y); gdx += g.dx * 0.6; gdy += g.dy * 0.6; }
        const mag = Math.sqrt(gdx*gdx + gdy*gdy);
        if (mag > 0.03) {
          c.vx += (gdx/mag) * 0.3; c.vy += (gdy/mag) * 0.3;
          c.packTarget = null; c.status = 'TRACKING SCENT';
        } else { c.packTarget = null; c.status = 'PATROLLING'; }
      } else if (tx === null) { c.packTarget = null; c.status = 'PATROLLING'; }

      if (tx === null && mateElig) {
        const mate = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 0.5,
          o => o !== c && o.dna.type === 'carnivore' && o.energy >= MATE_ENERGY
            && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
    }
  }

  // Memory-biased wandering: drift toward last known food patch when no other goal
  if (tx !== null) {
    const dx = tx - c.x, dy = ty - c.y;
    const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
    c.vx += (dx/d) * 0.4; c.vy += (dy/d) * 0.4;
  } else if ((c.dna.type === 'herbivore' || c.dna.type === 'omnivore')
             && c.memFoodX !== null && c.memFoodAge < 400) {
    // Bias toward remembered food patch; strength fades with time
    const memStr = Math.max(0, 1 - c.memFoodAge / 400) * 0.25;
    const dx = c.memFoodX - c.x, dy = c.memFoodY - c.y;
    const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
    c.vx += (dx/d) * memStr; c.vy += (dy/d) * memStr;
    c.vx += (Math.random()-0.5) * 0.3; c.vy += (Math.random()-0.5) * 0.3;
  } else {
    c.vx += (Math.random()-0.5) * 0.5; c.vy += (Math.random()-0.5) * 0.5;
  }

  // â”€â”€ FLOCKING (Boids) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const flockRadius = c.dna.sense * 0.6;
  const sepRadius   = c.dna.size * 3.5;

  let sepX = 0, sepY = 0, sepN = 0;
  let aliX = 0, aliY = 0, aliN = 0;
  let cohX = 0, cohY = 0, cohN = 0;

  // Use spatial grid â€” only checks nearby cells instead of all creatures
  const flockNeighbours = sgCreatures ? sgCreatures.query(c.x, c.y, flockRadius) : [];
  for (const o of flockNeighbours) {
    if (o === c || o.sleeping || o.dna.type !== c.dna.type) continue;
    const dx = o.x - c.x, dy = o.y - c.y;
    const d2 = dx*dx + dy*dy;
    const d = Math.sqrt(d2) + 0.001;

    // Separation â€” push away from very close neighbours
    if (d < sepRadius) {
      sepX -= dx / d; sepY -= dy / d;
      sepN++;
    }
    // Alignment â€” match velocity of neighbours
    aliX += o.vx; aliY += o.vy; aliN++;
    // Cohesion â€” move toward centre of neighbours
    cohX += o.x; cohY += o.y; cohN++;
  }

  const fs = params.flockStr / 10;
  if (c.dna.type === 'herbivore') {
    // Herbivore flocking â€” safety in numbers
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.35 * fs; c.vy += (sepY/sepN) * 0.35 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.08 * fs; c.vy += (aliY/aliN - c.vy) * 0.08 * fs; }
    if (cohN > 0) {
      const cx = cohX/cohN - c.x, cy = cohY/cohN - c.y;
      const cd = Math.sqrt(cx*cx+cy*cy)+0.001;
      if (tx === null) { c.vx += (cx/cd) * 0.12 * fs; c.vy += (cy/cd) * 0.12 * fs; }
    }
    // Shepherd pull: if a nearby sated omnivore is shepherding, be drawn toward it
    const lists = window._simLists || {};
    const shepherd = gridNearest(c.x, c.y, sgCreatures, c.dna.sense * 1.6,
      o => o !== c && o.dna.type === 'omnivore' && o.alive && o.energy >= 270);
    if (shepherd) {
      const sdx = shepherd.x - c.x, sdy = shepherd.y - c.y;
      const sd  = Math.sqrt(sdx*sdx+sdy*sdy)+0.001;
      // Don't pull toward shepherd if already mid-flee (shepherd pull irrelevant)
      if (c.status !== 'FLEEING') {
        const shepherdPull = fs * 0.22;
        c.vx += (sdx/sd) * shepherdPull; c.vy += (sdy/sd) * shepherdPull;
      }
      // Shepherded herbivores share the omnivore's cone vision range (boosted)
      c._shepherdRef  = shepherd; // keep reference so we can draw the distinction
      c._shepherdVision = shepherd.dna.sense * 2.4;
    } else {
      c._shepherdVision = null;
      c._shepherdRef    = null;
    }
  } else if (c.dna.type === 'omnivore') {
    // Omnivores flock loosely with own kind â€” mild separation only
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.3 * fs; c.vy += (sepY/sepN) * 0.3 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.05 * fs; c.vy += (aliY/aliN - c.vy) * 0.05 * fs; }
  } else {
    // Carnivores spread out
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.5 * fs; c.vy += (sepY/sepN) * 0.5 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.04 * fs; c.vy += (aliY/aliN - c.vy) * 0.04 * fs; }
  }

  // Sprint: carnivores/omnivores chasing prey burn ENERGY for speed boost
  // stamina gene = efficiency multiplier; low stamina = more energy per sprint tick
  let maxSpd = c.dna.speed;
  const canSprint = (c.dna.type === 'carnivore' || c.dna.type === 'omnivore')
                    && tx !== null && c.energy > 75  // need >25% energy to sprint
                    && (c.status === 'CHASING' || c.status === 'STALKING'
                        || c.status === 'PACK FLANKING' || c.status === 'HUNTING MATING PREY'
                        || c.status === 'CANNIBALISING');
  if (canSprint) {
    maxSpd = c.dna.speed * 1.6;
    // Energy cost: base 0.08 per tick, divided by stamina gene (0.1â€“1.0)
    // Low stamina = more expensive sprint; high stamina = efficient
    const sprintCost = 0.08 / Math.max(0.1, c.dna.stamina);
    c.energy -= sprintCost;
    c.sprinting = true;
  }

  const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
  if (spd > maxSpd) { c.vx = (c.vx/spd)*maxSpd; c.vy = (c.vy/spd)*maxSpd; }
  c.x += c.vx; c.y += c.vy;
  if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
  if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

  // Herbivores and omnivores eat food when below sated threshold
  if ((c.dna.type === 'herbivore' || c.dna.type === 'omnivore') && !isSated) {
    for (let i = foods.length - 1; i >= 0; i--) {
      if (dist(c, foods[i]) < c.dna.size + 4) {
        if (foods[i].toxic) {
          // Toxic food: drains energy instead of restoring it
          c.energy -= foods[i].energy * 0.8;
        } else {
          c.energy += foods[i].energy;
        }
        // Record memory of this food location (even if toxic â€” they learn)
        c.memFoodX = foods[i].x; c.memFoodY = foods[i].y; c.memFoodAge = 0;
        foods.splice(i, 1);
        break;
      }
    }
  }
  // Age memory each tick
  if (c.memFoodX !== null) c.memFoodAge++;
  // Omnivores scavenge corpses (all types)
  if (c.dna.type === 'omnivore' && !isSated) {
    for (let i = corpses.length - 1; i >= 0; i--) {
      if (dist(c, corpses[i]) < c.dna.size + 5) {
        c.energy += corpses[i].energy;
        corpses.splice(i, 1);
        break;
      }
    }
  }

  // Carnivores hunt ONLY when below sated threshold (90%)
  if (c.dna.type === 'carnivore' && !isSated) {
    // Record hunt attempt periodically while actively chasing
    if (c.packTarget && c.packTarget.alive && c.age % 60 === 0) {
      const pKey = c.packTarget.dna.type + (c.packTarget.sleeping ? '_sleep' : c.packTarget.matingWith ? '_mating' : '');
      c.memHuntAttempts[pKey] = (c.memHuntAttempts[pKey] || 0) + 1;
    }
    let ate = false;
    for (const prey of creatures) {
      if (!prey.alive || prey === c) continue;
      const isPurple       = prey.matingWith !== null;
      const isHerbivore    = prey.dna.type === 'herbivore';
      const isSleeping     = prey.sleeping;
      const isWeakCarnivore = prey.dna.type === 'carnivore'
                              && prey.energy < 30 && prey.age < c.age * 0.5;
      const isVulnOmnivore = prey.dna.type === 'omnivore'
                              && (frenziedTicks > 0 || prey.sleeping || prey.matingWith !== null || prey.energy < 30);
      const edible = isPurple || isHerbivore || (isSleeping && prey !== c) || isWeakCarnivore || isVulnOmnivore;
      if (edible && dist(c, prey) < c.dna.size + prey.dna.size) {
        c.energy += prey.energy * 0.6;
        if (prey.matingWith) { prey.matingWith.matingWith = null; prey.matingWith.matingTicks = 0; }
        // Wake nearby sleepers if this prey was asleep
        if (prey.sleeping) {
          for (const neighbour of creatures) {
            if (neighbour !== prey && neighbour.sleeping && dist(neighbour, prey) < neighbour.dna.sense) {
              neighbour.sleeping = false;
              neighbour.sleepTicks = 0;
              neighbour.sleepCooldown = 400 + Math.floor(Math.random() * 300);
              // Scatter in random direction at high speed
              const ang = Math.random() * Math.PI * 2;
              neighbour.vx = Math.cos(ang) * neighbour.dna.speed * 2;
              neighbour.vy = Math.sin(ang) * neighbour.dna.speed * 2;
              neighbour.wakeScatter = 60;
            }
          }
        }
        // Record successful hunt in memory
        const pKey = prey.dna.type + (prey.sleeping ? '_sleep' : prey.matingWith ? '_mating' : '');
        c.memHuntWins[pKey]    = (c.memHuntWins[pKey]    || 0) + 1;
        c.memHuntAttempts[pKey]= (c.memHuntAttempts[pKey]|| 0) + 1;
        prey.alive = false;
        ate = true;
        break;
      }
    }
    // Also scavenge nearby corpses
    if (!ate) {
      for (let i = corpses.length - 1; i >= 0; i--) {
        if (dist(c, corpses[i]) < c.dna.size + 5) {
          c.energy += corpses[i].energy;
          corpses.splice(i, 1);
          break;
        }
      }
    }
  }

  // Initiate mating â€” requires 80%+ energy, under retirement limit, not sleeping
  if (mateElig && !c.sleeping && c.wakeScatter === 0) {
    const lists = window._simLists || {};
    const sameType = (c.dna.type === 'herbivore' ? lists.herbs
                    : c.dna.type === 'carnivore' ? lists.carns
                    : lists.omnis) || [];
    for (const other of sameType) {
      if (other === c || other.matingWith || other.matingCooldown > 0) continue;
      const otherMax = other.dna.type === 'herbivore' ? 3 : 5;
      if (other.mateCount >= otherMax || other.energy < MATE_ENERGY) continue;
      if (dist(c, other) < c.dna.size + other.dna.size + 5) {
        c.matingWith = other; c.matingTicks = 0;
        other.matingWith = c; other.matingTicks = 0;
        break;
      }
    }
  }

  c.energy = Math.min(c.energy, 300);
}

function updateSim() {
  tick++;

  // â”€â”€ Seasons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (longWinterActive) {
    longWinterTicks--;
    if (longWinterTicks <= 0) {
      longWinterActive = false;
      showWeatherBanner('â„ï¸ LONG WINTER ENDS', '#a0b4f0', 120, 'The thaw has finally come.');
      document.getElementById('longWinterBtn').classList.remove('active-event');
    }
  } else {
    seasonTick++;
    if (seasonTick >= SEASON_LENGTH) {
      seasonTick = 0;
      currentSeasonIdx = (currentSeasonIdx + 1) % 4;
      const ns = SEASONS[currentSeasonIdx];
      const seasonDescs = {
        SPRING: 'Food blooms. Population surges incoming.',
        SUMMER: 'Balanced conditions. The ecosystem breathes.',
        AUTUMN: 'Food slows. Prepare for harder times.',
        WINTER: 'Scarce food. High drain. Only the strong endure.',
      };
      showWeatherBanner(ns.emoji + ' ' + ns.name, ns.color, 180, seasonDescs[ns.name]);
    }
  }

  // â”€â”€ Weather events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (activeWeather) {
    activeWeather.ticksLeft--;
    if (activeWeather.ticksLeft <= 0) {
      const endedName = activeWeather.event.name;
      activeWeather = null;
      toxicRainActive = false;
      weatherCooldown = 600 + Math.floor(Math.random() * 800);
      showWeatherBanner('EVENT ENDED', '#8899bb', 80, endedName + ' HAS PASSED');
      updateDeusWeatherButtons();
    }
  } else if (randomWeatherEnabled) {
    if (weatherCooldown > 0) { weatherCooldown--; }
    else {
      // Only trigger certain events in matching seasons
      const ev = WEATHER_EVENTS[Math.floor(Math.random() * WEATHER_EVENTS.length)];
      const s = SEASONS[currentSeasonIdx].name;
      const valid = (ev.name === 'BLIZZARD' && (s === 'WINTER' || s === 'AUTUMN'))
                 || (ev.name === 'DROUGHT'  && (s === 'SUMMER' || s === 'AUTUMN'))
                 || (ev.name === 'FEEDING FRENZY' && (s === 'SPRING' || s === 'SUMMER'))
                 || (ev.name === 'PLAGUE WIND')
                 || (ev.name === 'TOXIC RAIN');
      if (valid) {
        activeWeather = { event: ev, ticksLeft: ev.duration };
        toxicRainActive = ev.name === 'TOXIC RAIN';
        showWeatherBanner(ev.emoji + ' ' + ev.name, ev.color, ev.duration, ev.desc);
        updateDeusWeatherButtons();
      } else {
        weatherCooldown = 200; // retry soon
      }
    }
  }

  // â”€â”€ Frenzy tick â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (frenziedTicks > 0) {
    frenziedTicks--;
    if (frenziedTicks === 0) {
      showWeatherBanner('ğŸ©¸ FRENZY ENDS', '#ff4d6d', 60, 'Carnivores return to normal behaviour.');
      document.getElementById('frenzyCBtn').classList.remove('active-event');
    }
  }

  // Effective multipliers = season * weather (if active)
  const season = getCurrentSeason();
  const weatherFoodMult = activeWeather ? activeWeather.event.foodMult : 1.0;
  const weatherMetaMult = activeWeather ? activeWeather.event.metaMult : 1.0;
  const effectiveFoodMult = season.foodMult * weatherFoodMult;
  const effectiveMetaMult = season.metaMult * weatherMetaMult;
  // Store on window so creature update can access
  window._seasonMetaMult = effectiveMetaMult;

  // Food grows by spreading from existing food â€” no random teleport spawning
  if (foods.length < params.maxFood && foods.length > 0) {
    // Each tick, each food pellet has a small chance to sprout a neighbour nearby
    const growthChance = params.foodRate * 0.0003 * effectiveFoodMult; // slider controls spread speed
    for (let i = 0; i < foods.length && foods.length < params.maxFood; i++) {
      if (Math.random() < growthChance) {
        const parent = foods[i];
        // Spread radius: closer neighbours more likely, max 60px
        const angle = Math.random() * Math.PI * 2;
        const r = 10 + Math.random() * 50;
        const nx = parent.x + Math.cos(angle) * r;
        const ny = parent.y + Math.sin(angle) * r;
        // Only sprout if within canvas bounds and not in a crater
        if (nx > 0 && nx < canvas.width && ny > 0 && ny < canvas.height) {
          const inCrater = craters.some(cr => {
            const dx = nx - cr.x, dy = ny - cr.y;
            return dx*dx + dy*dy < cr.r * cr.r;
          });
          if (!inCrater) foods.push(createFood(nx, ny, toxicRainActive));
        }
      }
    }
  }

  // Seeds disperse food based on foodRate, then expire
  for (let i = seeds.length - 1; i >= 0; i--) {
    const s = seeds[i];
    s.age++;
    if (foods.length < params.maxFood) {
      // Use the same growth chance as normal food spread, but slightly boosted
      const seedChance = params.foodRate * 0.0005 * effectiveFoodMult;
      if (Math.random() < seedChance) {
        const angle = Math.random() * Math.PI * 2;
        const r = 8 + Math.random() * 60;
        const nx = s.x + Math.cos(angle) * r;
        const ny = s.y + Math.sin(angle) * r;
        if (nx > 0 && nx < canvas.width && ny > 0 && ny < canvas.height) {
          const inCrater = craters.some(cr => {
            const dx = nx - cr.x, dy = ny - cr.y;
            return dx*dx + dy*dy < cr.r * cr.r;
          });
          if (!inCrater) { foods.push(createFood(nx, ny, toxicRainActive)); s.spawned++; }
        }
      }
    }
    if (s.spawned >= s.budget) seeds.splice(i, 1);
  }

  // Deposit pheromones â€” alive, non-sleeping agents leave scent trails
  if (pheroHerb && pheroCarn) {
    for (const c of creatures) {
      if (!c.alive || c.sleeping) continue;
      if (c.dna.type === 'herbivore') depositPhero(pheroHerb, c.x, c.y, 0.18);
      else if (c.dna.type === 'carnivore') depositPhero(pheroCarn, c.x, c.y, 0.18);
      // Omnivores deposit on their own channel â€” distinct cyan, carnivores can still track
      else if (c.dna.type === 'omnivore') depositPhero(pheroOmni, c.x, c.y, 0.18);
    }
    // Diffuse only every 3 ticks â€” evaporation is slow enough that this is imperceptible
    if (tick % 3 === 0) {
      updatePhero(pheroHerb);
      updatePhero(pheroCarn);
      updatePhero(pheroOmni);
    }
    pheroNeedsRedraw = true; // deposits happened, mark dirty
  }

  // Pre-build filtered lists once per tick for performance
  const _alive      = creatures.filter(c => c.alive);
  const _herbs      = _alive.filter(c => c.dna.type === 'herbivore');
  const _carns      = _alive.filter(c => c.dna.type === 'carnivore');
  const _omnis      = _alive.filter(c => c.dna.type === 'omnivore');
  const _mating     = _alive.filter(c => c.matingWith !== null);
  const _sleeping   = _alive.filter(c => c.sleeping);
  window._simLists  = { alive: _alive, herbs: _herbs, carns: _carns, omnis: _omnis, mating: _mating, sleeping: _sleeping };

  // â”€â”€ Meteors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let mi = meteors.length - 1; mi >= 0; mi--) {
    const m = meteors[mi];
    m.countdown--;
    if (m.countdown <= 0) {
      // IMPACT â€” kill creatures in radius, remove food, leave crater
      for (const c of creatures) {
        if (!c.alive) continue;
        const dx = c.x - m.x, dy = c.y - m.y;
        if (dx*dx + dy*dy < METEOR_RADIUS * METEOR_RADIUS) {
          c.alive = false;
          corpses.push({ x: c.x, y: c.y, energy: 0, decay: 0, fromType: c.dna.type });
        }
      }
      // Remove food in blast zone
      foods = foods.filter(f => {
        const dx = f.x - m.x, dy = f.y - m.y;
        return dx*dx + dy*dy >= METEOR_RADIUS * METEOR_RADIUS;
      });
      // Add crater
      craters.push({ x: m.x, y: m.y, r: METEOR_RADIUS, age: 0 });
      meteors.splice(mi, 1);
    }
  }

  // Age and expire craters
  for (let ci = craters.length - 1; ci >= 0; ci--) {
    craters[ci].age++;
    if (craters[ci].age > CRATER_DURATION) craters.splice(ci, 1);
  }

  rebuildGrids(); // spatial index for O(1) neighbour queries this tick
  for (const c of creatures) updateCreature(c);

  // Decay corpses over time
  for (const corp of corpses) {
    corp.decay++;
    // Fresh corpses keep emitting scent â€” re-deposit each tick, fading with age
    if (corp.decay % 8 === 0 && corp.decay < 300) {
      const strength = (1 - corp.decay / 600) * 0.18;
      if (pheroCarn) depositPhero(pheroCarn, corp.x, corp.y, strength);
      if (pheroOmni) depositPhero(pheroOmni, corp.x, corp.y, strength * 0.7);
    }
  }
  corpses = corpses.filter(corp => corp.decay < 600); // 2Ã— longer life

  creatures = creatures.filter(c => c.alive || (c.age++ < 60));

  // Soft density cap â€” overcrowding raises metabolism rather than killing randomly
  // This creates natural pressure without sudden die-offs
  const hCount = creatures.filter(c => c.alive && c.dna.type === 'herbivore').length;
  const cCount = creatures.filter(c => c.alive && c.dna.type === 'carnivore').length;
  const oCount = creatures.filter(c => c.alive && c.dna.type === 'omnivore').length;
  if (hCount > 150 || cCount > 60 || oCount > 80) {
    for (const c of creatures) {
      if (!c.alive) continue;
      const cnt = c.dna.type === 'herbivore' ? hCount
                : c.dna.type === 'carnivore' ? cCount : oCount;
      const cap = c.dna.type === 'herbivore' ? 150
                : c.dna.type === 'carnivore' ? 60 : 80;
      if (cnt > cap) {
        const overRatio = Math.min(1, (cnt - cap) / cap);
        c.energy -= 0.03 * overRatio; // flat density penalty // extra pressure proportional to overcrowding
      }
    }
  }
  // Hard failsafe â€” only kicks in at extreme numbers to prevent memory issues
  if (creatures.filter(c => c.alive).length > 600)
    creatures = creatures.filter(c => !c.alive || Math.random() > 0.05);

  if (tick % 300 === 0) updateSpeciesCentroids();

  if (tick % 60 === 0) {
    const alive = creatures.filter(c => c.alive);
    history.h.push(alive.filter(c => c.dna.type === 'herbivore').length);
    history.c.push(alive.filter(c => c.dna.type === 'carnivore').length);
    history.o.push(alive.filter(c => c.dna.type === 'omnivore').length);
    history.f.push(foods.length);
    if (history.h.length > MAX_HISTORY) { history.h.shift(); history.c.shift(); history.o.shift(); history.f.shift(); }
  }
}

// â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Draw a polygon or circle at cx,cy with radius r
// sides=0 â†’ circle, sides=4 â†’ diamond, sides=N â†’ regular polygon
function drawShape(ctx2, cx, cy, r, sides) {
  ctx2.beginPath();
  if (sides === 0) {
    ctx2.arc(cx, cy, r, 0, Math.PI * 2);
  } else if (sides === 4) {
    // Diamond (pointed top/bottom)
    ctx2.moveTo(cx,     cy - r * 1.3);
    ctx2.lineTo(cx + r, cy);
    ctx2.lineTo(cx,     cy + r * 1.3);
    ctx2.lineTo(cx - r, cy);
    ctx2.closePath();
  } else {
    // Regular polygon (hexagon=6, triangle=3, pentagon=5 etc.)
    for (let i = 0; i < sides; i++) {
      const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
      const px = cx + Math.cos(angle) * r;
      const py = cy + Math.sin(angle) * r;
      i === 0 ? ctx2.moveTo(px, py) : ctx2.lineTo(px, py);
    }
    ctx2.closePath();
  }
}

function drawCreature(c) {
  const alive = c.alive;
  const alpha = alive ? 1.0 : Math.max(0, 1 - (c.age - 3940) / 60);
  if (alpha <= 0) return;
  // Viewport culling: skip expensive drawing for off-screen creatures
  const cullR = c.dna.size * 4 + 12; // generous margin for glow/ring
  if (c.x + cullR < 0 || c.x - cullR > canvas.width ||
      c.y + cullR < 0 || c.y - cullR > canvas.height) return;

  const isH      = c.dna.type === 'herbivore';
  const isO      = c.dna.type === 'omnivore';
  const isMating = alive && c.matingWith !== null;
  const r        = c.dna.size;

  // Energy-based brightness/saturation: 20% min -> 100% at full energy
  const ePct = alive ? Math.max(0, Math.min(1, c.energy / 300)) : 0;
  const sat  = Math.round(30 + ePct * 70);  // 30%â€“100% saturation
  const lit  = Math.round(20 + ePct * 45);  // 20%â€“65% lightness

  // Base hue per type: mating=267(purple), herbivore=168(teal), carnivore=348(red)
  const isSleepingDraw = alive && c.sleeping;
  const hue = isMating ? 267 : isSleepingDraw ? 220 : (isH ? 168 : isO ? 205 : 348);
  // glowRGB per type for rgba() calls
  const typeGlowRGB = isH ? '0,245,196' : isO ? '0,170,180' : '255,77,109';
  const baseColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#2a2a3a';
  const glowColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#444';
  // Extract approximate RGB for rgba() glow uses
  const glowRGB    = alive ? (isMating ? '162,155,254' : typeGlowRGB) : '68,68,68';
  const trailColor = isMating ? `hsla(267,${sat}%,${lit}%,0.2)` : `hsla(${hue},${sat}%,${lit}%,0.15)`;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Trail â€” fades from transparent at oldest point to full opacity at head
  const nearViewport = c.x > -40 && c.x < canvas.width+40 && c.y > -40 && c.y < canvas.height+40;
  if (alive && c.trail.length > 1 && nearViewport) {
    const tLen = c.trail.length;
    for (let i = 1; i < tLen; i++) {
      const a = c.trail[i - 1];
      const b = c.trail[i];
      // Skip wrap-around segments (toroidal world edge crossings)
      if (Math.abs(b.x - a.x) > canvas.width / 2 || Math.abs(b.y - a.y) > canvas.height / 2) continue;
      const segAlpha = (i / tLen) * 0.22; // fades to near-zero at tail
      ctx.strokeStyle = isMating
        ? `hsla(267,${sat}%,${lit}%,${segAlpha})`
        : `hsla(${hue},${sat}%,${lit}%,${segAlpha})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }
  }

  // Vision indicator (selected only)
  if (c === selectedCreature && alive) {
    const heading = Math.atan2(c.vy, c.vx);
    ctx.setLineDash([3, 5]);
    if (isH) {
      // Own sense circle â€” always shown at agent's actual range
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.15)`; ctx.lineWidth = 1; ctx.stroke();
      // Shepherd-boosted vision â€” outer ring in omnivore cyan, dashed, translucent
      if (c._shepherdVision) {
        ctx.setLineDash([5, 7]);
        ctx.beginPath(); ctx.arc(c.x, c.y, c._shepherdVision, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0,220,255,0.22)`;
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([3, 5]); // restore for rest of vision block
      }
    } else if (isO) {
      // Omnivore: cone + circle (dual)
      const coneRange = c.dna.sense * 1.8;
      ctx.beginPath(); ctx.moveTo(c.x, c.y);
      ctx.arc(c.x, c.y, coneRange, heading - Math.PI/3, heading + Math.PI/3);
      ctx.closePath();
      ctx.strokeStyle = `rgba(${glowRGB},0.12)`; ctx.fillStyle = `rgba(${glowRGB},0.04)`;
      ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense * 0.6, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.08)`; ctx.setLineDash([2,6]); ctx.stroke();
    } else {
      // Carnivore: cone only
      const coneRange = c.dna.sense * 1.8;
      ctx.beginPath(); ctx.moveTo(c.x, c.y);
      ctx.arc(c.x, c.y, coneRange, heading - Math.PI/3, heading + Math.PI/3);
      ctx.closePath();
      ctx.strokeStyle = `rgba(${glowRGB},0.12)`; ctx.fillStyle = `rgba(${glowRGB},0.04)`;
      ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
      ctx.setLineDash([2,6]);
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense * 0.4, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.07)`; ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  // Sleep indicator: zzz rings when asleep
  if (alive && c.sleeping) {
    ctx.save();
    ctx.globalAlpha = (alpha * 0.6);
    // Pulsing outer ring in dim blue-grey
    const pulse = 0.5 + 0.5 * Math.sin(tick * 0.08);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + pulse * 4, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(120,140,200,${0.4 + pulse * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([3, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
    // Tiny 'z' indicators floating upward
    for (let z = 0; z < 3; z++) {
      const zAge = (tick + z * 30) % 90;
      const zAlpha = zAge < 45 ? zAge / 45 : (90 - zAge) / 45;
      const zY = c.y - r - 6 - zAge * 0.25;
      const zX = c.x + r + 2 + z * 4;
      ctx.globalAlpha = alpha * zAlpha * 0.7;
      ctx.fillStyle = 'rgba(160,180,240,1)';
      ctx.font = `${7 + z}px monospace`;
      ctx.fillText('z', zX, zY);
    }
    ctx.restore();
  }

  // Mating pulse ring + progress arc
  if (isMating) {
    const progress = c.matingTicks / MATING_DURATION;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + Math.sin(tick * 0.25) * 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(162,155,254,${0.25 + progress * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 9, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
    ctx.strokeStyle = 'rgba(162,155,254,0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Outer glow â€” dimmed for sated omnivores so shepherd ring reads clearly
  if (alive) {
    const glowA = (isO && c.energy >= 270) ? 0.12 : 0.3;
    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r * 3);
    g.addColorStop(0, `rgba(${glowRGB},${glowA})`);
    g.addColorStop(1, `rgba(${glowRGB},0)`);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r * 3, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
  }

  // Body â€” shape determined by species (colour stays type-based)
  const sp = c.speciesId ? speciesRegistry[c.speciesId] : null;
  const bodyShape = sp ? sp.shape : (isH ? 6 : isO ? 0 : 4);
  ctx.beginPath();
  drawShape(ctx, c.x, c.y, r, bodyShape);

  if (alive) {
    ctx.fillStyle = baseColor;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = isMating ? 14 : 8;
    ctx.fill();
    ctx.shadowBlur = 0;
  } else {
    ctx.fillStyle = '#1a1a2a';
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }


  // Shepherding indicator ring (omnivore, sated) â€” drawn AFTER body so it's separate from icon
  if (alive && isO && c.energy >= 270) {
    ctx.save();
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    // Main transparency knob for the ring (independent of the icon)
    ctx.globalAlpha = alpha * 0.18;

    const rr = r * 7.0 + Math.sin(tick * 0.05) * 2;
    ctx.setLineDash([5, 8]);
    ctx.lineCap = 'round';

    // Dark under-stroke to visually separate it from glow/background
    ctx.beginPath();
    ctx.arc(c.x, c.y, rr, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,0,0,0.75)';
    ctx.lineWidth = 2.6;
    ctx.stroke();

    // Cyan ring on top
    ctx.beginPath();
    ctx.arc(c.x, c.y, rr, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,220,255,1)';
    ctx.lineWidth = 1.1;
    ctx.stroke();

    ctx.setLineDash([]);
    ctx.restore();
  }

  // (duplicate shepherd ring removed)

  // Direction nub + sprint streak
  if (alive) {
    const angle = Math.atan2(c.vy, c.vx);
    if (c.sprinting) {
      // Orange motion streak behind the carnivore
      ctx.beginPath();
      ctx.moveTo(c.x, c.y);
      ctx.lineTo(c.x - Math.cos(angle) * r * 4, c.y - Math.sin(angle) * r * 4);
      ctx.strokeStyle = `rgba(255,160,50,${0.3 + (c.dna.stamina ?? 1.0) * 0.4})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x + Math.cos(angle) * r * 1.8, c.y + Math.sin(angle) * r * 1.8);
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Energy bar
  if (alive) {
    const bw = r * 2.5, bh = 2;
    const bx = c.x - bw/2, by = c.y + r + 3;
    const pct = Math.min(1, c.energy / 300);
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = isMating ? '#a29bfe'
                  : pct > 0.5 ? '#00f5c4'
                  : pct > 0.25 ? '#ffd166' : '#ff4d6d';
    ctx.fillRect(bx, by, bw * pct, bh);
  }

  // Status icons â€” floating above creature
  if (alive) {
    const iconY = c.y - r - 10;
    ctx.shadowBlur = 0;
    ctx.font = `${Math.max(8, r * 0.9)}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    const ePct = c.energy / 300;
    if (ePct < 0.20 && !c.sleeping && !isMating) {
      // Skull warning for critically low energy
      const pulse2 = 0.5 + 0.5 * Math.sin(tick * 0.2);
      ctx.globalAlpha = alpha * (0.7 + pulse2 * 0.3);
      ctx.fillStyle = '#ff4d6d';
      ctx.fillText('ğŸ’€', c.x, iconY);
    } else if (c.sprinting) {
      ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = '#ffa032';
      ctx.fillText('âš¡', c.x, iconY);
    } else if (c.status === 'SEEKING MATE' || c.status === 'SATED â€” WANDERING') {
      ctx.globalAlpha = alpha * 0.75;
      ctx.fillText('â¤ï¸', c.x, iconY);
    }
  }

  // Selected species highlight ring
  if (alive && selectedSpeciesId && c.speciesId === selectedSpeciesId) {
    const pulse3 = 0.5 + 0.5 * Math.sin(tick * 0.15);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 6 + pulse3 * 4, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,209,102,${0.55 + pulse3 * 0.35})`;
    ctx.lineWidth = 2;
    ctx.shadowColor = 'rgba(255,209,102,0.8)';
    ctx.shadowBlur = 8;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // Champion crown ring
  if (alive && c.champion) {
    const pulse4 = 0.5 + 0.5 * Math.sin(tick * 0.1);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 10 + pulse4 * 4, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,215,0,${0.7 + pulse4 * 0.3})`;
    ctx.lineWidth = 2.5;
    ctx.shadowColor = 'rgba(255,215,0,1)';
    ctx.shadowBlur = 12;
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.font = `${r + 4}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.globalAlpha = alpha * 0.9;
    ctx.fillText('ğŸ‘‘', c.x, c.y - r - 12);
  }

  // Frenzy glow for carnivores
  if (alive && frenziedTicks > 0 && c.dna.type === 'carnivore') {
    const pulse5 = 0.5 + 0.5 * Math.sin(tick * 0.25 + c.x);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 4 + pulse5 * 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,30,60,${0.4 + pulse5 * 0.4})`;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = 'rgba(255,30,60,0.9)';
    ctx.shadowBlur = 10;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  ctx.restore();
}

function drawSeed(s) {
  const progress = Math.min(1, s.spawned / s.budget);
  const alpha = 1 - progress * 0.5; // fades as it exhausts
  const pulse = 0.7 + 0.3 * Math.sin(tick * 0.04 + s.x);
  ctx.save();
  ctx.globalAlpha = alpha;
  // Outer glow ring
  ctx.beginPath();
  ctx.arc(s.x, s.y, 7 * pulse, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(40,160,50,0.45)`;
  ctx.lineWidth = 1.5;
  ctx.setLineDash([3, 4]);
  ctx.stroke();
  ctx.setLineDash([]);
  // Core
  ctx.beginPath();
  ctx.arc(s.x, s.y, 3.5, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(120,60%,${28 - progress*10}%)`; // dark green
  ctx.shadowColor = '#2d8a30';
  ctx.shadowBlur = 8;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Small progress tick marks around ring (how much budget remains)
  const ticks = 8;
  for (let i = 0; i < ticks; i++) {
    const filled = i / ticks < (1 - progress);
    if (!filled) continue;
    const a = (i / ticks) * Math.PI * 2 - Math.PI / 2;
    ctx.beginPath();
    ctx.moveTo(s.x + Math.cos(a)*5, s.y + Math.sin(a)*5);
    ctx.lineTo(s.x + Math.cos(a)*7, s.y + Math.sin(a)*7);
    ctx.strokeStyle = `rgba(60,200,70,0.7)`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  ctx.restore();
}

function drawFood(f) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
  if (f.toxic) {
    ctx.fillStyle = '#84cc16';
    ctx.shadowColor = '#a3e635';
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Tiny drip indicator above
    ctx.beginPath();
    ctx.arc(f.x, f.y - 4, 1.2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(163,230,53,0.6)';
    ctx.fill();
  } else {
    ctx.fillStyle = '#ffd166';
    ctx.shadowColor = '#ffd166';
    ctx.shadowBlur = 6;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Inner specular highlight â€” jewel effect
    ctx.beginPath();
    ctx.arc(f.x - 0.8, f.y - 0.8, 1.1, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,220,0.55)';
    ctx.fill();
  }
  ctx.restore();
}

function drawCorpse(corp) {
  const age = corp.decay / 600; // 0=fresh, 1=gone â€” matches 600-tick lifetime
  const alpha = 1 - age * 0.8;
  const r = 3 + (1 - age) * 2;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.arc(corp.x, corp.y, r, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(30,${Math.round(40 - age*30)}%,${Math.round(18 + age*8)}%)`;
  ctx.shadowColor = 'rgba(80,40,0,0.3)';
  ctx.shadowBlur = 4;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Small X to distinguish from food
  ctx.strokeStyle = `rgba(100,60,20,${0.5 * alpha})`;
  ctx.lineWidth = 0.7;
  ctx.beginPath(); ctx.moveTo(corp.x - r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x + r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(corp.x + r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x - r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.restore();
}

function drawCrater(cr) {
  const progress = cr.age / CRATER_DURATION; // 0=fresh, 1=healed
  const alpha = 1 - progress * 0.85;
  ctx.save();
  ctx.globalAlpha = alpha;
  // Scorched ground â€” dark radial gradient
  const g = ctx.createRadialGradient(cr.x, cr.y, 0, cr.x, cr.y, cr.r);
  g.addColorStop(0,   `rgba(20,8,4,0.92)`);
  g.addColorStop(0.5, `rgba(40,15,5,0.6)`);
  g.addColorStop(1,   `rgba(60,20,5,0)`);
  ctx.beginPath();
  ctx.arc(cr.x, cr.y, cr.r, 0, Math.PI * 2);
  ctx.fillStyle = g;
  ctx.fill();
  // Glowing ember rim at the edge
  if (progress < 0.3) {
    const emberA = (1 - progress / 0.3) * 0.5;
    ctx.beginPath();
    ctx.arc(cr.x, cr.y, cr.r * 0.85, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,80,20,${emberA})`;
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  ctx.restore();
}

function drawMeteorWarning(m) {
  const progress = 1 - m.countdown / m.maxCountdown; // 0=just armed, 1=impact
  ctx.save();
  // Pulsing red targeting circle
  const pulse = 0.5 + 0.5 * Math.sin(tick * 0.4);
  const outerR = METEOR_RADIUS * (1.2 + pulse * 0.15);
  ctx.beginPath();
  ctx.arc(m.x, m.y, outerR, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(255,50,30,${0.3 + progress * 0.5})`;
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 6]);
  ctx.stroke();
  ctx.setLineDash([]);
  // Crosshair
  const ch = outerR * 0.35;
  ctx.strokeStyle = `rgba(255,100,50,${0.5 + progress * 0.4})`;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(m.x - ch, m.y); ctx.lineTo(m.x + ch, m.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(m.x, m.y - ch); ctx.lineTo(m.x, m.y + ch); ctx.stroke();
  // Incoming streak â€” grows as countdown decreases
  const streakLen = progress * 60;
  ctx.beginPath();
  ctx.moveTo(m.x - streakLen * 0.7, m.y - streakLen);
  ctx.lineTo(m.x, m.y);
  const grad = ctx.createLinearGradient(m.x - streakLen*0.7, m.y - streakLen, m.x, m.y);
  grad.addColorStop(0, 'rgba(255,150,50,0)');
  grad.addColorStop(1, `rgba(255,80,20,${progress * 0.8})`);
  ctx.strokeStyle = grad;
  ctx.lineWidth = 3 + progress * 4;
  ctx.stroke();
  // Impact countdown text
  const secs = Math.ceil(m.countdown / 60);
  ctx.globalAlpha = 0.7 + pulse * 0.3;
  ctx.fillStyle = '#ff4d2d';
  ctx.font = 'bold 11px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(m.countdown > 0 ? `â˜„ï¸ ${secs}s` : 'ğŸ’¥', m.x, m.y - outerR - 10);
  ctx.restore();
}

function drawChart() {
  const w = chartCanvas.width, h = chartCanvas.height;
  chartCtx.clearRect(0, 0, w, h);
  chartCtx.fillStyle = '#060810';
  chartCtx.fillRect(0, 0, w, h);

  // Season background tint
  const s = getCurrentSeason();
  chartCtx.fillStyle = s.barColor + '0a'; // 4% opacity tint
  chartCtx.fillRect(0, 0, w, h);

  const all = [...history.h, ...history.c, ...history.o, ...history.f];
  const maxVal = Math.max(...all, 1);
  if (history.h.length < 2) return;

  const line = (data, color) => {
    chartCtx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = (i / (MAX_HISTORY - 1)) * w;
      const y = h - (data[i] / maxVal) * h * 0.9 - 2;
      i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
    }
    chartCtx.strokeStyle = color;
    chartCtx.lineWidth = 1.5;
    chartCtx.stroke();
  };
  line(history.h, '#00f5c4');
  line(history.c, '#ff4d6d');
  line(history.o, '#2bbcff');
  line(history.f, '#ffd166');
}

function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(6,8,16,0.85)';
  ctx.fillRect(0, 0, W, H);

  // Seasonal ambient overlay
  const seasonTints = {
    SPRING: 'rgba(0,245,196,0.025)',
    SUMMER: 'rgba(255,209,102,0.02)',
    AUTUMN: 'rgba(255,120,50,0.03)',
    WINTER: 'rgba(100,140,255,0.04)',
  };
  const st = seasonTints[getCurrentSeason().name];
  if (st) { ctx.fillStyle = st; ctx.fillRect(0, 0, W, H); }

  // Active weather overlay
  if (activeWeather) {
    const wTints = {
      'DROUGHT':        'rgba(255,100,30,0.04)',
      'PLAGUE WIND':    'rgba(180,80,240,0.03)',
      'FEEDING FRENZY': 'rgba(0,245,196,0.05)',
      'BLIZZARD':       'rgba(150,200,255,0.06)',
      'TOXIC RAIN':     'rgba(130,210,20,0.04)',
    };
    const wt = wTints[activeWeather.event.name];
    if (wt) { ctx.fillStyle = wt; ctx.fillRect(0, 0, W, H); }
  }

  // Frenzy overlay
  if (frenziedTicks > 0) {
    const fp = 0.5 + 0.5 * Math.sin(tick * 0.08);
    ctx.fillStyle = `rgba(255,20,50,${0.02 + fp * 0.02})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Pheromone render â€” update offscreen canvas when dirty, then blit in one drawImage call
  if (pheroHerb && pheroCarn && params.showPhero) {
    if (pheroNeedsRedraw && tick % 5 === 0 && pheroCtx2) {
      pheroCtx2.clearRect(0, 0, pheroCanvas.width, pheroCanvas.height);
      for (let gy = 0; gy < pheroH; gy++) {
        for (let gx = 0; gx < pheroW; gx++) {
          const hi = pheroHerb[pheroIdx(gx, gy)];
          const ci = pheroCarn[pheroIdx(gx, gy)];
          const oi = pheroOmni ? pheroOmni[pheroIdx(gx, gy)] : 0;
          const px = gx * PHERO_CELL, py = gy * PHERO_CELL;
          if (hi > 0.03) {
            pheroCtx2.fillStyle = `rgba(0,245,196,${Math.min(1,hi*0.25).toFixed(3)})`;
            pheroCtx2.fillRect(px, py, PHERO_CELL, PHERO_CELL);
          }
          if (oi > 0.03) {
            pheroCtx2.fillStyle = `rgba(0,210,255,${Math.min(1,oi*0.28).toFixed(3)})`;
            pheroCtx2.fillRect(px, py, PHERO_CELL, PHERO_CELL);
          }
          if (ci > 0.03) {
            pheroCtx2.fillStyle = `rgba(255,77,109,${Math.min(1,ci*0.22).toFixed(3)})`;
            pheroCtx2.fillRect(px, py, PHERO_CELL, PHERO_CELL);
          }
        }
      }
      pheroNeedsRedraw = false;
    }
    // Single drawImage blit â€” far cheaper than per-cell fillRect every frame
    if (pheroCanvas) ctx.drawImage(pheroCanvas, 0, 0);
  }

  if (selectedCreature && selectedCreature.alive) {
    ctx.beginPath();
    ctx.arc(selectedCreature.x, selectedCreature.y, selectedCreature.dna.size + 10, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  for (const corp of corpses) drawCorpse(corp);
  // Draw craters under everything
  for (const cr of craters) drawCrater(cr);
  // Draw meteor warnings
  for (const m of meteors) drawMeteorWarning(m);
  for (const s of seeds) drawSeed(s);
  for (const f of foods) drawFood(f);
  for (const c of creatures) drawCreature(c);

  // Cinematic vignette â€” drawn last, above everything
  const vign = ctx.createRadialGradient(W/2, H/2, H * 0.3, W/2, H/2, H * 0.85);
  vign.addColorStop(0, 'rgba(0,0,0,0)');
  vign.addColorStop(1, 'rgba(0,0,0,0.38)');
  ctx.fillStyle = vign;
  ctx.fillRect(0, 0, W, H);
}

// â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateUI() {
  const alive = creatures.filter(c => c.alive);
  document.getElementById('hPop').textContent   = alive.filter(c => c.dna.type === 'herbivore').length;
  document.getElementById('cPop').textContent   = alive.filter(c => c.dna.type === 'carnivore').length;
  const oPop = document.getElementById('oPop'); if (oPop) oPop.textContent = alive.filter(c => c.dna.type === 'omnivore').length;
  document.getElementById('fPop').textContent   = foods.length;
  const sPop2 = document.getElementById('sPop'); if (sPop2) sPop2.textContent = seeds.length;
  document.getElementById('genNum').textContent  = generation;

  // Species panel â€” only rebuild DOM when membership actually changes (not every frame)
  const speciesEntries = Object.values(speciesRegistry);
  const sc = document.getElementById('speciesCount');
  if (sc) sc.textContent = `(${speciesEntries.length})`;
  const mobSc = document.getElementById('mobSpeciesCount');
  if (mobSc) mobSc.textContent = speciesEntries.length;
  const spCounts = {};
  for (const c of creatures) { if (c.alive && c.speciesId) spCounts[c.speciesId] = (spCounts[c.speciesId]||0)+1; }
  const newFingerprint = speciesEntries
    .filter(sp => (spCounts[sp.id]||0) > 0)
    .map(sp => sp.id + ':' + (spCounts[sp.id]||0))
    .join('|');
  // Update mobile species grid whenever fingerprint changes (not just on tab switch)
  if (isMobile() && mobActiveTab === 'species') updateMobSpeciesGrid();
  const grid = document.getElementById('speciesGrid');
  if (grid && newFingerprint !== grid.dataset.fp) {
    // If selected species went extinct, clear it
    if (selectedSpeciesId && !(selectedSpeciesId in spCounts)) selectedSpeciesId = null;
    grid.dataset.fp = newFingerprint;
    grid.innerHTML = '';
    for (const sp of speciesEntries) {
      const cnt = spCounts[sp.id] || 0;
      if (cnt === 0) continue;
      const cell = document.createElement('div');
      cell.className = 'species-cell';
      cell.title = `Click to highlight | + spawn | âˆ’ kill one (${sp.type}, ${sp.id.slice(3,8)})`;
      // Use data attribute + global handler â€” avoids closure/DOM timing issues
      cell.dataset.sid = sp.id;
      // No per-cell listener â€” handled by delegation on #speciesGrid
      // Mini canvas icon
      const mc = document.createElement('canvas');
      mc.width = 24; mc.height = 24;
      const mctx = mc.getContext('2d');
      const col = sp.type === 'herbivore' ? '#00f5c4'
                : sp.type === 'omnivore'  ? '#2bbcff' : '#ff4d6d';
      mctx.strokeStyle = col;
      mctx.fillStyle   = col + '55';
      mctx.lineWidth   = 1.5;
      drawShape(mctx, 12, 12, 8, sp.shape);
      mctx.fill();
      mctx.stroke();
      cell.appendChild(mc);
      const lbl = document.createElement('div');
      lbl.textContent = cnt;
      cell.appendChild(lbl);
      // +/- buttons row
      const btnRow = document.createElement('div');
      btnRow.className = 'sp-btn-row';
      const minusBtn = document.createElement('button');
      minusBtn.textContent = 'âˆ’';
      minusBtn.className = 'sp-btn minus';
      minusBtn.dataset.action = 'kill';
      minusBtn.dataset.sid = sp.id;
      const plusBtn = document.createElement('button');
      plusBtn.textContent = '+';
      plusBtn.className = 'sp-btn plus';
      plusBtn.dataset.action = 'spawn';
      plusBtn.dataset.sid = sp.id;
      btnRow.appendChild(minusBtn);
      btnRow.appendChild(plusBtn);
      cell.appendChild(btnRow);
      // Re-apply highlight if this was the selected species
      if (selectedSpeciesId === sp.id) cell.classList.add('selected-species');
      grid.appendChild(cell);
    }
  }
  document.getElementById('tickNum').textContent = tick;

  // Season display
  const seasonEl = document.getElementById('seasonDisplay');
  if (seasonEl) {
    const s = getCurrentSeason();
    seasonEl.textContent = s.emoji + ' ' + s.name;
    seasonEl.style.color = s.color;
    seasonEl.style.fontSize = '10px';
    seasonEl.style.letterSpacing = '1px';
  }
  // Season bar
  const barFill = document.getElementById('seasonBarFill');
  if (barFill) {
    const pct = (seasonTick / SEASON_LENGTH) * 100;
    barFill.style.width = pct + '%';
    barFill.style.background = getCurrentSeason().barColor;
    barFill.style.boxShadow = `0 0 6px ${getCurrentSeason().barColor}88`;
  }

  if (selectedCreature) {
    const c = selectedCreature, d = c.dna;
    const info = document.getElementById('infoBox');
    if (!c.alive) {
      info.innerHTML = '<b>DECEASED</b><br>Age: ' + c.age;
    } else {
      const energyPct = Math.round((c.energy / 300) * 100);
      const isSated = c.energy >= 270;
      const mateMax  = c.dna.type === 'herbivore' ? 3 : 5;
      const maxedOut = c.mateCount >= mateMax;
      const stateTag = c.sleeping
        ? `<br><b style="color:#a0b4f0">ğŸ’¤ SLEEPING (${c.sleepTicks} ticks)</b>`
        : c.matingWith
          ? `<br><b style="color:#a29bfe">â— MATING ${Math.round((c.matingTicks/MATING_DURATION)*100)}%</b>`
          : isSated && !maxedOut
            ? `<br><b style="color:#ffd166">â—ˆ SATED â€” seeking mate</b>`
            : isSated && maxedOut
              ? `<br><b style="color:#ffd166">â—ˆ SATED â€” retired</b>`
              : maxedOut
                ? `<br><b style="color:#636e72">âœ• RETIRED â€” 3/3 matings</b>`
                : c.matingCooldown > 0
                  ? `<br><b style="color:#636e72">â—Œ COOLDOWN ${c.matingCooldown}</b>`
                  : '';
      const staminaBar = (d.type === 'carnivore' || d.type === 'omnivore')
        ? `<br><b>STAMINA:</b> <b style="opacity:0.5">gene ${(d.stamina??1).toFixed(2)}</b>${c.sprinting ? ' <b style="color:#ffa032">âš¡ SPRINTING</b>' : ''}`
        : '';
      // Predator intelligence summary
      let huntMemHTML = '';
      if (d.type === 'carnivore') {
        const entries = Object.entries(c.memHuntAttempts || {})
          .filter(([k,v]) => v >= 3)
          .map(([k,v]) => {
            const wins = (c.memHuntWins || {})[k] || 0;
            return `${k.split('_')[0][0].toUpperCase()}:${Math.round(wins/v*100)}%`;
          });
        if (entries.length) huntMemHTML = `<br><b style="opacity:0.5">HUNT MEM: ${entries.join(' ')}</b>`;
      }
      info.innerHTML = `
        <b>TYPE:</b> ${d.type.toUpperCase()}<br>
        <b>STATUS:</b> <b style="color:var(--accent)">${c.status || 'â€”'}</b><br>
        <b>ENERGY:</b> ${Math.round(c.energy)} <b style="opacity:0.5">(${energyPct}%)</b><br>
        <b>AGE:</b> ${c.age}<br>
        <b>GEN:</b> ${c.gen}<br>
        <b>MATINGS:</b> ${c.mateCount}/${mateMax}${maxedOut ? ' <b style="color:var(--accent2)">RETIRED</b>' : ''}<br>
        <br>
        <b>â€” GENOME â€”</b><br>
        <b>SPEED:</b> ${d.speed.toFixed(2)}<br>
        <b>SENSE:</b> ${Math.round(d.sense)}${d.type==='carnivore' ? ' <b style="opacity:0.4">(cone)</b>' : ''}<br>
        <b>SIZE:</b> ${d.size.toFixed(2)}<br>
        <b>FERTILITY:</b> ${(d.fertility*1000).toFixed(2)}â€°<br>
        <b>METABOLISM:</b> ${d.metabolism.toFixed(3)}<br>
        <b>AGGRESSION:</b> ${d.aggression.toFixed(2)}${staminaBar}<br>
        <b>SPECIES:</b> <b style="opacity:0.5">${c.speciesId ? c.speciesId.slice(3,8) : '?'}</b>${huntMemHTML}${stateTag}
      `;
    }
  }
}

// â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastFPSTime = performance.now(), frames = 0;

function loop() {
  const now = performance.now();
  frames++;
  if (now - lastFPSTime > 1000) {
    document.getElementById('fpsDisplay').textContent = frames + ' FPS';
    frames = 0; lastFPSTime = now;
  }
  if (playing) {
    if (speed >= 1) {
      const iters = Math.round(speed);
      for (let i = 0; i < iters; i++) updateSim();
    } else {
      // Slow motion: accumulate fractional ticks
      speedFraction += speed;
      if (speedFraction >= 1) {
        speedFraction -= 1;
        updateSim();
      }
    }
  }
  updateUI(); // Always refresh panel so selected creature info stays live
  render();
  drawChart();
  requestAnimationFrame(loop);
}

// â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ Speed levels (0=0.25x, 1=0.5x, 2=1x, 3=2x, ... 13=12x) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SPEED_LEVELS = [0.25, 0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
let speedFraction = 0; // sub-tick accumulator for slow-motion

function updateSpeed(el) {
  const idx = parseInt(el.value);
  speed = SPEED_LEVELS[idx] || 1;
  const lbl = speed < 1 ? speed + 'Ã—' : Math.round(speed) + 'Ã—';
  document.getElementById('speedVal').textContent = lbl;
  // Keep both sliders in sync
  document.getElementById('speedSlider').value = el.value;
  const ms = document.getElementById('mobSpeedSlider');
  if (ms) ms.value = el.value;
  const mv = document.getElementById('mobSpeedVal');
  if (mv) mv.textContent = lbl;
}

// â”€â”€ Weather banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let bannerTimeout = null;
function showWeatherBanner(text, color, durationTicks, subtitle) {
  const el = document.getElementById('weatherBanner');
  const titleEl = document.getElementById('weatherBannerTitle');
  const subEl = document.getElementById('weatherBannerSub');
  if (!el) return;
  if (titleEl) titleEl.textContent = text;
  if (subEl) subEl.textContent = subtitle || '';
  el.style.borderColor = color;
  el.style.color = color;
  el.style.textShadow = `0 0 12px ${color}88`;
  el.classList.add('visible');
  if (bannerTimeout) clearTimeout(bannerTimeout);
  bannerTimeout = setTimeout(() => { el.classList.remove('visible'); }, 4500);
}

function togglePlay() {
  playing = !playing;
  const btn = document.getElementById('playBtn');
  btn.textContent = playing ? 'â¸ PAUSE' : 'â–¶ PLAY';
  btn.classList.toggle('active', playing);
  syncMobPlayBtn();
}

function updateParam(key, el) {
  params[key] = parseInt(el.value);
  const val = params[key] + (key === 'mutRate' ? '%' : '');
  document.getElementById(key + 'Val').textContent = val;
  // Keep desktop + mobile sliders in sync
  const desktopEl = document.getElementById(key);
  if (desktopEl && desktopEl !== el) desktopEl.value = el.value;
  const mobKey = 'mob' + key.charAt(0).toUpperCase() + key.slice(1);
  const mobEl = document.getElementById(mobKey);
  if (mobEl && mobEl !== el) mobEl.value = el.value;
  const mobValEl = document.getElementById(mobKey + 'Val');
  if (mobValEl) mobValEl.textContent = val;
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;

  // â”€â”€ Deus Mode routing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (deusMode === 'meteor') {
    meteors.push({ x: mx, y: my, countdown: METEOR_COUNTDOWN, maxCountdown: METEOR_COUNTDOWN });
    clearDeusArmed();
    return;
  }
  if (deusMode === 'champion') {
    // Find clicked creature
    let clicked = null;
    for (const c of creatures) {
      if (c.alive && dist(c, { x: mx, y: my }) < Math.max(c.dna.size + 14, 20)) { clicked = c; break; }
    }
    if (clicked) {
      // Remove champion from any existing champion first
      creatures.forEach(c => { c.champion = false; });
      clicked.champion = true;
      clicked.energy = 300;
      clicked.dna.speed    = Math.min(5,   clicked.dna.speed    * 2.2);
      clicked.dna.size     = Math.min(12,  clicked.dna.size     * 1.6);
      clicked.dna.sense    = Math.min(200, clicked.dna.sense    * 1.5);
      clicked.dna.stamina  = Math.min(1.0, clicked.dna.stamina  * 1.4);
      clicked.sleeping     = false;
      clicked.sleepTicks   = 0;
      clicked.sleepCooldown = 800;
      selectedCreature = clicked;
      clearDeusArmed();
    }
    return;
  }
  if (deusMode === 'teleport-pick') {
    let clicked = null;
    for (const c of creatures) {
      if (c.alive && dist(c, { x: mx, y: my }) < Math.max(c.dna.size + 14, 20)) { clicked = c; break; }
    }
    if (clicked) {
      deusTeleportCreature = clicked;
      deusMode = 'teleport-place';
      canvas.style.cursor = 'cell';
    }
    return;
  }
  if (deusMode === 'teleport-place') {
    if (deusTeleportCreature && deusTeleportCreature.alive) {
      deusTeleportCreature.x = mx;
      deusTeleportCreature.y = my;
      deusTeleportCreature.vx = (Math.random() - 0.5);
      deusTeleportCreature.vy = (Math.random() - 0.5);
      deusTeleportCreature.trail = [];
    }
    deusTeleportCreature = null;
    clearDeusArmed();
    return;
  }

  // â”€â”€ Normal creature selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let clicked = null;
  // Generous hit radius so small creatures are easy to click
  for (const c of creatures) {
    if (c.alive && dist(c, { x: mx, y: my }) < Math.max(c.dna.size + 12, 18)) { clicked = c; break; }
  }
  if (clicked) {
    selectedCreature = clicked;
    updateUI(); // Refresh panel immediately, even when paused
  } else {
    selectedCreature = null; // Just deselect â€” no food placement on empty click
  }
});

window.addEventListener('resize', resize);
resize();
resetSim();
loop();

// â”€â”€ Species grid event delegation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('speciesGrid').addEventListener('click', function(e) {
  // +/- buttons
  const btn = e.target.closest('button[data-action]');
  if (btn) {
    e.stopPropagation();
    const sid = btn.dataset.sid;
    if (btn.dataset.action === 'spawn') {
      spawnFromSpecies(sid);
    } else if (btn.dataset.action === 'kill') {
      // Randomly kill one alive creature of this species
      const candidates = creatures.filter(c => c.alive && c.speciesId === sid);
      if (candidates.length > 0) {
        const victim = candidates[Math.floor(Math.random() * candidates.length)];
        victim.alive = false;
        corpses.push({ x: victim.x, y: victim.y, energy: 0, decay: 0, fromType: victim.dna.type });
      }
    }
    return;
  }
  // Cell highlight (clicking icon/count area)
  const cell = e.target.closest('.species-cell');
  if (!cell) return;
  const sid = cell.dataset.sid;
  if (!sid) return;
  if (selectedSpeciesId === sid) {
    selectedSpeciesId = null;
  } else {
    selectedSpeciesId = sid;
  }
  document.querySelectorAll('.species-cell').forEach(c2 => {
    c2.classList.toggle('selected-species', c2.dataset.sid === selectedSpeciesId);
  });
});

// â”€â”€ Deus Ex Machina Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function clearDeusArmed() {
  deusMode = null;
  deusTeleportCreature = null;
  canvas.style.cursor = 'crosshair';
  document.querySelectorAll('.btn.deus').forEach(b => b.classList.remove('armed'));
}

function updateDeusWeatherButtons() {
  const eventBtnMap = {
    'DROUGHT':        'deusdroughtBtn',
    'PLAGUE WIND':    'deusplagueBtn',
    'FEEDING FRENZY': 'deusfrenzywBtn',
    'BLIZZARD':       'deusblizzardBtn',
    'TOXIC RAIN':     'deustoxicBtn',
  };
  // Clear all
  Object.values(eventBtnMap).forEach(id => {
    const btn = document.getElementById(id);
    if (btn) btn.classList.remove('active-event');
  });
  // Highlight active
  if (activeWeather) {
    const id = eventBtnMap[activeWeather.event.name];
    if (id) { const btn = document.getElementById(id); if (btn) btn.classList.add('active-event'); }
  }
}

function deusSetSeason(idx) {
  currentSeasonIdx = idx;
  seasonTick = 0;
  longWinterActive = false;
  longWinterTicks = 0;
  ['longWinterBtn','mobLongWinterBtn'].forEach(id => { const b=document.getElementById(id); if(b) b.classList.remove('active-event'); });
  const ns = SEASONS[idx];
  showWeatherBanner(ns.emoji + ' ' + ns.name + ' â€” FORCED', ns.color, 120, 'A divine hand shifts the seasons.');
}

function deusLongWinter() {
  currentSeasonIdx = 3; // Winter
  seasonTick = 0;
  longWinterActive = true;
  longWinterTicks = SEASON_LENGTH * 2.5;
  ['longWinterBtn','mobLongWinterBtn'].forEach(id => { const b=document.getElementById(id); if(b) b.classList.add('active-event'); });
  showWeatherBanner('ğŸ§Š LONG WINTER BEGINS', '#a0b4f0', 200, 'An endless freeze descends. No thaw in sight.');
}

function deusTriggerWeather(name) {
  const ev = WEATHER_EVENTS.find(e => e.name === name);
  if (!ev) return;
  activeWeather = { event: ev, ticksLeft: ev.duration };
  toxicRainActive = ev.name === 'TOXIC RAIN';
  weatherCooldown = 0;
  showWeatherBanner(ev.emoji + ' ' + ev.name + ' â€” FORCED', ev.color, ev.duration, ev.desc);
  updateDeusWeatherButtons();
}

function deusClearWeather() {
  if (activeWeather) {
    const endedName = activeWeather.event.name;
    activeWeather = null;
    toxicRainActive = false;
    weatherCooldown = 300;
    showWeatherBanner('âœ• WEATHER CLEARED', '#8899bb', 60, endedName + ' HAS BEEN DISMISSED');
    updateDeusWeatherButtons();
  }
}

function toggleRandomWeather() {
  randomWeatherEnabled = !randomWeatherEnabled;
  const label = randomWeatherEnabled ? 'ğŸ² RANDOM EVENTS: ON' : 'ğŸ² RANDOM EVENTS: OFF';
  if (randomWeatherEnabled) weatherCooldown = 600 + Math.floor(Math.random() * 600);
  ['randomWeatherBtn', 'mobRandomWeatherBtn'].forEach(id => {
    const b = document.getElementById(id);
    if (!b) return;
    b.textContent = label;
    b.classList.toggle('active-event', randomWeatherEnabled);
  });
}

function deusClearToxic() {
  // Remove all toxic food pellets
  const before = foods.length;
  foods = foods.filter(f => !f.toxic);
  const removedFood = before - foods.length;
  // Also clear toxicRainActive so no more toxic food spawns (unless weather still active)
  // If toxic rain weather is still running, end it too
  if (activeWeather && activeWeather.event.name === 'TOXIC RAIN') {
    activeWeather = null;
    toxicRainActive = false;
    weatherCooldown = 300;
    updateDeusWeatherButtons();
  } else {
    toxicRainActive = false;
  }
  showWeatherBanner('ğŸ§¹ TOXINS PURGED', '#a3e635', 60,
    `${removedFood} toxic food pellets removed`);
}

function deusArmMeteor() {
  if (deusMode === 'meteor') { clearDeusArmed(); return; }
  clearDeusArmed();
  deusMode = 'meteor';
  canvas.style.cursor = 'crosshair';
  ['meteorBtn','mobMeteorBtn'].forEach(id => { const b=document.getElementById(id); if(b) b.classList.add('armed'); });
}

function deusFrenzy() {
  frenziedTicks = 500;
  showWeatherBanner('ğŸ©¸ CARNIVORE FRENZY', '#ff4d6d', 200, 'Carnivores ignore all social inhibition. Omnivores beware.');
  ['frenzyCBtn','mobFrenzyCBtn'].forEach(id => { const b=document.getElementById(id); if(b) b.classList.add('active-event'); });
}

function deusArmChampion() {
  if (deusMode === 'champion') { clearDeusArmed(); return; }
  clearDeusArmed();
  deusMode = 'champion';
  canvas.style.cursor = 'pointer';
  ['championBtn','mobChampionBtn'].forEach(id => { const b=document.getElementById(id); if(b) b.classList.add('armed'); });
}

function deusArmTeleport() {
  if (deusMode === 'teleport-pick' || deusMode === 'teleport-place') { clearDeusArmed(); return; }
  clearDeusArmed();
  deusMode = 'teleport-pick';
  canvas.style.cursor = 'pointer';
  ['teleportBtn','mobTeleportBtn'].forEach(id => { const b=document.getElementById(id); if(b) b.classList.add('armed'); });
}

// Escape key cancels any armed Deus mode
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') clearDeusArmed();
});

// â”€â”€ Targeted Mutations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MUT_TRAITS = [
  { key: 'speed',      label: 'Speed',      min: 0.2,    max: 5,    step: 0.15 },
  { key: 'sense',      label: 'Sense',      min: 15,     max: 200,  step: 8    },
  { key: 'size',       label: 'Size',       min: 2,      max: 12,   step: 0.3  },
  { key: 'fertility',  label: 'Fertility',  min: 0.0005, max: 0.01, step: 0.0005 },
  { key: 'metabolism', label: 'Metabolism', min: 0.005,  max: 0.08, step: 0.003 },
  { key: 'aggression', label: 'Aggression', min: 0,      max: 1,    step: 0.07 },
  { key: 'stamina',    label: 'Stamina',    min: 0.1,    max: 1.0,  step: 0.07 },
];

function buildMutRows() {
  const container = document.getElementById('mutRows');
  if (!container) return;
  container.innerHTML = '';
  for (const trait of MUT_TRAITS) {
    const row = document.createElement('div');
    row.className = 'mut-row';
    const lbl = document.createElement('div');
    lbl.className = 'mut-label';
    lbl.textContent = trait.label;
    const minus = document.createElement('button');
    minus.className = 'mut-btn minus';
    minus.textContent = 'âˆ’';
    minus.title = `Decrease ${trait.label} for all ${mutTargetType}s`;
    minus.onclick = () => nudgeTrait(trait.key, -trait.step, trait.min, trait.max);
    const plus = document.createElement('button');
    plus.className = 'mut-btn';
    plus.textContent = '+';
    plus.title = `Increase ${trait.label} for all ${mutTargetType}s`;
    plus.onclick = () => nudgeTrait(trait.key, trait.step, trait.min, trait.max);
    row.appendChild(lbl);
    row.appendChild(minus);
    row.appendChild(plus);
    container.appendChild(row);
  }
}

function setMutTab(type) {
  mutTargetType = type;
  document.querySelectorAll('.type-tab').forEach(t => t.classList.remove('active'));
  const tabMap = { herbivore: 'mutTabHerb', carnivore: 'mutTabCarn', omnivore: 'mutTabOmni' };
  const mobTabMap = { herbivore: 'mobMutTabHerb', carnivore: 'mobMutTabCarn', omnivore: 'mobMutTabOmni' };
  [tabMap[type], mobTabMap[type]].forEach(id => { const el = document.getElementById(id); if (el) el.classList.add('active'); });
}

function nudgeTrait(key, delta, min, max) {
  let affected = 0;
  for (const c of creatures) {
    if (!c.alive || c.dna.type !== mutTargetType) continue;
    c.dna[key] = Math.max(min, Math.min(max, (c.dna[key] ?? 0) + delta));
    affected++;
  }
  if (affected > 0) {
    const dir = delta > 0 ? 'â–²' : 'â–¼';
    showWeatherBanner(`${dir} ${key.toUpperCase()} NUDGED`, '#8899bb', 60,
      `${affected} ${mutTargetType}s affected`);
  }
}

// Build mutation rows on load
buildMutRows();

// â”€â”€ Mobile UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// (isMobile declared at top of script)

// Track active tab
let mobActiveTab = 'sim';

function mobSwitchTab(tab, btn) {
  const sheet = document.getElementById('mobileSheet');
  // If tapping the already-active tab, toggle sheet open/closed
  if (tab === mobActiveTab) {
    sheet.classList.toggle('open');
    return;
  }
  mobActiveTab = tab;
  sheet.classList.add('open');
  // Switch tab button highlights
  document.querySelectorAll('.mob-tab').forEach(t => t.classList.remove('active'));
  if (btn) btn.classList.add('active');
  // Show correct panel
  document.querySelectorAll('.mob-panel').forEach(p => p.style.display = 'none');
  const el = document.getElementById('mobPanel' + tab.charAt(0).toUpperCase() + tab.slice(1));
  if (el) el.style.display = '';
  // Refresh species grid when switching to species tab
  if (tab === 'species') updateMobSpeciesGrid();
}

// Keep mobile play button in sync
function syncMobPlayBtn() {
  const btn = document.getElementById('mobPlayBtn');
  if (!btn) return;
  btn.textContent = playing ? 'â¸ PAUSE' : 'â–¶ PLAY';
  btn.classList.toggle('active', playing);
}

// Keep mobile speed slider in sync with desktop
function syncMobSpeed(label) {
  const sl = document.getElementById('mobSpeedSlider');
  const vl = document.getElementById('mobSpeedVal');
  if (sl) sl.value = document.getElementById('speedSlider').value;
  if (vl && label) vl.textContent = label;
}

// Sync mobile phero button
function syncMobPheroBtn() {
  const btn = document.getElementById('mobPheroBtn');
  if (btn) {
    btn.textContent = params.showPhero ? 'ON' : 'OFF';
    btn.classList.toggle('active', params.showPhero);
  }
}

// Sync qty buttons on mobile
function syncMobQty() {
  document.querySelectorAll('#mobileSheet .qty-btn').forEach(b => b.classList.remove('active'));
  const el = document.getElementById('mobQty' + currentQty);
  if (el) el.classList.add('active');
}

// Build mobile mutation rows (mirrors desktop but targets mobMutRows)
function buildMobMutRows() {
  const container = document.getElementById('mobMutRows');
  if (!container) return;
  container.innerHTML = '';
  for (const trait of MUT_TRAITS) {
    const row = document.createElement('div');
    row.className = 'mut-row';
    const lbl = document.createElement('div');
    lbl.className = 'mut-label';
    lbl.textContent = trait.label;
    const minus = document.createElement('button');
    minus.className = 'mut-btn minus';
    minus.textContent = 'âˆ’';
    minus.onclick = () => nudgeTrait(trait.key, -trait.step, trait.min, trait.max);
    const plus = document.createElement('button');
    plus.className = 'mut-btn';
    plus.textContent = '+';
    plus.onclick = () => nudgeTrait(trait.key, trait.step, trait.min, trait.max);
    row.appendChild(lbl); row.appendChild(minus); row.appendChild(plus);
    container.appendChild(row);
  }
}
buildMobMutRows();

// Mobile species grid â€” mirrors desktop grid, same delegation
const mobSpeciesGrid = document.getElementById('mobSpeciesGrid');
let mobSpFingerprint = '';

function updateMobSpeciesGrid() {
  if (!isMobile()) return;
  // Reuse same fingerprint logic as desktop
  const alive = creatures.filter(c => c.alive);
  const spCounts = {};
  for (const c of alive) { if (c.speciesId) spCounts[c.speciesId] = (spCounts[c.speciesId]||0)+1; }
  const fp = Object.entries(spCounts).sort().map(([k,v])=>k+':'+v).join(',');
  if (fp === mobSpFingerprint) return;
  mobSpFingerprint = fp;

  const countEl = document.getElementById('mobSpeciesCount');
  if (countEl) countEl.textContent = Object.keys(spCounts).length;

  mobSpeciesGrid.innerHTML = '';
  const entries = Object.values(speciesRegistry).filter(sp => (spCounts[sp.id]||0) > 0);
  for (const sp of entries) {
    const cnt = spCounts[sp.id] || 0;
    if (!cnt) continue;
    const cell = document.createElement('div');
    cell.className = 'species-cell';
    cell.dataset.sid = sp.id;
    if (selectedSpeciesId === sp.id) cell.classList.add('selected-species');
    const mc = document.createElement('canvas');
    mc.width = 24; mc.height = 24;
    const mctx = mc.getContext('2d');
    const col = sp.type === 'herbivore' ? '#00f5c4' : sp.type === 'omnivore' ? '#2bbcff' : '#ff4d6d';
    mctx.strokeStyle = col; mctx.fillStyle = col + '55'; mctx.lineWidth = 1.5;
    drawShape(mctx, 12, 12, 8, sp.shape); mctx.fill(); mctx.stroke();
    cell.appendChild(mc);
    const lbl = document.createElement('div'); lbl.textContent = cnt; cell.appendChild(lbl);
    const btnRow = document.createElement('div'); btnRow.className = 'sp-btn-row';
    const minus = document.createElement('button');
    minus.className = 'sp-btn minus'; minus.textContent = 'âˆ’';
    minus.dataset.action = 'kill'; minus.dataset.sid = sp.id;
    const plus = document.createElement('button');
    plus.className = 'sp-btn plus'; plus.textContent = '+';
    plus.dataset.action = 'spawn'; plus.dataset.sid = sp.id;
    btnRow.appendChild(minus); btnRow.appendChild(plus); cell.appendChild(btnRow);
    mobSpeciesGrid.appendChild(cell);
  }
}

mobSpeciesGrid.addEventListener('click', function(e) {
  const btn = e.target.closest('button[data-action]');
  if (btn) {
    e.stopPropagation();
    const sid = btn.dataset.sid;
    if (btn.dataset.action === 'spawn') spawnFromSpecies(sid);
    else if (btn.dataset.action === 'kill') {
      const cands = creatures.filter(c => c.alive && c.speciesId === sid);
      if (cands.length) { const v = cands[Math.floor(Math.random()*cands.length)]; v.alive=false; corpses.push({x:v.x,y:v.y,energy:0,decay:0,fromType:v.dna.type}); }
    }
    return;
  }
  const cell = e.target.closest('.species-cell');
  if (!cell || !cell.dataset.sid) return;
  const sid = cell.dataset.sid;
  selectedSpeciesId = selectedSpeciesId === sid ? null : sid;
  document.querySelectorAll('.species-cell').forEach(c2 => {
    c2.classList.toggle('selected-species', c2.dataset.sid === selectedSpeciesId);
  });
});

// Mirror Deus weather button states on mobile
const _origUpdateDeusWeatherButtons = updateDeusWeatherButtons;
updateDeusWeatherButtons = function() {
  _origUpdateDeusWeatherButtons();
  // Mirror active states on mobile buttons
  const map = {
    'DROUGHT':'mobDeusdroughtBtn','PLAGUE WIND':'mobDeusplagueBtn',
    'FEEDING FRENZY':'mobDeusfrenzywBtn','BLIZZARD':'mobDeusblizzardBtn','TOXIC RAIN':'mobDeustoxicBtn'
  };
  Object.values(map).forEach(id => { const b=document.getElementById(id); if(b) b.classList.remove('active-event'); });
  if (activeWeather) { const id=map[activeWeather.event.name]; if(id){const b=document.getElementById(id);if(b)b.classList.add('active-event');} }
};

// Mirror armed Deus states on mobile
const _origClearDeusArmed = clearDeusArmed;
clearDeusArmed = function() {
  _origClearDeusArmed();
  ['mobMeteorBtn','mobChampionBtn','mobTeleportBtn'].forEach(id => {
    const b = document.getElementById(id); if(b) b.classList.remove('armed');
  });
};

// Override resize to account for mobile tab bar
function resize() {
  const mobile = isMobile();
  const panel  = document.querySelector('.panel');
  const header = document.querySelector('header');
  const footer = document.querySelector('footer');
  const tabBar = document.getElementById('mobileTabBar');

  if (mobile) {
    const tabH = tabBar ? tabBar.offsetHeight : 52;
    const w    = window.innerWidth;
    const h    = window.innerHeight - header.offsetHeight - tabH;
    canvas.width        = w;
    canvas.height       = h;
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0); // reset any prior scaling
    chartCanvas.width = 180; chartCanvas.height = 60;
  } else {
    canvas.style.width  = '';
    canvas.style.height = '';
    canvas.width  = window.innerWidth - panel.offsetWidth;
    canvas.height = window.innerHeight - header.offsetHeight - footer.offsetHeight;
    chartCanvas.width  = panel.offsetWidth - 24;
    chartCanvas.height = 60;
  }
  initPhero();
}

// Touch support â€” translate touches directly into the click handler's coordinate space
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  // Fire a synthetic click with the touch coordinates so the existing click handler works
  const rect = canvas.getBoundingClientRect();
  const mx = touch.clientX - rect.left;
  const my = touch.clientY - rect.top;
  // Directly invoke the same logic as the click handler using computed canvas coords
  canvas.dispatchEvent(new MouseEvent('click', {
    bubbles: true, cancelable: true,
    clientX: touch.clientX, clientY: touch.clientY
  }));
}, { passive: false });

// Orientation change â€” re-run resize after a tick to get correct dimensions
window.addEventListener('orientationchange', () => setTimeout(resize, 150));

function toggleSection(bodyId, btn) {
  const body = document.getElementById(bodyId);
  if (!body) return;
  const collapsed = body.style.display === 'none';
  body.style.display = collapsed ? '' : 'none';
  if (btn) {
    btn.textContent = collapsed ? 'â–¼' : 'â–¶';
    btn.classList.toggle('collapsed', !collapsed);
  }
}

function toggleLegend() {
  toggleSection('legendBody', document.getElementById('legendToggle'));
}

function togglePhero() {
  params.showPhero = !params.showPhero;
  const btn = document.getElementById('pheroBtn');
  btn.textContent = params.showPhero ? 'â— HIDE SCENT TRAILS' : 'â— SHOW SCENT TRAILS';
  btn.classList.toggle('active', params.showPhero);
  syncMobPheroBtn();
}

// â”€â”€ Spawn quantity selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentQty = 1;

function spawnAmt() { return currentQty; }

function setQty(n) {
  currentQty = n;
  document.querySelectorAll('.qty-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('qty' + n).classList.add('active');
  const mobEl = document.getElementById('mobQty' + n);
  if (mobEl) mobEl.classList.add('active');
  // Update button labels
  const plural = () => n === 1 ? '' : 'S';
  document.getElementById('spawnHlbl').textContent = n;
  document.getElementById('spawnClbl').textContent = n;
  document.getElementById('spawnOlbl').textContent = n;
  document.getElementById('spawnSlbl').textContent = n;
  document.getElementById('spawnFlbl').textContent = n;
  document.getElementById('spawnHs').textContent = plural();
  document.getElementById('spawnCs').textContent = plural();
  document.getElementById('spawnOs').textContent = plural();
  document.getElementById('spawnSs').textContent = plural();
}
</script>
</body>
</html>
