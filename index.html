<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ALIFE — Artificial Life Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Syncopate:wght@400;700&display=swap');

  :root {
    --bg: #060810;
    --panel: #0a0e1a;
    --border: #1a2240;
    --accent: #00f5c4;
    --accent2: #ff4d6d;
    --accent3: #ffd166;
    --text: #8899bb;
    --text-bright: #ccd6f6;
    --grid: rgba(0,245,196,0.04);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
  }

  .logo {
    font-family: 'Syncopate', sans-serif;
    font-weight: 700;
    font-size: 18px;
    letter-spacing: 6px;
    color: var(--accent);
    text-shadow: 0 0 20px rgba(0,245,196,0.5);
  }
  .logo span { color: var(--text); font-weight: 400; }

  .header-stats {
    display: flex;
    gap: 24px;
    font-size: 11px;
    letter-spacing: 1px;
  }

  .stat { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .stat-val { color: var(--accent); font-size: 16px; font-weight: bold; }
  .stat-lbl { color: var(--text); opacity: 0.6; font-size: 9px; letter-spacing: 2px; text-transform: uppercase; }

  .by-cal-link {
    display: flex;
    align-items: center;
    gap: 7px;
    text-decoration: none;
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--text);
    opacity: 0.8;
    border: 1px solid var(--border);
    padding: 5px 11px;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .by-cal-link:hover {
    border-color: var(--accent);
    color: var(--accent);
    opacity: 1;
    box-shadow: 0 0 12px rgba(0,245,196,0.15);
  }

  .main { display: flex; flex: 1; overflow: hidden; }

  canvas { flex: 1; display: block; cursor: crosshair; }

  .panel {
    width: 220px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
    flex-shrink: 0;
  }
  .panel::-webkit-scrollbar { width: 3px; }
  .panel::-webkit-scrollbar-track { background: transparent; }
  .panel::-webkit-scrollbar-thumb { background: var(--border); }

  .section { border-bottom: 1px solid var(--border); padding: 12px; }

  .section-title {
    font-family: 'Syncopate', sans-serif;
    font-size: 8px;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 10px;
    text-transform: uppercase;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 10px;
  }
  .control-label { color: var(--text); letter-spacing: 1px; }

  input[type=range] {
    -webkit-appearance: none;
    width: 90px; height: 2px;
    background: var(--border);
    outline: none; border-radius: 2px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(0,245,196,0.6);
  }

  .val-display { color: var(--accent); font-size: 10px; min-width: 28px; text-align: right; }

  .btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px; letter-spacing: 2px; text-transform: uppercase;
    border: 1px solid var(--border); background: transparent;
    color: var(--text-bright); padding: 7px 10px;
    cursor: pointer; transition: all 0.15s;
    width: 100%; margin-bottom: 6px; text-align: left;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.05); box-shadow: 0 0 10px rgba(0,245,196,0.1); }
  .btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0,245,196,0.08); }
  .btn.danger:hover { border-color: var(--accent2); color: var(--accent2); background: rgba(255,77,109,0.05); }

  .legend { display: flex; flex-direction: column; gap: 5px; }
  .legend-item { display: flex; align-items: center; gap: 8px; font-size: 9px; letter-spacing: 1px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

  .mini-chart { width: 100%; height: 60px; border: 1px solid var(--border); margin-top: 8px; overflow: hidden; }
  .mini-chart canvas { width: 100%; height: 100%; }

  .info-box { font-size: 9px; line-height: 1.8; color: var(--text); letter-spacing: 0.5px; }
  .info-box b { color: var(--accent); font-weight: normal; }

  footer {
    padding: 6px 16px; font-size: 9px; letter-spacing: 2px;
    color: var(--border); border-top: 1px solid var(--border);
    background: var(--panel); display: flex; justify-content: space-between; flex-shrink: 0;
  }
</style>
</head>
<body>

<header>
  <div class="logo">ALIFE <span>/ SIM</span></div>
  <div class="header-stats">
    <div class="stat"><div class="stat-val" id="hPop">0</div><div class="stat-lbl">Herbivores</div></div>
    <div class="stat"><div class="stat-val" id="cPop" style="color:var(--accent2)">0</div><div class="stat-lbl">Carnivores</div></div>
    <div class="stat"><div class="stat-val" id="oPop" style="color:#00dce0">0</div><div class="stat-lbl">Omnivores</div></div>
    <div class="stat"><div class="stat-val" id="fPop" style="color:var(--accent3)">0</div><div class="stat-lbl">Food</div></div>
    <div class="stat"><div class="stat-val" id="genNum" style="color:#a29bfe">0</div><div class="stat-lbl">Generation</div></div>
    <div class="stat"><div class="stat-val" id="tickNum">0</div><div class="stat-lbl">Tick</div></div>
  </div>
  <a href="https://www.linkedin.com/in/callum-smith-55118071/" target="_blank" rel="noopener" class="by-cal-link">
    <svg width="13" height="13" viewBox="0 0 24 24" fill="currentColor">
      <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
    </svg>
    BY CAL
  </a>
</header>

<div class="main">
  <canvas id="canvas"></canvas>
  <div class="panel">
    <div class="section">
      <div class="section-title">Simulation</div>
      <button class="btn active" id="playBtn" onclick="togglePlay()">⏸ PAUSE</button>
      <button class="btn danger" onclick="resetSim()">↺ RESET</button>
      <div class="control-row">
        <div class="control-label">SPEED</div>
        <input type="range" id="speedSlider" min="1" max="10" value="1" oninput="updateSpeed(this)">
        <div class="val-display" id="speedVal">1</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Environment</div>
      <div class="control-row">
        <div class="control-label">FOOD SPREAD</div>
        <input type="range" id="foodRate" min="1" max="20" value="8" oninput="updateParam('foodRate', this)">
        <div class="val-display" id="foodRateVal">8</div>
      </div>
      <div class="control-row">
        <div class="control-label">MAX FOOD</div>
        <input type="range" id="maxFood" min="20" max="1000" value="120" oninput="updateParam('maxFood', this)">
        <div class="val-display" id="maxFoodVal">120</div>
      </div>
      <div class="control-row">
        <div class="control-label">MUTATION</div>
        <input type="range" id="mutRate" min="0" max="50" value="10" oninput="updateParam('mutRate', this)">
        <div class="val-display" id="mutRateVal">10%</div>
      </div>
      <div class="control-row">
        <div class="control-label">FLOCK STR</div>
        <input type="range" id="flockStr" min="0" max="20" value="10" oninput="updateParam('flockStr', this)">
        <div class="val-display" id="flockStrVal">10</div>
      </div>
      <button class="btn" id="pheroBtn" onclick="togglePhero()" style="margin-top:2px;">◎ SHOW SCENT TRAILS</button>
    </div>
    <div class="section">
      <div class="section-title">Spawn</div>
      <button class="btn" id="spawnH" onclick="spawnCreatures('herbivore', spawnAmt())">+ <span id="spawnHlbl">1</span> HERBIVORE<span id="spawnHs"></span></button>
      <button class="btn" id="spawnC" onclick="spawnCreatures('carnivore', spawnAmt())">+ <span id="spawnClbl">1</span> CARNIVORE<span id="spawnCs"></span></button>
      <button class="btn" id="spawnO" onclick="spawnCreatures('omnivore', spawnAmt())">+ <span id="spawnOlbl">1</span> OMNIVORE<span id="spawnOs"></span></button>
      <button class="btn" id="spawnF" onclick="spawnFood(spawnAmt())">+ <span id="spawnFlbl">1</span> FOOD</button>
      <div style="display:flex;gap:6px;margin-top:8px;">
        <button class="btn qty-btn active" id="qty1" onclick="setQty(1)" style="flex:1;text-align:center;padding:6px 0;">1</button>
        <button class="btn qty-btn" id="qty10" onclick="setQty(10)" style="flex:1;text-align:center;padding:6px 0;">10</button>
        <button class="btn qty-btn" id="qty25" onclick="setQty(25)" style="flex:1;text-align:center;padding:6px 0;">25</button>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Legend</div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>HERBIVORE — eats food</div>
        <div class="legend-item"><div class="legend-dot" style="background:#00dce0"></div>OMNIVORE — food + corpses</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent2)"></div>CARNIVORE — hunts prey</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent3)"></div>FOOD — energy pellets</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a29bfe"></div>MATING — purple, vulnerable!</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffd166;opacity:0.7"></div>SATED (90%+) — behaviour shift</div>
        <div class="legend-item"><div class="legend-dot" style="background:#a0b4f0;opacity:0.7"></div>SLEEPING — inert, vulnerable</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffa032;opacity:0.8"></div>SPRINTING — burning stamina</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(0,245,196,0.4)"></div>HERB SCENT — carnivores track</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(0,210,255,0.5)"></div>OMNI SCENT — distinct cyan</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(255,77,109,0.4)"></div>CARN SCENT — herbivores flee</div>
        <div class="legend-item"><div class="legend-dot" style="background:#5c3d1a;opacity:0.7"></div>CORPSE — carnivore food</div>
        <div class="legend-item"><div class="legend-dot" style="background:#636e72;opacity:0.4"></div>OLD AGE — no corpse</div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Population Graph</div>
      <div class="mini-chart"><canvas id="chartCanvas"></canvas></div>
    </div>
    <div class="section">
      <div class="section-title">Selection Info</div>
      <div class="info-box" id="infoBox"><b>Click a creature</b> to inspect its genes and status.</div>
    </div>
  </div>
</div>

<footer>
  <span>ARTIFICIAL LIFE SIMULATOR — EVOLUTIONARY GENETICS ENGINE</span>
  <span id="fpsDisplay">60 FPS</span>
</footer>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const chartCanvas = document.getElementById('chartCanvas');
const chartCtx = chartCanvas.getContext('2d');

let creatures = [];
let foods = [];
let tick = 0;
let generation = 1;
let playing = true;
let speed = 1;
let selectedCreature = null;
let corpses = [];

// ── Pheromone grids ───────────────────────────────────────────────────────────
const PHERO_CELL = 8;        // pixels per grid cell
let pheroW = 1, pheroH = 1; // grid dimensions, set on resize
let pheroHerb = null;        // herbivore scent (teal) — carnivores follow this
let pheroCarn = null;        // carnivore scent (red)  — herbivores flee this
let pheroOmni = null;        // omnivore scent (cyan)  — distinct from herb

function initPhero() {
  pheroW = Math.ceil(canvas.width  / PHERO_CELL);
  pheroH = Math.ceil(canvas.height / PHERO_CELL);
  pheroHerb = new Float32Array(pheroW * pheroH);
  pheroCarn = new Float32Array(pheroW * pheroH);
  pheroOmni = new Float32Array(pheroW * pheroH);
}

function pheroIdx(gx, gy) { return gy * pheroW + gx; }

function depositPhero(grid, x, y, amount) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  if (gx < 0 || gx >= pheroW || gy < 0 || gy >= pheroH) return;
  grid[pheroIdx(gx, gy)] = Math.min(1, grid[pheroIdx(gx, gy)] + amount);
}

function samplePhero(grid, x, y) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  if (gx < 0 || gx >= pheroW || gy < 0 || gy >= pheroH) return 0;
  return grid[pheroIdx(gx, gy)];
}

// Read gradient of grid at position — returns (dx,dy) pointing uphill
function pheroGradient(grid, x, y) {
  const gx = Math.floor(x / PHERO_CELL);
  const gy = Math.floor(y / PHERO_CELL);
  const get = (gx2, gy2) => {
    if (gx2 < 0 || gx2 >= pheroW || gy2 < 0 || gy2 >= pheroH) return 0;
    return grid[pheroIdx(gx2, gy2)];
  };
  const dx = get(gx+1, gy) - get(gx-1, gy);
  const dy = get(gx, gy+1) - get(gx, gy-1);
  return { dx, dy };
}

// Evaporate and diffuse the grid — called each tick
function updatePhero(grid) {
  const evap    = 0.992; // retain 99.2% each tick — slow fade
  const diffuse = 0.06;  // how much bleeds to neighbours
  const next = new Float32Array(grid.length);
  for (let gy = 0; gy < pheroH; gy++) {
    for (let gx = 0; gx < pheroW; gx++) {
      const i   = pheroIdx(gx, gy);
      const val = grid[i] * evap;
      const bleed = val * diffuse;
      next[i] += val - bleed;
      // Spread a fraction to the 4 neighbours
      if (gx > 0)          next[pheroIdx(gx-1, gy)] += bleed * 0.25;
      if (gx < pheroW - 1) next[pheroIdx(gx+1, gy)] += bleed * 0.25;
      if (gy > 0)          next[pheroIdx(gx, gy-1)] += bleed * 0.25;
      if (gy < pheroH - 1) next[pheroIdx(gx, gy+1)] += bleed * 0.25;
    }
  }
  grid.set(next);
}

// How many ticks creatures stay in the purple mating state before baby spawns
const MATING_DURATION = 60;

const params = { foodRate: 8, maxFood: 120, mutRate: 10, flockStr: 10, showPhero: false };
const history = { h: [], c: [], o: [], f: [] };
const MAX_HISTORY = 196;

// ── DNA ───────────────────────────────────────────────────────────────────────
function randomDNA(type) {
  return {
    type,
    speed:      0.5 + Math.random() * 2.5,
    sense:      30  + Math.random() * 120,
    size:       3   + Math.random() * 5,
    fertility:  0.001 + Math.random() * 0.004,
    metabolism: 0.015 + Math.random() * 0.03,
    aggression: type === 'carnivore' ? 0.5 + Math.random() * 0.5 : Math.random() * 0.3,
    stamina:    (type === 'carnivore' || type === 'omnivore') ? 0.4 + Math.random() * 0.6 : 1.0,
  };
}

function mutateDNA(dna) {
  const m = params.mutRate / 100;
  const mut = v => v * (1 + (Math.random() * 2 - 1) * m);
  return {
    type:       dna.type,
    speed:      Math.max(0.2, Math.min(5,    mut(dna.speed))),
    sense:      Math.max(15,  Math.min(200,  mut(dna.sense))),
    size:       Math.max(2,   Math.min(12,   mut(dna.size))),
    fertility:  Math.max(0.0005, Math.min(0.01, mut(dna.fertility))),
    metabolism: Math.max(0.005,  Math.min(0.08, mut(dna.metabolism))),
    aggression: Math.max(0,   Math.min(1,    mut(dna.aggression))),
    stamina:    Math.max(0.1, Math.min(1.0,  mut(dna.stamina ?? 1.0))),
  };
}

// ── Factory ───────────────────────────────────────────────────────────────────
function createCreature(type, x, y, dna) {
  dna = dna || randomDNA(type);
  return {
    id:             Math.random().toString(36).slice(2),
    dna,
    x:              x ?? Math.random() * canvas.width,
    y:              y ?? Math.random() * canvas.height,
    vx:             (Math.random() - 0.5) * 2,
    vy:             (Math.random() - 0.5) * 2,
    energy:         150, // Start at 50% of max (300) — must eat before mating
    age:            0,
    alive:          true,
    matingWith:     null,  // partner reference during active mating
    matingTicks:    0,     // progress through MATING_DURATION
    matingCooldown: 0,     // post-birth cooldown
    mateCount:      0,     // successful matings; capped at 3
    sleeping:       false, // currently asleep
    sleepTicks:     0,     // ticks remaining in sleep
    sleepCooldown:  Math.floor(Math.random() * 400) + 200, // ticks until next sleep check
    wakeScatter:    0,     // >0 = startled, flee at full speed
    sprinting:      false, // is currently sprinting
    packTarget:     null,  // shared prey reference for pack hunting
    status:         'WANDERING',
    trail:          [],
    gen:            generation,
  };
}

function createFood(x, y) {
  return {
    x:      x ?? Math.random() * canvas.width,
    y:      y ?? Math.random() * canvas.height,
    energy: 20 + Math.random() * 30,
  };
}

// ── Init ──────────────────────────────────────────────────────────────────────
function resetSim() {
  creatures = []; foods = []; corpses = []; initPhero();
  tick = 0; generation = 1;
  history.h = []; history.c = []; history.o = []; history.f = [];
  selectedCreature = null;
  for (let i = 0; i < 20; i++) creatures.push(createCreature('herbivore'));
  for (let i = 0; i < 6;  i++) creatures.push(createCreature('carnivore'));
  for (let i = 0; i < 60; i++) foods.push(createFood());
}

function spawnCreatures(type, n) { for (let i = 0; i < n; i++) creatures.push(createCreature(type)); }
function spawnFood(n)            { for (let i = 0; i < n; i++) foods.push(createFood()); }

// ── Helpers ───────────────────────────────────────────────────────────────────
function dist(a, b) {
  const dx = a.x - b.x, dy = a.y - b.y;
  return Math.sqrt(dx*dx + dy*dy);
}

function findNearest(c, list, maxDist) {
  let best = null, bd = maxDist;
  for (const item of list) {
    const d = dist(c, item);
    if (d < bd) { bd = d; best = item; }
  }
  return best;
}

// Cone vision for carnivores — forward-facing arc, longer range
// angle is half-arc in radians (Math.PI/3 = 60° each side = 120° total)
function findInCone(c, list, range, halfArc) {
  const heading = Math.atan2(c.vy, c.vx);
  // Fallback to full circle if barely moving
  const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
  const useCone = spd > 0.1;
  let best = null, bd = range;
  for (const item of list) {
    const dx = item.x - c.x, dy = item.y - c.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d >= bd) continue;
    if (useCone) {
      const angle = Math.atan2(dy, dx);
      let diff = angle - heading;
      // Normalise to -PI..PI
      while (diff >  Math.PI) diff -= 2*Math.PI;
      while (diff < -Math.PI) diff += 2*Math.PI;
      if (Math.abs(diff) > halfArc) continue;
    }
    bd = d; best = item;
  }
  return best;
}

// ── Update ────────────────────────────────────────────────────────────────────
function updateCreature(c) {
  if (!c.alive) return;

  c.age++;
  if (c.matingCooldown > 0) c.matingCooldown--;
  c.energy -= c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002;

  if (c.energy <= 0 || c.age > 4000) {
    if (c.matingWith) { c.matingWith.matingWith = null; c.matingWith.matingTicks = 0; }
    // All deaths leave a corpse (burst carnivore pheromone too — death smell)
    corpses.push({ x: c.x, y: c.y, energy: 20 + Math.random() * 25, decay: 0, fromType: c.dna.type });
    if (pheroCarn) depositPhero(pheroCarn, c.x, c.y, 0.6);
    c.alive = false;
    return;
  }

  const W = canvas.width, H = canvas.height;

  // ── SLEEP ─────────────────────────────────────────────────────────────────
  if (c.sleeping) {
    c.sleepTicks--;
    // Sleeping metabolism is 10% of normal
    // (energy was already deducted at 100% above; refund 90%)
    c.energy += (c.dna.metabolism + c.dna.speed * 0.003 + c.dna.size * 0.002) * 0.9;

    // Dampen velocity — nearly still
    c.vx *= 0.05; c.vy *= 0.05;
    c.x += c.vx; c.y += c.vy;
    if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
    if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;
    c.trail.push({ x: c.x, y: c.y });
    if (c.trail.length > 8) c.trail.shift();

    if (c.sleepTicks <= 0) {
      c.sleeping = false;
      c.sleepCooldown = 300 + Math.floor(Math.random() * 400);
    }
    c.energy = Math.min(c.energy, 300);
    return; // Skip all other behaviour while asleep
  }

  // Startled — flee at max speed for a short burst
  if (c.wakeScatter > 0) {
    c.wakeScatter--;
    // Random scatter direction was set when startled; just let velocity carry
    const spd0 = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
    if (spd0 > c.dna.speed * 2) { c.vx = (c.vx/spd0)*c.dna.speed*2; c.vy = (c.vy/spd0)*c.dna.speed*2; }
  }

  // Tick down sleep cooldown; trigger sleep when it hits zero
  if (c.sleepCooldown > 0) {
    c.sleepCooldown--;
  } else if (!c.matingWith && c.wakeScatter === 0) {
    // Fall asleep: duration 180-360 ticks
    c.sleeping = true;
    c.sleepTicks = 180 + Math.floor(Math.random() * 180);
    c.vx *= 0.1; c.vy *= 0.1;
    c.energy = Math.min(c.energy, 300);
    return;
  }

  // ── ACTIVE MATING (creature is purple) ──────────────────────────────────
  if (c.matingWith) {
    const partner = c.matingWith;

    // Safety checks: cancel if partner died, or partner no longer points back (stale link)
    if (!partner.alive || partner.matingWith !== c) {
      c.matingWith = null; c.matingTicks = 0;
    } else {
      // Only the lower-id creature drives the tick counter to avoid double-counting
      if (c.id < partner.id) c.matingTicks++;
      else c.matingTicks = partner.matingTicks; // mirror the master's progress

      // Drift slowly toward partner — easy prey for carnivores!
      const dx = partner.x - c.x, dy = partner.y - c.y;
      const d  = Math.sqrt(dx*dx + dy*dy) + 0.001;
      c.vx += (dx/d) * 0.15;
      c.vy += (dy/d) * 0.15;
      const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
      const cap = c.dna.speed * 0.3;
      if (spd > cap) { c.vx = (c.vx/spd)*cap; c.vy = (c.vy/spd)*cap; }
      c.x += c.vx; c.y += c.vy;
      if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
      if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 8) c.trail.shift();

      // Spawn babies at end — only the lower-id creature (the "mother") births
      if (c.matingTicks >= MATING_DURATION && c.id < partner.id) {
        const avg = (a, b) => (a + b) / 2;
        const newGen = Math.max(c.gen, partner.gen) + 1;
        generation = Math.max(generation, newGen);
        // 80% = 1 offspring, 15% = 2, 5% = 3
        const roll = Math.random();
        const numOffspring = roll < 0.80 ? 1 : roll < 0.95 ? 2 : 3;
        for (let n = 0; n < numOffspring; n++) {
          const childDNA = mutateDNA({
            type:       c.dna.type,
            speed:      avg(c.dna.speed,      partner.dna.speed),
            sense:      avg(c.dna.sense,      partner.dna.sense),
            size:       avg(c.dna.size,       partner.dna.size),
            fertility:  avg(c.dna.fertility,  partner.dna.fertility),
            metabolism: avg(c.dna.metabolism, partner.dna.metabolism),
            aggression: avg(c.dna.aggression, partner.dna.aggression),
            stamina:    avg(c.dna.stamina ?? 1.0, partner.dna.stamina ?? 1.0),
          });
          const child = createCreature(
            c.dna.type,
            c.x + (Math.random()-0.5)*24,
            c.y + (Math.random()-0.5)*24,
            childDNA
          );
          child.gen = newGen;
          creatures.push(child);
        }
        // Energy cost scales with number of offspring; carnivores pay 50% less
        const baseCost = 30 + numOffspring * 15;
        const costMult = (c.dna.type === 'carnivore' || c.dna.type === 'omnivore') ? 0.5 : 1.0;
        const cost = baseCost * costMult;
        c.energy -= cost; partner.energy -= cost * 0.5;
        c.matingCooldown = 120; partner.matingCooldown = 120;
        c.mateCount++;       // track successful births
        partner.mateCount++; // both parents count it
      }

      // End mating phase for both
      if (c.matingTicks >= MATING_DURATION) {
        partner.matingWith = null; partner.matingTicks = 0;
        c.matingWith       = null; c.matingTicks       = 0;
      }
    }

    c.energy = Math.min(c.energy, 300);
    return; // Skip normal behaviour while mating
  }

  // ── NORMAL BEHAVIOUR ─────────────────────────────────────────────────────
  c.trail.push({ x: c.x, y: c.y });
  if (c.trail.length > 8) c.trail.shift();

  const MATE_ENERGY  = 240; // 80% of max 300 — required to mate
  const SATED_ENERGY = 270; // 90% of max 300 — above this, behaviour shifts
  const MAX_MATES    = c.dna.type === 'herbivore' ? 3 : 5; // carns/omnis retire at 5

  const isSated    = c.energy >= SATED_ENERGY;
  const canMate    = c.matingCooldown === 0 && c.mateCount < MAX_MATES && !c.matingWith;
  const mateElig   = canMate && c.energy >= MATE_ENERGY;

  let tx = null, ty = null;

  if (c.dna.type === 'herbivore') {
    c.status = 'FORAGING';
    // Always flee carnivores (stronger urge when sated — nothing to distract from survival)
    const predator = findNearest(c,
      creatures.filter(o => o.alive && o.dna.type === 'carnivore'),
      isSated ? c.dna.sense * 1.4 : c.dna.sense); // wider awareness when sated
    if (predator) {
      const dx = c.x - predator.x, dy = c.y - predator.y;
      const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
      tx = c.x + (dx/d) * (isSated ? 120 : 80);
      ty = c.y + (dy/d) * (isSated ? 120 : 80);
      c.status = 'FLEEING';
    }
    // Mildly repelled by corpses (smell of death = predator nearby)
    if (tx === null) {
      const corpse = findNearest(c, corpses, c.dna.sense * 0.5);
      if (corpse) {
        const dx = c.x - corpse.x, dy = c.y - corpse.y;
        const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
        tx = c.x + (dx/d) * 40; ty = c.y + (dy/d) * 40;
      }
    }
    // Flee carnivore pheromone trail — avoid areas carnivores recently passed through
    // (Herbivores only — omnivores don't fear carnivore scent)
    if (tx === null && pheroCarn) {
      const grad = pheroGradient(pheroCarn, c.x, c.y);
      const mag  = Math.sqrt(grad.dx*grad.dx + grad.dy*grad.dy);
      if (mag > 0.02) {
        c.vx -= (grad.dx/mag) * 0.25;
        c.vy -= (grad.dy/mag) * 0.25;
      }
    }
    // Only seek food when NOT sated
    if (tx === null && !isSated) {
      const food = findNearest(c, foods, c.dna.sense);
      if (food) { tx = food.x; ty = food.y; c.status = 'SEEKING FOOD'; }
    }
    // Seek mate when eligible (sated herbivores actively seek mates)
    if (tx === null && mateElig) {
      const mate = findNearest(c,
        creatures.filter(o => o.alive && o !== c && o.dna.type === 'herbivore' &&
                              o.energy >= MATE_ENERGY && o.matingCooldown === 0 &&
                              !o.matingWith && o.mateCount < MAX_MATES),
        c.dna.sense * 0.8);
      if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
    }
    if (isSated && tx === null) c.status = 'SATED — WANDERING';

  } else if (c.dna.type === 'omnivore') {
    // ── OMNIVORE BEHAVIOUR ──────────────────────────────────────────────────
    // Dual vision: cone (forward, long) + circle (close, omnidirectional)
    const CONE_RANGE  = c.dna.sense * 1.8;
    const CONE_ARC    = Math.PI / 3;

    c.sprinting = false;
    c.status = 'FORAGING';

    const lists = window._simLists || {};
    const wCarn = (lists.carns || []).filter(o => o !== c);
    const dangerCarn = findNearest(c, wCarn, c.dna.sense); // nearby carnivore — flee if awake

    if (isSated) {
      // SHEPHERDING: attract nearby herbivores to follow
      c.status = 'SHEPHERDING';
      // Seek mates if eligible
      if (mateElig) {
        const mate = findNearest(c,
          (lists.alive || []).filter(o => o !== c && o.dna.type === 'omnivore' &&
            o.energy >= MATE_ENERGY && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES),
          c.dna.sense * 0.8);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
    } else {
      // Flee awake carnivores
      if (dangerCarn && !dangerCarn.sleeping) {
        const dx = c.x - dangerCarn.x, dy = c.y - dangerCarn.y;
        const d = Math.sqrt(dx*dx+dy*dy)+0.001;
        tx = c.x + (dx/d)*100; ty = c.y + (dy/d)*100;
        c.status = 'FLEEING CARNIVORE';
      }
      // Scavenge corpses (omnis eat all corpses — priority)
      if (tx === null) {
        const nc = findNearest(c, corpses, c.dna.sense);
        if (nc) { tx = nc.x; ty = nc.y; c.packTarget = null; c.status = 'SCAVENGING'; }
      }
      // Eat food like herbivore
      if (tx === null) {
        const food = findNearest(c, foods, c.dna.sense);
        if (food) { tx = food.x; ty = food.y; c.status = 'SEEKING FOOD'; }
      }
      // Seek mate if nothing else
      if (tx === null && mateElig) {
        const mate = findNearest(c,
          (lists.alive || []).filter(o => o !== c && o.dna.type === 'omnivore' &&
            o.energy >= MATE_ENERGY && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES),
          c.dna.sense * 0.5);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
      if (tx === null) { c.status = 'WANDERING'; c.packTarget = null; }
    }

  } else {
    // ── CARNIVORE BEHAVIOUR ────────────────────────────────────────────────────
    const CONE_RANGE  = c.dna.sense * 1.8;
    const CONE_ARC    = Math.PI / 3;

    c.sprinting = false;
    const lists = window._simLists || {};

    // Avoid awake omnivores — they're not worth the trouble
    const nearOmni = findNearest(c,
      (lists.omnis || []).filter(o => !o.sleeping && o.energy >= 30),
      c.dna.sense * 0.6);
    if (nearOmni) {
      const dx = c.x - nearOmni.x, dy = c.y - nearOmni.y;
      const d = Math.sqrt(dx*dx+dy*dy)+0.001;
      c.vx += (dx/d) * 0.3; c.vy += (dy/d) * 0.3;
    }

    if (isSated) {
      c.status = 'SEEKING MATE';
      if (mateElig) {
        const mate = findNearest(c,
          (lists.carns || []).filter(o => o !== c &&
            o.energy >= MATE_ENERGY && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES),
          c.dna.sense * 0.8);
        if (mate) { tx = mate.x; ty = mate.y; }
      }
      if (tx === null) c.status = 'SATED — WANDERING';
    } else {
      c.status = 'HUNTING';

      // Pack hunting coordination
      let packInterceptX = null, packInterceptY = null;
      for (const pack of (lists.carns || [])) {
        if (pack === c || !pack.packTarget) continue;
        if (dist(c, pack) > c.dna.sense * 1.2) continue;
        const prey = pack.packTarget;
        if (!prey.alive) continue;
        const interceptX = prey.x + prey.vx * 20;
        const interceptY = prey.y + prey.vy * 20;
        if (dist(c, prey) > dist(pack, prey)) {
          packInterceptX = interceptX; packInterceptY = interceptY; break;
        }
      }
      if (packInterceptX !== null) { tx = packInterceptX; ty = packInterceptY; c.status = 'PACK FLANKING'; }

      // Cone prey detection — sleeping first
      if (tx === null) {
        const sp = findInCone(c, lists.sleeping || [], CONE_RANGE, CONE_ARC);
        if (sp && sp !== c) { tx = sp.x; ty = sp.y; c.packTarget = sp; c.status = 'STALKING'; }
      }
      // Mating prey
      if (tx === null) {
        const pp = findInCone(c, lists.mating || [], CONE_RANGE, CONE_ARC);
        if (pp) { tx = pp.x; ty = pp.y; c.packTarget = pp; c.status = 'HUNTING MATING PREY'; }
      }
      // Cannibalism (weak young carnivore)
      if (tx === null) {
        const wc = findInCone(c, (lists.carns || []).filter(o => o !== c && o.energy < 30 && o.age < c.age*0.5), CONE_RANGE, CONE_ARC);
        if (wc) { tx = wc.x; ty = wc.y; c.packTarget = wc; c.status = 'CANNIBALISING'; }
      }
      // Sleeping omnivore is fair game
      if (tx === null) {
        const so = findInCone(c, (lists.omnis || []).filter(o => o.sleeping), CONE_RANGE, CONE_ARC);
        if (so) { tx = so.x; ty = so.y; c.packTarget = so; c.status = 'HUNTING OMNIVORE'; }
      }
      // Weak omnivore <10% energy
      if (tx === null) {
        const wo = findInCone(c, (lists.omnis || []).filter(o => o.energy < 30), CONE_RANGE, CONE_ARC);
        if (wo) { tx = wo.x; ty = wo.y; c.packTarget = wo; c.status = 'HUNTING OMNIVORE'; }
      }
      // Corpses
      if (tx === null) {
        const nc = findNearest(c, corpses, c.dna.sense);
        if (nc) { tx = nc.x; ty = nc.y; c.packTarget = null; c.status = 'SCAVENGING'; }
      }
      // Herbivores in cone
      if (tx === null) {
        const prey = findInCone(c, lists.herbs || [], CONE_RANGE, CONE_ARC);
        if (prey) { tx = prey.x; ty = prey.y; c.packTarget = prey; c.status = 'CHASING'; }
      }
      // Follow pheromone trail
      if (tx === null && pheroHerb) {
        const grad = pheroGradient(pheroHerb, c.x, c.y);
        const mag  = Math.sqrt(grad.dx*grad.dx + grad.dy*grad.dy);
        if (mag > 0.03) {
          c.vx += (grad.dx/mag) * 0.3; c.vy += (grad.dy/mag) * 0.3;
          c.packTarget = null; c.status = 'TRACKING SCENT';
        } else { c.packTarget = null; c.status = 'PATROLLING'; }
      } else if (tx === null) { c.packTarget = null; c.status = 'PATROLLING'; }

      if (tx === null && mateElig) {
        const mate = findNearest(c,
          (lists.carns || []).filter(o => o !== c &&
            o.energy >= MATE_ENERGY && o.matingCooldown === 0 && !o.matingWith && o.mateCount < MAX_MATES),
          c.dna.sense * 0.5);
        if (mate) { tx = mate.x; ty = mate.y; c.status = 'SEEKING MATE'; }
      }
    }
  }

  if (tx !== null) {
    const dx = tx - c.x, dy = ty - c.y;
    const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
    c.vx += (dx/d) * 0.4; c.vy += (dy/d) * 0.4;
  } else {
    c.vx += (Math.random()-0.5) * 0.5; c.vy += (Math.random()-0.5) * 0.5;
  }

  // ── FLOCKING (Boids) ────────────────────────────────────────────────────────
  // Neighbours = same type, alive, not sleeping, within flock radius
  const flockRadius = c.dna.sense * 0.6;
  const sepRadius   = c.dna.size * 3.5; // personal space

  let sepX = 0, sepY = 0, sepN = 0;   // separation
  let aliX = 0, aliY = 0, aliN = 0;   // alignment
  let cohX = 0, cohY = 0, cohN = 0;   // cohesion

  for (const o of creatures) {
    if (!o.alive || o === c || o.sleeping || o.dna.type !== c.dna.type) continue;
    const dx = o.x - c.x, dy = o.y - c.y;
    const d2 = dx*dx + dy*dy;
    const fd = flockRadius * flockRadius;
    if (d2 > fd) continue;
    const d = Math.sqrt(d2) + 0.001;

    // Separation — push away from very close neighbours
    if (d < sepRadius) {
      sepX -= dx / d; sepY -= dy / d;
      sepN++;
    }
    // Alignment — match velocity of neighbours
    aliX += o.vx; aliY += o.vy; aliN++;
    // Cohesion — move toward centre of neighbours
    cohX += o.x; cohY += o.y; cohN++;
  }

  const fs = params.flockStr / 10;
  if (c.dna.type === 'herbivore') {
    // Herbivore flocking — safety in numbers
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.35 * fs; c.vy += (sepY/sepN) * 0.35 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.08 * fs; c.vy += (aliY/aliN - c.vy) * 0.08 * fs; }
    if (cohN > 0) {
      const cx = cohX/cohN - c.x, cy = cohY/cohN - c.y;
      const cd = Math.sqrt(cx*cx+cy*cy)+0.001;
      if (tx === null) { c.vx += (cx/cd) * 0.12 * fs; c.vy += (cy/cd) * 0.12 * fs; }
    }
    // Shepherd pull: if a nearby sated omnivore is shepherding, be drawn toward it
    const lists = window._simLists || {};
    const shepherd = findNearest(c,
      (lists.omnis || []).filter(o => o.alive && o.energy >= 270),
      c.dna.sense * 1.6);
    if (shepherd) {
      const sdx = shepherd.x - c.x, sdy = shepherd.y - c.y;
      const sd  = Math.sqrt(sdx*sdx+sdy*sdy)+0.001;
      const shepherdPull = fs * 0.22; // stronger than normal flock cohesion
      c.vx += (sdx/sd) * shepherdPull; c.vy += (sdy/sd) * shepherdPull;
      // Shepherded herbivores share the omnivore's cone vision range (boosted)
      c._shepherdRef  = shepherd; // keep reference so we can draw the distinction
      c._shepherdVision = shepherd.dna.sense * 2.4;
    } else {
      c._shepherdVision = null;
      c._shepherdRef    = null;
    }
  } else if (c.dna.type === 'omnivore') {
    // Omnivores flock loosely with own kind — mild separation only
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.3 * fs; c.vy += (sepY/sepN) * 0.3 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.05 * fs; c.vy += (aliY/aliN - c.vy) * 0.05 * fs; }
  } else {
    // Carnivores spread out
    if (sepN > 0) { c.vx += (sepX/sepN) * 0.5 * fs; c.vy += (sepY/sepN) * 0.5 * fs; }
    if (aliN > 0) { c.vx += (aliX/aliN - c.vx) * 0.04 * fs; c.vy += (aliY/aliN - c.vy) * 0.04 * fs; }
  }

  // Sprint: carnivores/omnivores chasing prey burn ENERGY for speed boost
  // stamina gene = efficiency multiplier; low stamina = more energy per sprint tick
  let maxSpd = c.dna.speed;
  const canSprint = (c.dna.type === 'carnivore' || c.dna.type === 'omnivore')
                    && tx !== null && c.energy > 40  // need >13% energy to sprint
                    && (c.status === 'CHASING' || c.status === 'STALKING'
                        || c.status === 'PACK FLANKING' || c.status === 'HUNTING MATING PREY'
                        || c.status === 'CANNIBALISING');
  if (canSprint) {
    maxSpd = c.dna.speed * 1.6;
    // Energy cost: base 0.08 per tick, divided by stamina gene (0.1–1.0)
    // Low stamina = more expensive sprint; high stamina = efficient
    const sprintCost = 0.08 / Math.max(0.1, c.dna.stamina);
    c.energy -= sprintCost;
    c.sprinting = true;
  }

  const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
  if (spd > maxSpd) { c.vx = (c.vx/spd)*maxSpd; c.vy = (c.vy/spd)*maxSpd; }
  c.x += c.vx; c.y += c.vy;
  if (c.x < 0) c.x += W; if (c.x > W) c.x -= W;
  if (c.y < 0) c.y += H; if (c.y > H) c.y -= H;

  // Herbivores and omnivores eat food when below sated threshold
  if ((c.dna.type === 'herbivore' || c.dna.type === 'omnivore') && !isSated) {
    for (let i = foods.length - 1; i >= 0; i--) {
      if (dist(c, foods[i]) < c.dna.size + 4) {
        c.energy += foods[i].energy;
        foods.splice(i, 1);
        break;
      }
    }
  }
  // Omnivores scavenge corpses (all types)
  if (c.dna.type === 'omnivore' && !isSated) {
    for (let i = corpses.length - 1; i >= 0; i--) {
      if (dist(c, corpses[i]) < c.dna.size + 5) {
        c.energy += corpses[i].energy;
        corpses.splice(i, 1);
        break;
      }
    }
  }

  // Carnivores hunt ONLY when below sated threshold (90%)
  if (c.dna.type === 'carnivore' && !isSated) {
    let ate = false;
    for (const prey of creatures) {
      if (!prey.alive || prey === c) continue;
      const isPurple       = prey.matingWith !== null;
      const isHerbivore    = prey.dna.type === 'herbivore';
      const isSleeping     = prey.sleeping;
      const isWeakCarnivore = prey.dna.type === 'carnivore'
                              && prey.energy < 30 && prey.age < c.age * 0.5;
      const isVulnOmnivore = prey.dna.type === 'omnivore'
                              && (prey.sleeping || prey.energy < 30);
      const edible = isPurple || isHerbivore || (isSleeping && prey !== c) || isWeakCarnivore || isVulnOmnivore;
      if (edible && dist(c, prey) < c.dna.size + prey.dna.size) {
        c.energy += prey.energy * 0.6;
        if (prey.matingWith) { prey.matingWith.matingWith = null; prey.matingWith.matingTicks = 0; }
        // Wake nearby sleepers if this prey was asleep
        if (prey.sleeping) {
          for (const neighbour of creatures) {
            if (neighbour !== prey && neighbour.sleeping && dist(neighbour, prey) < neighbour.dna.sense) {
              neighbour.sleeping = false;
              neighbour.sleepTicks = 0;
              neighbour.sleepCooldown = 400 + Math.floor(Math.random() * 300);
              // Scatter in random direction at high speed
              const ang = Math.random() * Math.PI * 2;
              neighbour.vx = Math.cos(ang) * neighbour.dna.speed * 2;
              neighbour.vy = Math.sin(ang) * neighbour.dna.speed * 2;
              neighbour.wakeScatter = 60;
            }
          }
        }
        prey.alive = false;
        ate = true;
        break;
      }
    }
    // Also scavenge nearby corpses
    if (!ate) {
      for (let i = corpses.length - 1; i >= 0; i--) {
        if (dist(c, corpses[i]) < c.dna.size + 5) {
          c.energy += corpses[i].energy;
          corpses.splice(i, 1);
          break;
        }
      }
    }
  }

  // Initiate mating — requires 80%+ energy, under retirement limit, not sleeping
  if (mateElig && !c.sleeping && c.wakeScatter === 0) {
    const lists = window._simLists || {};
    const sameType = (c.dna.type === 'herbivore' ? lists.herbs
                    : c.dna.type === 'carnivore' ? lists.carns
                    : lists.omnis) || [];
    for (const other of sameType) {
      if (other === c || other.matingWith || other.matingCooldown > 0) continue;
      const otherMax = other.dna.type === 'herbivore' ? 3 : 5;
      if (other.mateCount >= otherMax || other.energy < MATE_ENERGY) continue;
      if (dist(c, other) < c.dna.size + other.dna.size + 5) {
        c.matingWith = other; c.matingTicks = 0;
        other.matingWith = c; other.matingTicks = 0;
        break;
      }
    }
  }

  c.energy = Math.min(c.energy, 300);
}

function updateSim() {
  tick++;

  // Food grows by spreading from existing food — no random teleport spawning
  if (foods.length < params.maxFood && foods.length > 0) {
    // Each tick, each food pellet has a small chance to sprout a neighbour nearby
    const growthChance = params.foodRate * 0.0003; // slider controls spread speed
    for (let i = 0; i < foods.length && foods.length < params.maxFood; i++) {
      if (Math.random() < growthChance) {
        const parent = foods[i];
        // Spread radius: closer neighbours more likely, max 60px
        const angle = Math.random() * Math.PI * 2;
        const r = 10 + Math.random() * 50;
        const nx = parent.x + Math.cos(angle) * r;
        const ny = parent.y + Math.sin(angle) * r;
        // Only sprout if within canvas bounds
        if (nx > 0 && nx < canvas.width && ny > 0 && ny < canvas.height) {
          foods.push(createFood(nx, ny));
        }
      }
    }
  }

  // Deposit pheromones — alive, non-sleeping agents leave scent trails
  if (pheroHerb && pheroCarn) {
    for (const c of creatures) {
      if (!c.alive || c.sleeping) continue;
      if (c.dna.type === 'herbivore') depositPhero(pheroHerb, c.x, c.y, 0.18);
      else if (c.dna.type === 'carnivore') depositPhero(pheroCarn, c.x, c.y, 0.18);
      // Omnivores deposit on their own channel — distinct cyan, carnivores can still track
      else if (c.dna.type === 'omnivore') depositPhero(pheroOmni, c.x, c.y, 0.18);
    }
    updatePhero(pheroHerb);
    updatePhero(pheroCarn);
    updatePhero(pheroOmni);
  }

  // Pre-build filtered lists once per tick for performance
  const _alive      = creatures.filter(c => c.alive);
  const _herbs      = _alive.filter(c => c.dna.type === 'herbivore');
  const _carns      = _alive.filter(c => c.dna.type === 'carnivore');
  const _omnis      = _alive.filter(c => c.dna.type === 'omnivore');
  const _mating     = _alive.filter(c => c.matingWith !== null);
  const _sleeping   = _alive.filter(c => c.sleeping);
  window._simLists  = { alive: _alive, herbs: _herbs, carns: _carns, omnis: _omnis, mating: _mating, sleeping: _sleeping };

  for (const c of creatures) updateCreature(c);

  // Decay corpses over time
  for (const corp of corpses) corp.decay++;
  corpses = corpses.filter(corp => corp.decay < 300);

  creatures = creatures.filter(c => c.alive || (c.age++ < 60));

  if (creatures.filter(c => c.dna.type === 'herbivore').length > 500)
    creatures = creatures.filter(c => c.dna.type !== 'herbivore' || Math.random() > 0.1);
  if (creatures.filter(c => c.dna.type === 'carnivore').length > 500)
    creatures = creatures.filter(c => c.dna.type !== 'carnivore' || Math.random() > 0.1);
  if (creatures.filter(c => c.dna.type === 'omnivore').length > 500)
    creatures = creatures.filter(c => c.dna.type !== 'omnivore' || Math.random() > 0.1);

  if (tick % 60 === 0) {
    const alive = creatures.filter(c => c.alive);
    history.h.push(alive.filter(c => c.dna.type === 'herbivore').length);
    history.c.push(alive.filter(c => c.dna.type === 'carnivore').length);
    history.o.push(alive.filter(c => c.dna.type === 'omnivore').length);
    history.f.push(foods.length);
    if (history.h.length > MAX_HISTORY) { history.h.shift(); history.c.shift(); history.o.shift(); history.f.shift(); }
  }
}

// ── Draw ──────────────────────────────────────────────────────────────────────
function drawCreature(c) {
  const alive = c.alive;
  const alpha = alive ? 1.0 : Math.max(0, 1 - (c.age - 3940) / 60);
  if (alpha <= 0) return;

  const isH      = c.dna.type === 'herbivore';
  const isO      = c.dna.type === 'omnivore';
  const isMating = alive && c.matingWith !== null;
  const r        = c.dna.size;

  // Energy-based brightness/saturation: 20% min -> 100% at full energy
  const ePct = alive ? Math.max(0, Math.min(1, c.energy / 300)) : 0;
  const sat  = Math.round(30 + ePct * 70);  // 30%–100% saturation
  const lit  = Math.round(20 + ePct * 45);  // 20%–65% lightness

  // Base hue per type: mating=267(purple), herbivore=168(teal), carnivore=348(red)
  const isSleepingDraw = alive && c.sleeping;
  const hue = isMating ? 267 : isSleepingDraw ? 220 : (isH ? 168 : isO ? 185 : 348);
  // glowRGB per type for rgba() calls
  const typeGlowRGB = isH ? '0,245,196' : isO ? '0,220,180' : '255,77,109';
  const baseColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#2a2a3a';
  const glowColor  = alive ? `hsl(${hue},${sat}%,${lit}%)` : '#444';
  // Extract approximate RGB for rgba() glow uses
  const glowRGB    = alive ? (isMating ? '162,155,254' : typeGlowRGB) : '68,68,68';
  const trailColor = isMating ? `hsla(267,${sat}%,${lit}%,0.2)` : `hsla(${hue},${sat}%,${lit}%,0.15)`;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Trail
  if (alive && c.trail.length > 1) {
    ctx.beginPath();
    ctx.moveTo(c.trail[0].x, c.trail[0].y);
    for (let i = 1; i < c.trail.length; i++) ctx.lineTo(c.trail[i].x, c.trail[i].y);
    ctx.strokeStyle = trailColor;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Vision indicator (selected only)
  if (c === selectedCreature && alive) {
    const heading = Math.atan2(c.vy, c.vx);
    ctx.setLineDash([3, 5]);
    if (isH) {
      // Own sense circle — always shown at agent's actual range
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.15)`; ctx.lineWidth = 1; ctx.stroke();
      // Shepherd-boosted vision — outer ring in omnivore cyan, dashed, translucent
      if (c._shepherdVision) {
        ctx.setLineDash([5, 7]);
        ctx.beginPath(); ctx.arc(c.x, c.y, c._shepherdVision, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0,220,255,0.22)`;
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([3, 5]); // restore for rest of vision block
      }
    } else if (isO) {
      // Omnivore: cone + circle (dual)
      const coneRange = c.dna.sense * 1.8;
      ctx.beginPath(); ctx.moveTo(c.x, c.y);
      ctx.arc(c.x, c.y, coneRange, heading - Math.PI/3, heading + Math.PI/3);
      ctx.closePath();
      ctx.strokeStyle = `rgba(${glowRGB},0.12)`; ctx.fillStyle = `rgba(${glowRGB},0.04)`;
      ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense * 0.6, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.08)`; ctx.setLineDash([2,6]); ctx.stroke();
    } else {
      // Carnivore: cone only
      const coneRange = c.dna.sense * 1.8;
      ctx.beginPath(); ctx.moveTo(c.x, c.y);
      ctx.arc(c.x, c.y, coneRange, heading - Math.PI/3, heading + Math.PI/3);
      ctx.closePath();
      ctx.strokeStyle = `rgba(${glowRGB},0.12)`; ctx.fillStyle = `rgba(${glowRGB},0.04)`;
      ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
      ctx.setLineDash([2,6]);
      ctx.beginPath(); ctx.arc(c.x, c.y, c.dna.sense * 0.4, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${glowRGB},0.07)`; ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  // Sleep indicator: zzz rings when asleep
  if (alive && c.sleeping) {
    ctx.save();
    ctx.globalAlpha = (alpha * 0.6);
    // Pulsing outer ring in dim blue-grey
    const pulse = 0.5 + 0.5 * Math.sin(tick * 0.08);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + pulse * 4, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(120,140,200,${0.4 + pulse * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([3, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
    // Tiny 'z' indicators floating upward
    for (let z = 0; z < 3; z++) {
      const zAge = (tick + z * 30) % 90;
      const zAlpha = zAge < 45 ? zAge / 45 : (90 - zAge) / 45;
      const zY = c.y - r - 6 - zAge * 0.25;
      const zX = c.x + r + 2 + z * 4;
      ctx.globalAlpha = alpha * zAlpha * 0.7;
      ctx.fillStyle = 'rgba(160,180,240,1)';
      ctx.font = `${7 + z}px monospace`;
      ctx.fillText('z', zX, zY);
    }
    ctx.restore();
  }

  // Mating pulse ring + progress arc
  if (isMating) {
    const progress = c.matingTicks / MATING_DURATION;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5 + Math.sin(tick * 0.25) * 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(162,155,254,${0.25 + progress * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 9, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
    ctx.strokeStyle = 'rgba(162,155,254,0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Outer glow
  if (alive) {
    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r * 3);
    g.addColorStop(0, `rgba(${glowRGB},0.3)`);
    g.addColorStop(1, `rgba(${glowRGB},0)`);
    ctx.beginPath();
    ctx.arc(c.x, c.y, r * 3, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
  }

  // Body
  ctx.beginPath();
  if (isH) {
    // Hexagon
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
      const px = c.x + Math.cos(angle) * r, py = c.y + Math.sin(angle) * r;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
  } else if (isO) {
    // Circle (omnivore)
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    // Shepherd ring if sated
    if (alive && c.energy >= 270) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(c.x, c.y, r * 3.5 + Math.sin(tick * 0.05) * 2, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(0,220,180,${0.12 + 0.08 * Math.sin(tick*0.05)})`;
      ctx.lineWidth = 1;
      ctx.setLineDash([4,6]);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  } else {
    // Diamond (carnivore)
    ctx.moveTo(c.x,     c.y - r * 1.3);
    ctx.lineTo(c.x + r, c.y);
    ctx.lineTo(c.x,     c.y + r * 1.3);
    ctx.lineTo(c.x - r, c.y);
    ctx.closePath();
  }

  if (alive) {
    ctx.fillStyle = baseColor;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = isMating ? 14 : 8;
    ctx.fill();
    ctx.shadowBlur = 0;
  } else {
    ctx.fillStyle = '#1a1a2a';
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }

  // Direction nub + sprint streak
  if (alive) {
    const angle = Math.atan2(c.vy, c.vx);
    if (c.sprinting) {
      // Orange motion streak behind the carnivore
      ctx.beginPath();
      ctx.moveTo(c.x, c.y);
      ctx.lineTo(c.x - Math.cos(angle) * r * 4, c.y - Math.sin(angle) * r * 4);
      ctx.strokeStyle = `rgba(255,160,50,${0.3 + c.staminaCur * 0.4})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x + Math.cos(angle) * r * 1.8, c.y + Math.sin(angle) * r * 1.8);
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Energy bar
  if (alive) {
    const bw = r * 2.5, bh = 2;
    const bx = c.x - bw/2, by = c.y + r + 3;
    const pct = Math.min(1, c.energy / 200);
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = isMating ? '#a29bfe'
                  : pct > 0.5 ? '#00f5c4'
                  : pct > 0.25 ? '#ffd166' : '#ff4d6d';
    ctx.fillRect(bx, by, bw * pct, bh);
  }

  ctx.restore();
}

function drawFood(f) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#ffd166';
  ctx.shadowColor = '#ffd166';
  ctx.shadowBlur = 6;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawCorpse(corp) {
  const age = corp.decay / 300; // 0=fresh, 1=gone
  const alpha = 1 - age * 0.8;
  const r = 3 + (1 - age) * 2;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.arc(corp.x, corp.y, r, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(30,${Math.round(40 - age*30)}%,${Math.round(18 + age*8)}%)`;
  ctx.shadowColor = 'rgba(80,40,0,0.3)';
  ctx.shadowBlur = 4;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Small X to distinguish from food
  ctx.strokeStyle = `rgba(100,60,20,${0.5 * alpha})`;
  ctx.lineWidth = 0.7;
  ctx.beginPath(); ctx.moveTo(corp.x - r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x + r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(corp.x + r*0.5, corp.y - r*0.5); ctx.lineTo(corp.x - r*0.5, corp.y + r*0.5); ctx.stroke();
  ctx.restore();
}

function drawChart() {
  const w = chartCanvas.width, h = chartCanvas.height;
  chartCtx.clearRect(0, 0, w, h);
  chartCtx.fillStyle = '#060810';
  chartCtx.fillRect(0, 0, w, h);
  const all = [...history.h, ...history.c, ...history.f];
  const maxVal = Math.max(...all, 1);
  if (history.h.length < 2) return;

  const line = (data, color) => {
    chartCtx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = (i / (MAX_HISTORY - 1)) * w;
      const y = h - (data[i] / maxVal) * h * 0.9 - 2;
      i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
    }
    chartCtx.strokeStyle = color;
    chartCtx.lineWidth = 1.5;
    chartCtx.stroke();
  };
  line(history.h, '#00f5c4');
  line(history.c, '#ff4d6d');
  line(history.o, '#00dce0');
  line(history.f, '#ffd166');
}

function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(6,8,16,0.85)';
  ctx.fillRect(0, 0, W, H);

  // Draw pheromone layers as subtle coloured mist
  if (pheroHerb && pheroCarn && params.showPhero) {
    for (let gy = 0; gy < pheroH; gy++) {
      for (let gx = 0; gx < pheroW; gx++) {
        const hi = pheroHerb[pheroIdx(gx, gy)];
        const ci = pheroCarn[pheroIdx(gx, gy)];
        const oi = pheroOmni ? pheroOmni[pheroIdx(gx, gy)] : 0;
        const px = gx * PHERO_CELL, py = gy * PHERO_CELL;
        if (hi > 0.03) {
          ctx.fillStyle = `rgba(0,245,196,${(hi * 0.25).toFixed(3)})`; // teal-green
          ctx.fillRect(px, py, PHERO_CELL, PHERO_CELL);
        }
        if (oi > 0.03) {
          ctx.fillStyle = `rgba(0,210,255,${(oi * 0.28).toFixed(3)})`; // distinct bright cyan
          ctx.fillRect(px, py, PHERO_CELL, PHERO_CELL);
        }
        if (ci > 0.03) {
          ctx.fillStyle = `rgba(255,77,109,${(ci * 0.22).toFixed(3)})`; // red
          ctx.fillRect(px, py, PHERO_CELL, PHERO_CELL);
        }
      }
    }
  }

  if (selectedCreature && selectedCreature.alive) {
    ctx.beginPath();
    ctx.arc(selectedCreature.x, selectedCreature.y, selectedCreature.dna.size + 10, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  for (const corp of corpses) drawCorpse(corp);
  for (const f of foods) drawFood(f);
  for (const c of creatures) drawCreature(c);
}

// ── UI ────────────────────────────────────────────────────────────────────────
function updateUI() {
  const alive = creatures.filter(c => c.alive);
  document.getElementById('hPop').textContent   = alive.filter(c => c.dna.type === 'herbivore').length;
  document.getElementById('cPop').textContent   = alive.filter(c => c.dna.type === 'carnivore').length;
  const oPop = document.getElementById('oPop'); if (oPop) oPop.textContent = alive.filter(c => c.dna.type === 'omnivore').length;
  document.getElementById('fPop').textContent   = foods.length;
  document.getElementById('genNum').textContent  = generation;
  document.getElementById('tickNum').textContent = tick;

  if (selectedCreature) {
    const c = selectedCreature, d = c.dna;
    const info = document.getElementById('infoBox');
    if (!c.alive) {
      info.innerHTML = '<b>DECEASED</b><br>Age: ' + c.age;
    } else {
      const energyPct = Math.round((c.energy / 300) * 100);
      const isSated = c.energy >= 270;
      const maxedOut = c.mateCount >= 3;
      const stateTag = c.sleeping
        ? `<br><b style="color:#a0b4f0">💤 SLEEPING (${c.sleepTicks} ticks)</b>`
        : c.matingWith
          ? `<br><b style="color:#a29bfe">● MATING ${Math.round((c.matingTicks/MATING_DURATION)*100)}%</b>`
          : isSated && !maxedOut
            ? `<br><b style="color:#ffd166">◈ SATED — seeking mate</b>`
            : isSated && maxedOut
              ? `<br><b style="color:#ffd166">◈ SATED — retired</b>`
              : maxedOut
                ? `<br><b style="color:#636e72">✕ RETIRED — 3/3 matings</b>`
                : c.matingCooldown > 0
                  ? `<br><b style="color:#636e72">◌ COOLDOWN ${c.matingCooldown}</b>`
                  : '';
      const staminaBar = (d.type === 'carnivore' || d.type === 'omnivore')
        ? `<br><b>STAMINA:</b> <b style="opacity:0.5">gene ${(d.stamina??1).toFixed(2)}</b>${c.sprinting ? ' <b style="color:#ffa032">⚡ SPRINTING</b>' : ''}`
        : '';
      info.innerHTML = `
        <b>TYPE:</b> ${d.type.toUpperCase()}<br>
        <b>STATUS:</b> <b style="color:var(--accent)">${c.status || '—'}</b><br>
        <b>ENERGY:</b> ${Math.round(c.energy)} <b style="opacity:0.5">(${energyPct}%)</b><br>
        <b>AGE:</b> ${c.age}<br>
        <b>GEN:</b> ${c.gen}<br>
        <b>MATINGS:</b> ${c.mateCount}/3${maxedOut ? ' <b style="color:var(--accent2)">RETIRED</b>' : ''}<br>
        <br>
        <b>— GENOME —</b><br>
        <b>SPEED:</b> ${d.speed.toFixed(2)}<br>
        <b>SENSE:</b> ${Math.round(d.sense)}${d.type==='carnivore' ? ' <b style="opacity:0.4">(cone)</b>' : ''}<br>
        <b>SIZE:</b> ${d.size.toFixed(2)}<br>
        <b>FERTILITY:</b> ${(d.fertility*1000).toFixed(2)}‰<br>
        <b>METABOLISM:</b> ${d.metabolism.toFixed(3)}<br>
        <b>AGGRESSION:</b> ${d.aggression.toFixed(2)}${staminaBar}${stateTag}
      `;
    }
  }
}

// ── Loop ──────────────────────────────────────────────────────────────────────
let lastFPSTime = performance.now(), frames = 0;

function loop() {
  const now = performance.now();
  frames++;
  if (now - lastFPSTime > 1000) {
    document.getElementById('fpsDisplay').textContent = frames + ' FPS';
    frames = 0; lastFPSTime = now;
  }
  if (playing) {
    for (let i = 0; i < speed; i++) updateSim();
  }
  updateUI(); // Always refresh panel so selected creature info stays live
  render();
  drawChart();
  requestAnimationFrame(loop);
}

// ── Controls ──────────────────────────────────────────────────────────────────
function togglePlay() {
  playing = !playing;
  const btn = document.getElementById('playBtn');
  btn.textContent = playing ? '⏸ PAUSE' : '▶ PLAY';
  btn.classList.toggle('active', playing);
}

function updateSpeed(el) {
  speed = parseInt(el.value);
  document.getElementById('speedVal').textContent = speed;
}

function updateParam(key, el) {
  params[key] = parseInt(el.value);
  document.getElementById(key + 'Val').textContent = params[key] + (key === 'mutRate' ? '%' : '');
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  let clicked = null;
  // Generous hit radius so small creatures are easy to click
  for (const c of creatures) {
    if (c.alive && dist(c, { x: mx, y: my }) < Math.max(c.dna.size + 12, 18)) { clicked = c; break; }
  }
  if (clicked) {
    selectedCreature = clicked;
    updateUI(); // Refresh panel immediately, even when paused
  } else {
    selectedCreature = null; // Just deselect — no food placement on empty click
  }
});

function resize() {
  const panel  = document.querySelector('.panel');
  const header = document.querySelector('header');
  const footer = document.querySelector('footer');
  canvas.width        = window.innerWidth - panel.offsetWidth;
  canvas.height       = window.innerHeight - header.offsetHeight - footer.offsetHeight;
  chartCanvas.width   = panel.offsetWidth - 24;
  chartCanvas.height  = 60;
  initPhero();
}

window.addEventListener('resize', resize);
resize();
resetSim();
loop();

function togglePhero() {
  params.showPhero = !params.showPhero;
  const btn = document.getElementById('pheroBtn');
  btn.textContent = params.showPhero ? '◎ HIDE SCENT TRAILS' : '◎ SHOW SCENT TRAILS';
  btn.classList.toggle('active', params.showPhero);
}

// ── Spawn quantity selector ────────────────────────────────────────────────────
let currentQty = 1;

function spawnAmt() { return currentQty; }

function setQty(n) {
  currentQty = n;
  document.querySelectorAll('.qty-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('qty' + n).classList.add('active');
  // Update button labels
  const plural = s => n === 1 ? '' : 'S';
  document.getElementById('spawnHlbl').textContent = n;
  document.getElementById('spawnClbl').textContent = n;
  document.getElementById('spawnOlbl').textContent = n;
  document.getElementById('spawnFlbl').textContent = n;
  document.getElementById('spawnHs').textContent = plural('S');
  document.getElementById('spawnCs').textContent = plural('S');
  document.getElementById('spawnOs').textContent = plural('S');
}
</script>
</body>
</html>
